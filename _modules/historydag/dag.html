<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>historydag.dag &mdash; historydag  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> historydag
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">Description</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html#classes">Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html#functions">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html#modules">Modules</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">historydag</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">historydag.dag</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for historydag.dag</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;A module providing the class HistoryDag, and supporting functions.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>
<span class="kn">import</span> <span class="nn">graphviz</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">ete3</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Generator</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">NamedTuple</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">FrozenSet</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">historydag</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">historydag.utils</span> <span class="kn">import</span> <span class="n">Weight</span><span class="p">,</span> <span class="n">Label</span><span class="p">,</span> <span class="n">UALabel</span><span class="p">,</span> <span class="n">prod</span>
<span class="kn">from</span> <span class="nn">historydag.counterops</span> <span class="kn">import</span> <span class="n">counter_sum</span><span class="p">,</span> <span class="n">counter_prod</span>


<span class="k">def</span> <span class="nf">_clade_union_dict</span><span class="p">(</span><span class="n">nodeseq</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
    <span class="n">clade_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="n">Label</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodeseq</span><span class="p">:</span>
        <span class="n">clade_union</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">clade_union</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">clade_dict</span><span class="p">:</span>
            <span class="n">clade_dict</span><span class="p">[</span><span class="n">clade_union</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">clade_dict</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">clade_dict</span>


<div class="viewcode-block" id="HistoryDagNode"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDagNode">[docs]</a><span class="k">class</span> <span class="nc">HistoryDagNode</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A recursive representation of a history DAG object.</span>

<span class="sd">    - a dictionary keyed by clades (frozensets) containing EdgeSet objects</span>
<span class="sd">    - a label, which is a namedtuple.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HistoryDagNode.__init__"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDagNode.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Label</span><span class="p">,</span> <span class="n">clades</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clades</span> <span class="o">=</span> <span class="n">clades</span>
        <span class="c1"># If passed a nonempty dictionary, need to add self to children&#39;s parents</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="n">attr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dp_data</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">edgeset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">edgeset</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Internal nodes (those which are not the DAG UA root node) &quot;</span>
                <span class="s2">&quot;may not have exactly one child clade; Unifurcations cannot be expressed &quot;</span>
                <span class="s2">&quot;in the history DAG.&quot;</span>
            <span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_clades</span><span class="p">()))</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">HistoryDagNode</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_clades</span><span class="p">())</span> <span class="o">==</span> <span class="p">(</span>
                <span class="n">other</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
                <span class="n">other</span><span class="o">.</span><span class="n">child_clades</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">HistoryDagNode</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_child_clades</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="p">(</span>
                <span class="n">other</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
                <span class="n">other</span><span class="o">.</span><span class="n">sorted_child_clades</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">HistoryDagNode</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_child_clades</span><span class="p">())</span> <span class="o">&lt;</span> <span class="p">(</span>
                <span class="n">other</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
                <span class="n">other</span><span class="o">.</span><span class="n">sorted_child_clades</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__le__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__lt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="HistoryDagNode.empty_copy"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDagNode.empty_copy">[docs]</a>    <span class="k">def</span> <span class="nf">empty_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a HistoryDagNode object with the same clades, label, and</span>
<span class="sd">        attr dictionary, but no descendant edges.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">HistoryDagNode</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="p">{</span><span class="n">clade</span><span class="p">:</span> <span class="n">EdgeSet</span><span class="p">()</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">},</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDagNode.node_self"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDagNode.node_self">[docs]</a>    <span class="k">def</span> <span class="nf">node_self</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Deprecated name for :meth:`empty_copy`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="HistoryDagNode.clade_union"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDagNode.clade_union">[docs]</a>    <span class="k">def</span> <span class="nf">clade_union</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="n">Label</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the union of this node&#39;s child clades (or a set containing</span>
<span class="sd">        only the node label, for leaf nodes.)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="k">return</span> <span class="nb">frozenset</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">frozenset</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

<div class="viewcode-block" id="HistoryDagNode.under_clade"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDagNode.under_clade">[docs]</a>    <span class="k">def</span> <span class="nf">under_clade</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="n">Label</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Deprecated name for :meth:`clade_union`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span></div>

<div class="viewcode-block" id="HistoryDagNode.is_leaf"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDagNode.is_leaf">[docs]</a>    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether this is a leaf node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDagNode.is_ua_node"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDagNode.is_ua_node">[docs]</a>    <span class="k">def</span> <span class="nf">is_ua_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether this is the source node in the DAG, from which all</span>
<span class="sd">        others are reachable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="HistoryDagNode.is_root"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDagNode.is_root">[docs]</a>    <span class="k">def</span> <span class="nf">is_root</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Deprecated name for :meth:`is_ua_node`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()</span></div>

<div class="viewcode-block" id="HistoryDagNode.is_history_root"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDagNode.is_history_root">[docs]</a>    <span class="k">def</span> <span class="nf">is_history_root</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return whether node is a root of any histories in the DAG.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDagNode.child_clades"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDagNode.child_clades">[docs]</a>    <span class="k">def</span> <span class="nf">child_clades</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">frozenset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the node&#39;s child clades, or a frozenset containing a</span>
<span class="sd">        frozenset if this node is a UANode.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

<div class="viewcode-block" id="HistoryDagNode.partitions"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDagNode.partitions">[docs]</a>    <span class="k">def</span> <span class="nf">partitions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">frozenset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Deprecated name for :meth:`child_clades`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_clades</span><span class="p">()</span></div>

<div class="viewcode-block" id="HistoryDagNode.sorted_child_clades"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDagNode.sorted_child_clades">[docs]</a>    <span class="k">def</span> <span class="nf">sorted_child_clades</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the node&#39;s child clades as a sorted tuple containing leaf</span>
<span class="sd">        labels in sorted tuples.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">clade</span><span class="p">))</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">keys</span><span class="p">()]))</span></div>

<div class="viewcode-block" id="HistoryDagNode.sorted_partitions"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDagNode.sorted_partitions">[docs]</a>    <span class="k">def</span> <span class="nf">sorted_partitions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Deprecated name for :meth:`sorted_child_clades`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_child_clades</span><span class="p">()</span></div>

<div class="viewcode-block" id="HistoryDagNode.children"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDagNode.children">[docs]</a>    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">clade</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Label</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns generator object containing child nodes.</span>

<span class="sd">        Args:</span>
<span class="sd">            clade: If clade is provided, returns generator object of edge targets from that</span>
<span class="sd">        clade. If no clade is provided, generator includes all children of self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">clade</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">target</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span> <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">child</span> <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">])</span></div>

<div class="viewcode-block" id="HistoryDagNode.add_edge"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDagNode.add_edge">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span>
        <span class="n">weight</span><span class="p">:</span> <span class="n">Weight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prob_norm</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Adds edge, if allowed and not already present.</span>

<span class="sd">        Returns whether edge was added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># target clades must union to a clade of self</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()</span> <span class="k">else</span> <span class="n">target</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Target clades&#39; union is not a clade of this parent node: &quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">add_to_edgeset</span><span class="p">(</span>
                <span class="n">target</span><span class="p">,</span>
                <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span>
                <span class="n">prob</span><span class="o">=</span><span class="n">prob</span><span class="p">,</span>
                <span class="n">prob_norm</span><span class="o">=</span><span class="n">prob_norm</span><span class="p">,</span>
            <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_subhistory_by_subid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subid</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the subtree below the current HistoryDagNode corresponding</span>
<span class="sd">        to the given index.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>  <span class="c1"># base case - the node is a leaf</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">()</span>

            <span class="c1"># get the subtree for each of the clades</span>
            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># get the sum of subtrees of the edges for this clade</span>
                <span class="n">num_subtrees</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">eset</span><span class="p">:</span>
                    <span class="n">num_subtrees</span> <span class="o">=</span> <span class="n">num_subtrees</span> <span class="o">+</span> <span class="n">child</span><span class="o">.</span><span class="n">_dp_data</span>
                <span class="n">curr_index</span> <span class="o">=</span> <span class="n">subid</span> <span class="o">%</span> <span class="n">num_subtrees</span>

                <span class="c1"># find the edge corresponding to the curr_index</span>
                <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">eset</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">curr_index</span> <span class="o">&gt;=</span> <span class="n">child</span><span class="o">.</span><span class="n">_dp_data</span><span class="p">:</span>
                        <span class="n">curr_index</span> <span class="o">=</span> <span class="n">curr_index</span> <span class="o">-</span> <span class="n">child</span><span class="o">.</span><span class="n">_dp_data</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># add this edge to the tree somehow</span>
                        <span class="n">history</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span><span class="o">.</span><span class="n">add_to_edgeset</span><span class="p">(</span>
                            <span class="n">child</span><span class="o">.</span><span class="n">_get_subhistory_by_subid</span><span class="p">(</span><span class="n">curr_index</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">break</span>

                <span class="n">subid</span> <span class="o">=</span> <span class="n">subid</span> <span class="o">/</span> <span class="n">num_subtrees</span>
        <span class="k">return</span> <span class="n">history</span>

    <span class="k">def</span> <span class="nf">remove_edge_by_clade_and_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="n">clade</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">):</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">frozenset</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">clade</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">remove_from_edgeset_byid</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

<div class="viewcode-block" id="HistoryDagNode.remove_node"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDagNode.remove_node">[docs]</a>    <span class="k">def</span> <span class="nf">remove_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodedict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Recursively removes node self and any orphaned children from dag.</span>

<span class="sd">        May not work on root. Does not check to make sure that parent</span>
<span class="sd">        clade still has descendant edges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">nodedict</span><span class="p">:</span>
            <span class="n">nodedict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                <span class="n">child</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">nodedict</span><span class="o">=</span><span class="n">nodedict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">remove_edge_by_clade_and_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">clade_union</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">removed</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="k">def</span> <span class="nf">_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_selector</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Samples a history (a sub-history DAG containing the root and all</span>
<span class="sd">        leaf nodes).</span>

<span class="sd">        Returns a new HistoryDagNode object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge_selector</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span> <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">]</span>
            <span class="n">sampled_target</span><span class="p">,</span> <span class="n">target_weight</span> <span class="o">=</span> <span class="n">eset</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">sampled_target_subsample</span> <span class="o">=</span> <span class="n">sampled_target</span><span class="o">.</span><span class="n">_sample</span><span class="p">(</span>
                <span class="n">edge_selector</span><span class="o">=</span><span class="n">edge_selector</span>
            <span class="p">)</span>
            <span class="n">sampled_target_subsample</span><span class="o">.</span><span class="n">parents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>
            <span class="n">sample</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span><span class="o">.</span><span class="n">add_to_edgeset</span><span class="p">(</span>
                <span class="n">sampled_target_subsample</span><span class="p">,</span>
                <span class="n">weight</span><span class="o">=</span><span class="n">target_weight</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">sample</span>

    <span class="k">def</span> <span class="nf">_get_subhistories</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return a generator to iterate through all trees expressed by the</span>
<span class="sd">        DAG.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">genexp_func</span><span class="p">(</span><span class="n">clade</span><span class="p">):</span>
            <span class="c1"># Return generator expression of all possible choices of tree</span>
            <span class="c1"># structure from dag below clade</span>
            <span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
                <span class="n">eset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">clade</span><span class="p">,</span> <span class="n">targettree</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">targettree</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">_get_subhistories</span><span class="p">()</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">f</span>

        <span class="n">optionlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">genexp_func</span><span class="p">(</span><span class="n">clade</span><span class="p">)</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">]</span>

        <span class="c1"># TODO is this duplicated code?</span>
        <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">utils</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">optionlist</span><span class="p">):</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">targettree</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">option</span><span class="p">:</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span><span class="o">.</span><span class="n">add_to_edgeset</span><span class="p">(</span>
                    <span class="n">targettree</span><span class="p">,</span>
                    <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="k">yield</span> <span class="n">tree</span>

    <span class="k">def</span> <span class="nf">_newick_label</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;unnamed&quot;</span><span class="p">),</span>
        <span class="n">features</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">feature_funcs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return an extended newick format node label.</span>

<span class="sd">        Args:</span>
<span class="sd">            name_func: A function which maps nodes to names</span>
<span class="sd">            features: A list of label fields to be recorded in extended newick format</span>
<span class="sd">            feature_funcs: A dictionary keyed by extended newick field names containing</span>
<span class="sd">                functions which map nodes to field values. These override fields named</span>
<span class="sd">                in `features`, if a key in `feature_funcs` is also contained in `features`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A string which can be used as a node name in a newick string.</span>
<span class="sd">            For example, `namefuncresult[&amp;&amp;NHX:feature1=val1:feature2=val2]`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span>  <span class="c1"># type: ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">_fields</span>
            <span class="c1"># Use dict to avoid duplicate fields</span>
            <span class="n">nameval_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">val</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">features</span>
            <span class="p">}</span>
            <span class="n">nameval_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">feature_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
            <span class="n">featurestr</span> <span class="o">=</span> <span class="s2">&quot;:&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">nameval_dict</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">name_func</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[&amp;&amp;NHX:</span><span class="si">{</span><span class="n">featurestr</span><span class="si">}</span><span class="s2">]&quot;</span> <span class="k">if</span> <span class="n">featurestr</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="UANode"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.UANode">[docs]</a><span class="k">class</span> <span class="nc">UANode</span><span class="p">(</span><span class="n">HistoryDagNode</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A universal ancestor node, the root node of a HistoryDag.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="UANode.__init__"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.UANode.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">targetnodes</span><span class="p">:</span> <span class="s2">&quot;EdgeSet&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">UALabel</span><span class="p">()</span>
        <span class="c1"># an empty frozenset is not used as a key in any other node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetnodes</span> <span class="o">=</span> <span class="n">targetnodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clades</span> <span class="o">=</span> <span class="p">{</span><span class="nb">frozenset</span><span class="p">():</span> <span class="n">targetnodes</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
            <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="UANode.empty_copy"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.UANode.empty_copy">[docs]</a>    <span class="k">def</span> <span class="nf">empty_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;UANode&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a UANode object with the same clades and label, but no</span>
<span class="sd">        descendant edges.&quot;&quot;&quot;</span>
        <span class="n">newnode</span> <span class="o">=</span> <span class="n">UANode</span><span class="p">(</span><span class="n">EdgeSet</span><span class="p">())</span>
        <span class="n">newnode</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newnode</span></div>

<div class="viewcode-block" id="UANode.is_ua_node"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.UANode.is_ua_node">[docs]</a>    <span class="k">def</span> <span class="nf">is_ua_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether this is the source node in the DAG, from which all</span>
<span class="sd">        others are reachable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span></div></div>


<div class="viewcode-block" id="HistoryDag"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag">[docs]</a><span class="k">class</span> <span class="nc">HistoryDag</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;An object to represent a collection of internally labeled trees. A</span>
<span class="sd">    wrapper object to contain exposed HistoryDag methods and point to a</span>
<span class="sd">    HistoryDagNode root.</span>

<span class="sd">    Args:</span>
<span class="sd">        dagroot: The root node of the history DAG</span>
<span class="sd">        attr: An attribute to contain data which will be preserved by copying (default and empty dict)</span>


<span class="sd">    Subclassing HistoryDag:</span>
<span class="sd">    HistoryDag may be subclassed without overriding __init__, by defining a `_required_label_fields` class variable</span>
<span class="sd">    for any subclasses.</span>

<span class="sd">    The value of `_required_label_fields` should be a dictionary keyed by label fields that are expected by methods</span>
<span class="sd">    of the subclass. Each dictionary entry shall be of the form `required_field: [(from_fields, conversion_func), ...]`, where</span>
<span class="sd">    the dict value is a list of tuples, with each `conversion_func` a function mapping `HistoryDagNode`s to the value of</span>
<span class="sd">    that node label&#39;s `required_field` field, and `from_fields` a tuple containing all label fields expected by that function.</span>

<span class="sd">    Keyword arguments passed to :meth:`HistoryDag.from_history_dag` will be passed to conversion functions provided in the</span>
<span class="sd">    appropriate subclass&#39;s `_required_label_fields` attribute. Be sure to document each subclass, including available</span>
<span class="sd">    conversion functions and their keywords, in each subclass&#39;s docstring.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_required_label_fields</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

<div class="viewcode-block" id="HistoryDag.from_history_dag"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.from_history_dag">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_history_dag</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">dag</span><span class="p">:</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span> <span class="n">label_fields</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts HistoryDag instances between subclasses of HistoryDag. No</span>
<span class="sd">        copy is performed, so the passed `dag` will in general be modified.</span>

<span class="sd">        Args:</span>
<span class="sd">            dag: A HistoryDag (or subclass) instance</span>
<span class="sd">            label_fields: A list specifying the order of label fields in node labels on the resulting HistoryDag</span>
<span class="sd">            kwargs: Any additional arguments required for label conversions. For details, see the class docstring</span>
<span class="sd">                for the subclass into which the conversion is taking place.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The converted HistoryDag object, carrying the type from which this static method was called.</span>
<span class="sd">            After conversion to the new HistoryDag subclass ``to_cls``, the following will be true about node labels:</span>

<span class="sd">            * If passed ``label_fields`` is None, then existing label fields will be preserved, except that missing</span>
<span class="sd">              required label fields will be recovered if possible, and the existing label fields used to recover</span>
<span class="sd">              them will be omitted. Recovered label fields will appear before the existing label fields.</span>
<span class="sd">            * If passed ``label_fields`` is not None, then it must include all fields expected in node labels</span>
<span class="sd">              in the converted history DAG object, otherwise an exception will be raised.</span>
<span class="sd">            * Converted node label field order will match the order of passed ``label_fields``.</span>
<span class="sd">            * All label fields passed in ``label_fields`` will be included</span>
<span class="sd">              in converted node labels, if possible. Otherwise, an exception will be raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">label_fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">label_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">label_fields</span><span class="p">)</span>
        <span class="n">required_fields_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_required_label_fields</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">label_fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">required_fields_set</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">label_fields</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="c1"># This would be handled by __init__ anyway, but this prevents</span>
            <span class="c1"># any changes from being applied first and provides better</span>
            <span class="c1"># error message</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If passed, `label_fields` must contain all required label fields&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;for </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">required_fields_set</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">label_fields</span> <span class="o">==</span> <span class="n">dag</span><span class="o">.</span><span class="n">label_fields</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">label_fields</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">required_fields_set</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">label_fields</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="c1"># No label modification is needed</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">dagroot</span><span class="p">,</span> <span class="n">dag</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_existing_field</span><span class="p">(</span><span class="n">fieldname</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">get_field</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">HistoryDagNode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">get_field</span>

        <span class="k">def</span> <span class="nf">raise_unable_error</span><span class="p">(</span><span class="n">fieldname</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">label_fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">label_fields</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; Label field &#39;</span><span class="si">{</span><span class="n">fieldname</span><span class="si">}</span><span class="s2">&#39; is not present in existing label fields.&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unable to convert </span><span class="si">{</span><span class="n">dag</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> with label fields </span><span class="si">{</span><span class="n">dag</span><span class="o">.</span><span class="n">label_fields</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;, which requires label field &#39;</span><span class="si">{</span><span class="n">fieldname</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">required_fields_set</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="s2">&quot; Automatic conversion from label fields&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="s1">&#39; or &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">converttuple</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">converttuple</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_required_label_fields</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]])</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="s2">&quot; is supported.&quot;</span>
                <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

        <span class="n">precursor_fields</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">find_conversion_func</span><span class="p">(</span><span class="n">fieldname</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">label_fields</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">get_existing_field</span><span class="p">(</span><span class="n">fieldname</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">required_fields_set</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">from_fields</span><span class="p">,</span> <span class="n">conversion_func</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_required_label_fields</span><span class="p">[</span>
                    <span class="n">fieldname</span>
                <span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">from_fields</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">label_fields</span><span class="p">)):</span>
                        <span class="n">precursor_fields</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">from_fields</span><span class="p">)</span>
                        <span class="k">return</span> <span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">conversion_func</span><span class="p">)</span>
            <span class="n">raise_unable_error</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>

        <span class="n">convert_funcs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">label_fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># keep all existing fields, except those used to recover missing</span>
            <span class="c1"># required fields:</span>
            <span class="n">added_fields</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_required_label_fields</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">label_fields</span> <span class="ow">and</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">added_fields</span><span class="p">:</span>
                    <span class="n">convert_funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">find_conversion_func</span><span class="p">(</span><span class="n">field</span><span class="p">))</span>
                    <span class="n">added_fields</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">label_fields</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">added_fields</span> <span class="ow">and</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">precursor_fields</span><span class="p">:</span>
                    <span class="n">convert_funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">find_conversion_func</span><span class="p">(</span><span class="n">field</span><span class="p">))</span>
                    <span class="n">added_fields</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">label_fields</span><span class="p">:</span>
                <span class="n">convert_funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">find_conversion_func</span><span class="p">(</span><span class="n">field</span><span class="p">))</span>

        <span class="n">Label</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span>
            <span class="s2">&quot;Label&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="n">converttuple</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Any</span><span class="p">)</span> <span class="k">for</span> <span class="n">converttuple</span> <span class="ow">in</span> <span class="n">convert_funcs</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">relabel_func</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">labeldata</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">converttuple</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">node</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">converttuple</span> <span class="ow">in</span> <span class="n">convert_funcs</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="n">Label</span><span class="p">(</span><span class="o">*</span><span class="n">labeldata</span><span class="p">)</span>

        <span class="n">newdag</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">relabel_func</span><span class="p">,</span> <span class="n">relax_type</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">newdag</span><span class="o">.</span><span class="n">dagroot</span><span class="p">,</span> <span class="n">dag</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.__init__"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dagroot</span><span class="p">:</span> <span class="n">HistoryDagNode</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="p">{}):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dagroot</span><span class="p">,</span> <span class="n">UANode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="n">attr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span> <span class="o">=</span> <span class="n">dagroot</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_fields</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">())</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">_fields</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_fields</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_required_label_fields</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_fields</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;An instance of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> must have node labels containing a &#39;</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">&#39; field.&quot;</span>
                <span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Eventually this can be done by comparing bytestrings, but we need</span>
        <span class="c1"># some sorting to be done first, to ensure two dags that represent</span>
        <span class="c1"># identical trees return True. TODO</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the history (tree-shaped sub-history DAG) in the current</span>
<span class="sd">        history dag corresponding to the given index.&quot;&quot;&quot;</span>
        <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">length</span> <span class="o">+</span> <span class="n">key</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;History DAG indices must be integers, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">key</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">_get_subhistory_by_subid</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

<div class="viewcode-block" id="HistoryDag.get_label_type"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.get_label_type">[docs]</a>    <span class="k">def</span> <span class="nf">get_label_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">type</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the type for labels on this dag&#39;s nodes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">())</span><span class="o">.</span><span class="n">label</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">trim_within_range</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">min_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">start_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
            <span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="n">HistoryDagNode</span><span class="p">],</span> <span class="n">Weight</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">wrapped_hamming_distance</span><span class="p">,</span>
        <span class="n">min_possible_weight</span><span class="o">=-</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span>
        <span class="n">max_possible_weight</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">max_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trim_below_weight</span><span class="p">(</span>
                <span class="n">max_weight</span><span class="p">,</span> <span class="n">start_func</span><span class="p">,</span> <span class="n">edge_weight_func</span><span class="p">,</span> <span class="n">min_possible_weight</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">min_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trim_below_weight</span><span class="p">(</span>
                <span class="o">-</span><span class="n">min_weight</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="o">-</span><span class="n">start_func</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>
                <span class="k">lambda</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">:</span> <span class="o">-</span><span class="n">edge_weight_func</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">),</span>
                <span class="o">-</span><span class="n">max_possible_weight</span><span class="p">,</span>
            <span class="p">)</span>

<div class="viewcode-block" id="HistoryDag.trim_below_weight"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.trim_below_weight">[docs]</a>    <span class="k">def</span> <span class="nf">trim_below_weight</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_weight</span><span class="p">,</span>
        <span class="n">start_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
            <span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="n">HistoryDagNode</span><span class="p">],</span> <span class="n">Weight</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">wrapped_hamming_distance</span><span class="p">,</span>
        <span class="n">min_possible_weight</span><span class="o">=-</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Trim the dag to contain at least all the histories within the</span>
<span class="sd">        specified weight range.</span>

<span class="sd">        Supports totally ordered weights, accumulated by addition. A</span>
<span class="sd">        weight type must implement all ordering operators properly, as</span>
<span class="sd">        well as + and -, and addition and subtraction must respect the</span>
<span class="sd">        ordering. That is, if a &lt; b, then a + c &lt; b + c for any c</span>
<span class="sd">        (including negative c)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">trim_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>  <span class="c1"># base case - the node is a leaf</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node_min_weight</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_dp_data</span>  <span class="c1"># minimum weight of subtree under node</span>
                <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">weightlist</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
                        <span class="n">edgeweight</span> <span class="o">=</span> <span class="n">edge_weight_func</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
                        <span class="n">weightlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">_dp_data</span> <span class="o">+</span> <span class="n">edgeweight</span><span class="p">,</span> <span class="n">edgeweight</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
                        <span class="p">)</span>

                    <span class="c1"># By assuming a minimum weight edge is chosen for all other</span>
                    <span class="c1"># clades, we compute the maximum weight of a subtree below this</span>
                    <span class="c1"># clade</span>
                    <span class="n">min_weight_under_clade</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                        <span class="n">minweight</span> <span class="k">for</span> <span class="n">minweight</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">weightlist</span>
                    <span class="p">)</span>
                    <span class="c1"># The sum of minimum scores beneath all other clades is</span>
                    <span class="c1"># quantity in parentheses:</span>
                    <span class="n">max_weight_allowed_clade</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">maxweight</span> <span class="o">-</span> <span class="p">(</span>
                        <span class="n">node_min_weight</span> <span class="o">-</span> <span class="n">min_weight_under_clade</span>
                    <span class="p">)</span>

                    <span class="n">to_keep</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="p">(</span>
                        <span class="n">minweight</span><span class="p">,</span>
                        <span class="n">edgeweight</span><span class="p">,</span>
                        <span class="n">target</span><span class="p">,</span>
                    <span class="p">)</span> <span class="ow">in</span> <span class="p">(</span>
                        <span class="n">weightlist</span>
                    <span class="p">):</span>  <span class="c1"># this is looping through all the edges under clade</span>
                        <span class="k">if</span> <span class="n">minweight</span> <span class="o">&lt;=</span> <span class="n">max_weight_allowed_clade</span><span class="p">:</span>
                            <span class="n">targetmax</span> <span class="o">=</span> <span class="n">max_weight_allowed_clade</span> <span class="o">-</span> <span class="n">edgeweight</span>
                            <span class="n">target</span><span class="o">.</span><span class="n">maxweight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">maxweight</span><span class="p">,</span> <span class="n">targetmax</span><span class="p">)</span>
                            <span class="n">to_keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="n">eset</span><span class="o">.</span><span class="n">set_targets</span><span class="p">(</span><span class="n">to_keep</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">optimal_weight_annotate</span><span class="p">(</span>
            <span class="n">start_func</span><span class="o">=</span><span class="n">start_func</span><span class="p">,</span> <span class="n">edge_weight_func</span><span class="o">=</span><span class="n">edge_weight_func</span>
        <span class="p">)</span>

        <span class="n">nl</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())))</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nl</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">maxweight</span> <span class="o">=</span> <span class="n">min_possible_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">maxweight</span> <span class="o">=</span> <span class="n">max_weight</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nl</span><span class="p">:</span>
            <span class="n">trim_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
        <span class="n">newdag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">newdag</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newdag</span>

    <span class="k">def</span> <span class="fm">__ior__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">|</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converts HistoryDag to a bytestring-serializable dictionary.</span>

<span class="sd">        Since a HistoryDag is a recursive data structure, and contains label</span>
<span class="sd">        types defined in function scope, modifications must be made for pickling.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary containing:</span>
<span class="sd">            * label_fields: The names of label fields.</span>
<span class="sd">            * label_list: labels used in nodes, without duplicates. Indices are</span>
<span class="sd">                mapped to nodes in node_list</span>
<span class="sd">            * node_list: node tuples containing</span>
<span class="sd">                (node label index in label_list, tuple of frozensets of leaf label indices, node.attr).</span>
<span class="sd">            * edge_list: a tuple for each edge:</span>
<span class="sd">                    (origin node index, target node index, edge weight, edge probability)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">label_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">_fields</span>
        <span class="n">label_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">node_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edge_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">label_indices</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Label</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">node_indices</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())}</span>

        <span class="k">def</span> <span class="nf">cladesets</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="nb">frozenset</span><span class="p">({</span><span class="n">label_indices</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">clade</span><span class="p">})</span>
                <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">label_indices</span><span class="p">:</span>
                <span class="n">label_indices</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">label_list</span><span class="p">)</span>
                <span class="n">label_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">label_list</span><span class="p">[</span><span class="n">label_indices</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">]]</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span>
                    <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="n">node_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">label_indices</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">],</span> <span class="n">cladesets</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">node</span><span class="o">.</span><span class="n">attr</span><span class="p">))</span>
            <span class="n">node_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">):</span>
                    <span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">node_idx</span><span class="p">,</span>
                            <span class="n">node_indices</span><span class="p">[</span><span class="n">target</span><span class="p">],</span>
                            <span class="n">eset</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                            <span class="n">eset</span><span class="o">.</span><span class="n">probs</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
        <span class="n">serial_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;label_fields&quot;</span><span class="p">:</span> <span class="n">label_fields</span><span class="p">,</span>
            <span class="s2">&quot;label_list&quot;</span><span class="p">:</span> <span class="n">label_list</span><span class="p">,</span>
            <span class="s2">&quot;node_list&quot;</span><span class="p">:</span> <span class="n">node_list</span><span class="p">,</span>
            <span class="s2">&quot;edge_list&quot;</span><span class="p">:</span> <span class="n">edge_list</span><span class="p">,</span>
            <span class="s2">&quot;attr&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">serial_dict</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">serial_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rebuilds a HistoryDagNode using a serial_dict output by</span>
<span class="sd">        __getstate__&quot;&quot;&quot;</span>
        <span class="n">label_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]</span> <span class="o">=</span> <span class="n">serial_dict</span><span class="p">[</span><span class="s2">&quot;label_list&quot;</span><span class="p">]</span>
        <span class="n">node_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]</span> <span class="o">=</span> <span class="n">serial_dict</span><span class="p">[</span><span class="s2">&quot;node_list&quot;</span><span class="p">]</span>
        <span class="n">edge_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="n">serial_dict</span><span class="p">[</span><span class="s2">&quot;edge_list&quot;</span><span class="p">]</span>
        <span class="n">label_fields</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">serial_dict</span><span class="p">[</span><span class="s2">&quot;label_fields&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_fields</span> <span class="o">=</span> <span class="n">label_fields</span>
        <span class="n">Label</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span><span class="s2">&quot;Label&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="n">label</span><span class="p">,</span> <span class="nb">any</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">label_fields</span><span class="p">])</span>  <span class="c1"># type: ignore</span>

        <span class="k">def</span> <span class="nf">unpack_labels</span><span class="p">(</span><span class="n">labelset</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">Label</span><span class="p">(</span><span class="o">*</span><span class="n">label_list</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">labelset</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="n">node_postorder</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">UANode</span><span class="p">(</span><span class="n">EdgeSet</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">label_list</span><span class="p">[</span><span class="n">labelidx</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">HistoryDagNode</span><span class="p">(</span>
                <span class="p">(</span><span class="n">Label</span><span class="p">(</span><span class="o">*</span><span class="n">label_list</span><span class="p">[</span><span class="n">labelidx</span><span class="p">])),</span>
                <span class="p">{</span><span class="n">unpack_labels</span><span class="p">(</span><span class="n">clade</span><span class="p">):</span> <span class="n">EdgeSet</span><span class="p">()</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">clades</span><span class="p">},</span>
                <span class="n">attr</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">labelidx</span><span class="p">,</span> <span class="n">clades</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">node_list</span>
        <span class="p">]</span>
        <span class="c1"># Last node in list is root</span>
        <span class="k">for</span> <span class="n">origin_idx</span><span class="p">,</span> <span class="n">target_idx</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="n">edge_list</span><span class="p">:</span>
            <span class="n">node_postorder</span><span class="p">[</span><span class="n">origin_idx</span><span class="p">]</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span>
                <span class="n">node_postorder</span><span class="p">[</span><span class="n">target_idx</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="n">prob</span><span class="p">,</span> <span class="n">prob_norm</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span> <span class="o">=</span> <span class="n">node_postorder</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="n">serial_dict</span><span class="p">[</span><span class="s2">&quot;attr&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_check_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Check that this HistoryDag complies with all the conditions of the</span>
<span class="sd">        definition.&quot;&quot;&quot;</span>
        <span class="c1"># Traversal checks if a node has been visited by its id, which makes it</span>
        <span class="c1"># suitable for these checks.</span>
        <span class="n">po</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())</span>
        <span class="n">node_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">po</span><span class="p">)</span>

        <span class="c1"># ***Node instances are unique (And therefore leaves are uniquely labeled also):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">po</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_set</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Node instances are not unique&quot;</span><span class="p">)</span>

        <span class="c1"># ***All nodes are reachable from the UA node: this is proven by the</span>
        <span class="c1"># structure of the postorder traversal; if a node is visited, then it&#39;s</span>
        <span class="c1"># reachable by following directed edges downward. (parent sets aren&#39;t</span>
        <span class="c1"># used in the traversal)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">po</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
                        <span class="c1"># ***Parent clade equals child clade union for all edges:</span>
                        <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span> <span class="o">!=</span> <span class="n">clade</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s2">&quot;Parent clade does not equal child clade union: &quot;</span>
                            <span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">po</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># ***At least one edge descends from each node-clade pair:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found a clade with no child edges&quot;</span><span class="p">)</span>
                <span class="c1"># ...and there are no duplicate children:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Duplicate child edges found descending from the same clade&quot;</span>
                    <span class="p">)</span>
                <span class="c1"># ...and the eset._targetset set is correct</span>
                <span class="k">if</span> <span class="n">eset</span><span class="o">.</span><span class="n">_targetset</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;eset._targetset doesn&#39;t match eset.targets&quot;</span><span class="p">)</span>

        <span class="n">parents</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">po</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">po</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                <span class="n">parents</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">po</span><span class="p">:</span>
            <span class="c1"># ... and parent sets are correct:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="n">node</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found an incorrect parent set&quot;</span><span class="p">)</span>
            <span class="c1"># ... and there are no duplicate parents:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="n">node</span><span class="p">])):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found duplicate parents&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">())</span>

<div class="viewcode-block" id="HistoryDag.get_histories"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.get_histories">[docs]</a>    <span class="k">def</span> <span class="nf">get_histories</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return a generator containing all histories in the history DAG.</span>

<span class="sd">        Note that each history is a tree-shaped history DAG, containing a UA node,</span>
<span class="sd">        which exists as a subgraph of the history DAG.</span>

<span class="sd">        The order of these histories does not necessarily match the order of</span>
<span class="sd">        indexing. That is, ``dag.get_histories()`` and ``history for history in</span>
<span class="sd">        dag`` will result in different orderings. ``get_histories`` should</span>
<span class="sd">        be slightly faster, but possibly more memory intensive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">history</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">_get_subhistories</span><span class="p">():</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">history</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.get_trees"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.get_trees">[docs]</a>    <span class="k">def</span> <span class="nf">get_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Deprecated name for :meth:`get_histories`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_histories</span><span class="p">()</span></div>

<div class="viewcode-block" id="HistoryDag.get_leaves"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.get_leaves">[docs]</a>    <span class="k">def</span> <span class="nf">get_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return a generator containing all leaf nodes in the history DAG.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">())</span></div>

<div class="viewcode-block" id="HistoryDag.num_nodes"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.num_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">num_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the number of nodes in the DAG, not counting the UA node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div>

<div class="viewcode-block" id="HistoryDag.num_leaves"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.num_leaves">[docs]</a>    <span class="k">def</span> <span class="nf">num_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the number of leaf nodes in the DAG.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">())</span></div>

<div class="viewcode-block" id="HistoryDag.sample"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_selector</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Samples a history from the history DAG. (A history is a sub-history</span>
<span class="sd">        DAG containing the root and all leaf nodes) For reproducibility, set</span>
<span class="sd">        ``random.seed`` before sampling.</span>

<span class="sd">        When there is an option, edges pointing to nodes on which `selection_func` is True</span>
<span class="sd">        will always be chosen.</span>

<span class="sd">        Returns a new HistoryDag object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">_sample</span><span class="p">(</span><span class="n">edge_selector</span><span class="o">=</span><span class="n">edge_selector</span><span class="p">))</span></div>

<div class="viewcode-block" id="HistoryDag.nodes_above_node"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.nodes_above_node">[docs]</a>    <span class="k">def</span> <span class="nf">nodes_above_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return a set of nodes from which the passed node is reachable along</span>
<span class="sd">        directed edges.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
        <span class="n">mask_true</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">nodequeue</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">}</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodequeue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">curr_node</span> <span class="o">=</span> <span class="n">nodequeue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">curr_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mask_true</span><span class="p">:</span>
                <span class="n">nodequeue</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">curr_node</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span>
                <span class="n">mask_true</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mask_true</span></div>

<div class="viewcode-block" id="HistoryDag.sample_with_node"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.sample_with_node">[docs]</a>    <span class="k">def</span> <span class="nf">sample_with_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Samples a history which contains ``node`` from the history DAG.</span>

<span class="sd">        Sampling is likely unbiased from the distribution of trees in</span>
<span class="sd">        the DAG, conditioned on each sampled tree containing the passed</span>
<span class="sd">        node. However, if unbiased sampling from the conditional</span>
<span class="sd">        distribution is important, this should be tested.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mask_true</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_above_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">edge_selector</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">edge</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">mask_true</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">edge_selector</span><span class="o">=</span><span class="n">edge_selector</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.sample_with_edge"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.sample_with_edge">[docs]</a>    <span class="k">def</span> <span class="nf">sample_with_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Samples a history which contains ``edge`` (a tuple of</span>
<span class="sd">        HistoryDagNodes) from the history DAG.</span>

<span class="sd">        Sampling is likely unbiased from the distribution of trees in</span>
<span class="sd">        the DAG, conditioned on each sampled tree containing the passed</span>
<span class="sd">        edge. However, if unbiased sampling from the conditional</span>
<span class="sd">        distribution is important, this should be tested.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask_true</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_above_node</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">edge_selector</span><span class="p">(</span><span class="n">inedge</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">inedge</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">mask_true</span> <span class="ow">or</span> <span class="n">inedge</span> <span class="o">==</span> <span class="n">edge</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">edge_selector</span><span class="o">=</span><span class="n">edge_selector</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.iter_covering_histories"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.iter_covering_histories">[docs]</a>    <span class="k">def</span> <span class="nf">iter_covering_histories</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cover_edges</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Samples a sequence of histories which together contain all nodes in</span>
<span class="sd">        the history DAG.</span>

<span class="sd">        Histories are sampled using :meth:`sample_with_node`, starting</span>
<span class="sd">        with the nodes which are contained in the fewest of the DAG&#39;s</span>
<span class="sd">        histories. The sequence of trees is therefore non-deterministic</span>
<span class="sd">        unless ``random.seed`` is set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_nodes</span><span class="p">()</span>
        <span class="n">node_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">node_counts</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">node_counts</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cover_edges</span><span class="p">:</span>
            <span class="n">part_list</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">node_list</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">()</span>
            <span class="p">]</span>
            <span class="n">sample_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_with_edge</span>

            <span class="k">def</span> <span class="nf">update_visited</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="nb">set</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">preorder</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">part_list</span> <span class="o">=</span> <span class="n">node_list</span>
            <span class="n">sample_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_with_node</span>

            <span class="k">def</span> <span class="nf">update_visited</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">preorder</span><span class="p">()))</span>

        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">part_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">part</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">tree</span> <span class="o">=</span> <span class="n">sample_func</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
                <span class="n">olen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span>
                <span class="n">update_visited</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="c1"># At least part must have been added.</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">olen</span>
                <span class="k">yield</span> <span class="n">tree</span></div>

<div class="viewcode-block" id="HistoryDag.unlabel"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.unlabel">[docs]</a>    <span class="k">def</span> <span class="nf">unlabel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sets all internal node labels to be identical, and merges nodes so</span>
<span class="sd">        that all histories in the DAG have unique topologies.&quot;&quot;&quot;</span>

        <span class="n">newdag</span> <span class="o">=</span> <span class="n">HistoryDag</span><span class="o">.</span><span class="n">from_history_dag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">model_label</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">label</span>
        <span class="c1"># initialize empty/default value for each item in model_label</span>
        <span class="n">field_values</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">model_label</span><span class="p">)</span>
        <span class="n">internal_label</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">model_label</span><span class="p">)(</span><span class="o">*</span><span class="n">field_values</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">newdag</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">internal_label</span>

        <span class="c1"># Use merging method to eliminate duplicate nodes, by starting with</span>
        <span class="c1"># a subdag with no duplicate nodes.</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">newdag</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">newdag</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="HistoryDag.relabel"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.relabel">[docs]</a>    <span class="k">def</span> <span class="nf">relabel</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">relabel_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="n">Label</span><span class="p">],</span> <span class="n">relax_type</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a new HistoryDag with labels modified according to a provided</span>
<span class="sd">        function.</span>

<span class="sd">        Args:</span>
<span class="sd">            relabel_func: A function which takes a node and returns the new label</span>
<span class="sd">                appropriate for that node. The relabel_func should return a consistent</span>
<span class="sd">                NamedTuple type with name Label. That is, all returned labels</span>
<span class="sd">                should have matching `_fields` attribute.</span>
<span class="sd">                No two leaf nodes may be mapped to the same new label.</span>
<span class="sd">            relax_type: Whether to require the returned HistoryDag to be of the same subclass as self.</span>
<span class="sd">                If True, the returned HistoryDag will be of the abstract type `HistoryDag`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">leaf_label_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">leaf</span><span class="o">.</span><span class="n">label</span><span class="p">:</span> <span class="n">relabel_func</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaf_label_dict</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">leaf_label_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;relabeling function maps multiple leaf nodes to the same new label&quot;</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">relabel_clade</span><span class="p">(</span><span class="n">old_clade</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">leaf_label_dict</span><span class="p">[</span><span class="n">old_label</span><span class="p">]</span> <span class="k">for</span> <span class="n">old_label</span> <span class="ow">in</span> <span class="n">old_clade</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">relabel_node</span><span class="p">(</span><span class="n">old_node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">old_node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">UANode</span><span class="p">(</span>
                    <span class="n">EdgeSet</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">relabel_node</span><span class="p">(</span><span class="n">old_child</span><span class="p">)</span> <span class="k">for</span> <span class="n">old_child</span> <span class="ow">in</span> <span class="n">old_node</span><span class="o">.</span><span class="n">children</span><span class="p">()]</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">clades</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">relabel_clade</span><span class="p">(</span><span class="n">old_clade</span><span class="p">):</span> <span class="n">EdgeSet</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">relabel_node</span><span class="p">(</span><span class="n">old_child</span><span class="p">)</span> <span class="k">for</span> <span class="n">old_child</span> <span class="ow">in</span> <span class="n">old_eset</span><span class="o">.</span><span class="n">targets</span><span class="p">],</span>
                        <span class="n">weights</span><span class="o">=</span><span class="n">old_eset</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span>
                        <span class="n">probs</span><span class="o">=</span><span class="n">old_eset</span><span class="o">.</span><span class="n">probs</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">old_clade</span><span class="p">,</span> <span class="n">old_eset</span> <span class="ow">in</span> <span class="n">old_node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="n">HistoryDagNode</span><span class="p">(</span><span class="n">relabel_func</span><span class="p">(</span><span class="n">old_node</span><span class="p">),</span> <span class="n">clades</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">relax_type</span><span class="p">:</span>
            <span class="n">newdag</span> <span class="o">=</span> <span class="n">HistoryDag</span><span class="p">(</span><span class="n">relabel_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newdag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">relabel_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="p">))</span>
        <span class="c1"># do any necessary collapsing</span>
        <span class="n">newdag</span> <span class="o">=</span> <span class="n">newdag</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span> <span class="o">|</span> <span class="n">newdag</span>
        <span class="k">return</span> <span class="n">newdag</span></div>

<div class="viewcode-block" id="HistoryDag.is_history"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.is_history">[docs]</a>    <span class="k">def</span> <span class="nf">is_history</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether history DAG is a history.</span>

<span class="sd">        That is, each node-clade pair has exactly one descendant edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="HistoryDag.is_clade_tree"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.is_clade_tree">[docs]</a>    <span class="k">def</span> <span class="nf">is_clade_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Deprecated name for :meth:`is_history`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_history</span><span class="p">()</span></div>

<div class="viewcode-block" id="HistoryDag.copy"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Uses bytestring serialization, and is guaranteed to copy:</span>

<span class="sd">        * node labels</span>
<span class="sd">        * node attr attributes</span>
<span class="sd">        * edge weights</span>
<span class="sd">        * edge probabilities</span>

<span class="sd">        However, other object attributes will not be copied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="HistoryDag.merge"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trees</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="s2">&quot;HistoryDag&quot;</span><span class="p">]]):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Graph union this history DAG with all those in a list of history</span>
<span class="sd">        DAGs.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">HistoryDag</span><span class="p">):</span>
            <span class="n">trees</span> <span class="o">=</span> <span class="p">[</span><span class="n">trees</span><span class="p">]</span>

        <span class="n">selforder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()</span>
        <span class="n">nodedict</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">selforder</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_fields</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">label_fields</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The given HistoryDag must contain identical label fields.</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">label_fields</span><span class="si">}</span><span class="se">\n</span><span class="s2">vs</span><span class="se">\n</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">label_fields</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">otherorder</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">postorder</span><span class="p">()</span>
            <span class="c1"># hash and __eq__ are implemented for nodes, but we need to retrieve</span>
            <span class="c1"># the actual instance that&#39;s the same as a proposed node-to-add:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">otherorder</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodedict</span><span class="p">:</span>
                    <span class="n">pnode</span> <span class="o">=</span> <span class="n">nodedict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pnode</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">()</span>
                    <span class="n">nodedict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pnode</span>

                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">edgeset</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">edgeset</span><span class="p">:</span>
                        <span class="n">pnode</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">nodedict</span><span class="p">[</span><span class="n">child</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.add_all_allowed_edges"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.add_all_allowed_edges">[docs]</a>    <span class="k">def</span> <span class="nf">add_all_allowed_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Provided as a deprecated synonym for :meth:`make_complete`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_complete</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.make_complete"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.make_complete">[docs]</a>    <span class="k">def</span> <span class="nf">make_complete</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_from_root</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">adjacent_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">preserve_parent_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Add all allowed edges to the DAG.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_from_root: If False, no edges will be added that start at the DAG root.</span>
<span class="sd">                Useful when attempting to constrain root label.</span>
<span class="sd">            adjacent_labels: If False, no edges will be added between nodes with the same</span>
<span class="sd">                labels. Useful when attempting to maintain the history DAG in a &#39;collapsed&#39;</span>
<span class="sd">                state.</span>
<span class="sd">            preserve_parent_labels: If True, ensures that for any edge added between a</span>
<span class="sd">                parent and child node, the parent node label was already among the original</span>
<span class="sd">                parent labels of the child node. This ensures that parsimony score is preserved.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The number of edges added to the history DAG</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_added</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">preserve_parent_labels</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
            <span class="n">uplabels</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">node</span><span class="p">:</span> <span class="p">{</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">}</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()</span>
            <span class="p">}</span>

        <span class="n">clade_dict</span> <span class="o">=</span> <span class="n">_clade_union_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">clade_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">new_from_root</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">clade_dict</span><span class="p">[</span><span class="n">clade</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">adjacent_labels</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">elif</span> <span class="p">(</span>
                            <span class="n">preserve_parent_labels</span> <span class="ow">is</span> <span class="kc">True</span>
                            <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">uplabels</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
                        <span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">n_added</span> <span class="o">+=</span> <span class="n">node</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n_added</span></div>

<div class="viewcode-block" id="HistoryDag.to_newick"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.to_newick">[docs]</a>    <span class="nd">@utils</span><span class="o">.</span><span class="n">_history_method</span>
    <span class="k">def</span> <span class="nf">to_newick</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;unnamed&quot;</span><span class="p">,</span>
        <span class="n">features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">feature_funcs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converts a history to extended newick format. Supports arbitrary</span>
<span class="sd">        node names and a sequence feature. For use on a history DAG which is a</span>
<span class="sd">        history.</span>

<span class="sd">        For extracting newick representations of trees in a general history DAG, see</span>
<span class="sd">        :meth:`HistoryDag.to_newicks`.</span>

<span class="sd">        Args:</span>
<span class="sd">            name_func: A map from nodes to newick node names</span>
<span class="sd">            features: A list of label field names to be included in extended newick data.</span>
<span class="sd">                If `None`, all label fields will be included. To include none of them,</span>
<span class="sd">                pass an empty list.</span>
<span class="sd">            feature_funcs: A dictionary keyed by extended newick field names, containing</span>
<span class="sd">                functions specifying how to populate that field for each node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A newick string. If `features` is an empty list, and feature_funcs is empty,</span>
<span class="sd">                then this will be a standard newick string. Otherwise, it will have ete3&#39;s</span>
<span class="sd">                extended newick format.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">newick</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">_newick_label</span><span class="p">(</span>
                    <span class="n">name_func</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span> <span class="n">feature_funcs</span><span class="o">=</span><span class="n">feature_funcs</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">childnewicks</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">newick</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span> <span class="k">for</span> <span class="n">node2</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">()])</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="s2">&quot;(&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">childnewicks</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                    <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">_newick_label</span><span class="p">(</span>
                        <span class="n">name_func</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span> <span class="n">feature_funcs</span><span class="o">=</span><span class="n">feature_funcs</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">newick</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">()))</span> <span class="o">+</span> <span class="s2">&quot;;&quot;</span></div>

<div class="viewcode-block" id="HistoryDag.to_ete"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.to_ete">[docs]</a>    <span class="nd">@utils</span><span class="o">.</span><span class="n">_history_method</span>
    <span class="k">def</span> <span class="nf">to_ete</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;unnamed&quot;</span><span class="p">,</span>
        <span class="n">features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">feature_funcs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert a history DAG which is a history to an ete tree.</span>

<span class="sd">        Args:</span>
<span class="sd">            name_func: A map from nodes to newick node names</span>
<span class="sd">            features: A list of label field names to be included in extended newick data.</span>
<span class="sd">                If `None`, all label fields will be included. To include none of them,</span>
<span class="sd">                pass an empty list.</span>
<span class="sd">            feature_funcs: A dictionary keyed by extended newick field names, containing</span>
<span class="sd">                functions specifying how to populate that field for each node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An ete3 Tree with the same topology as self, and node names and attributes</span>
<span class="sd">            as specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First build a dictionary of ete3 nodes keyed by HDagNodes.</span>
        <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labelfeatures</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labelfeatures</span> <span class="o">=</span> <span class="n">features</span>

        <span class="k">def</span> <span class="nf">etenode</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">HistoryDagNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">:</span>
            <span class="n">newnode</span> <span class="o">=</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">()</span>
            <span class="n">newnode</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name_func</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">labelfeatures</span><span class="p">:</span>
                <span class="n">newnode</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">feature</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">feature</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">feature_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">newnode</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">newnode</span>

        <span class="n">nodedict</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">etenode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">True</span><span class="p">)}</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodedict</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                <span class="n">nodedict</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">child</span><span class="o">=</span><span class="n">nodedict</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>

        <span class="c1"># Since self is cladetree, dagroot can have only one child</span>
        <span class="k">return</span> <span class="n">nodedict</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span></div>

<div class="viewcode-block" id="HistoryDag.to_graphviz"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.to_graphviz">[docs]</a>    <span class="k">def</span> <span class="nf">to_graphviz</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labelfunc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">namedict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Label</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">show_child_clades</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_partitions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gv</span><span class="o">.</span><span class="n">Digraph</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converts history DAG to graphviz (dot format) Digraph object.</span>

<span class="sd">        Args:</span>
<span class="sd">            labelfunc: A function to label nodes. If None, nodes will be labeled by</span>
<span class="sd">                their DAG node labels, or their label hash if label data is too large.</span>
<span class="sd">            namedict: A dictionary from node labels to label strings. Labelfunc will be</span>
<span class="sd">                used instead, if both are provided.</span>
<span class="sd">            show_child_clades: Whether to include child clades in output.</span>
<span class="sd">            show_partitions: Deprecated alias for show_child_clades.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">show_partitions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">show_child_clades</span> <span class="o">=</span> <span class="n">show_partitions</span>

        <span class="k">def</span> <span class="nf">labeller</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">namedict</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">namedict</span><span class="p">[</span><span class="n">label</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">label</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mi">11</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">taxa</span><span class="p">(</span><span class="n">clade</span><span class="p">):</span>
            <span class="n">ls</span> <span class="o">=</span> <span class="p">[</span><span class="n">labeller</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span> <span class="k">for</span> <span class="n">taxon</span> <span class="ow">in</span> <span class="n">clade</span><span class="p">]</span>
            <span class="n">ls</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">return</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">labelfunc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labelfunc</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">ignore_uanode</span><span class="p">(</span><span class="s2">&quot;UA_node&quot;</span><span class="p">)(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">labeller</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>

        <span class="n">G</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">Digraph</span><span class="p">(</span><span class="s2">&quot;labeled partition DAG&quot;</span><span class="p">,</span> <span class="n">node_attr</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="s2">&quot;record&quot;</span><span class="p">})</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span> <span class="ow">or</span> <span class="n">show_child_clades</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)),</span> <span class="sa">f</span><span class="s2">&quot;&lt;label&gt; </span><span class="si">{</span><span class="n">labelfunc</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">splits</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="n">taxa</span><span class="p">(</span><span class="n">clade</span><span class="p">)</span><span class="si">}</span><span class="s2">&gt; </span><span class="si">{</span><span class="n">taxa</span><span class="p">(</span><span class="n">clade</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">{{</span><span class="s2"> &lt;label&gt; </span><span class="si">{</span><span class="n">labelfunc</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2"> |</span><span class="se">{{</span><span class="si">{</span><span class="n">splits</span><span class="si">}</span><span class="se">}}</span><span class="s2"> </span><span class="se">}}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="k">if</span> <span class="n">prob</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
                        <span class="n">label</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;p:</span><span class="si">{</span><span class="n">prob</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="n">weight</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">label</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;w:</span><span class="si">{</span><span class="n">weight</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">taxa</span><span class="p">(</span><span class="n">clade</span><span class="p">)</span> <span class="k">if</span> <span class="n">show_child_clades</span> <span class="k">else</span> <span class="s1">&#39;label&#39;</span><span class="si">}</span><span class="s2">:s&quot;</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s2">:n&quot;</span><span class="p">,</span>
                        <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="HistoryDag.internal_avg_parents"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.internal_avg_parents">[docs]</a>    <span class="k">def</span> <span class="nf">internal_avg_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the average number of parents among internal nodes.</span>

<span class="sd">        A simple measure of similarity between the trees that the DAG</span>
<span class="sd">        expresses. However, keep in mind that two trees with the same</span>
<span class="sd">        topology but different labels would be considered entirely</span>
<span class="sd">        unalike by this measure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nonleaf_parents</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">())</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cumsum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="nb">sum</span> <span class="ow">in</span> <span class="n">nonleaf_parents</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">cumsum</span> <span class="o">+=</span> <span class="nb">sum</span>
        <span class="c1"># Exclude root:</span>
        <span class="k">return</span> <span class="n">cumsum</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.make_uniform"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.make_uniform">[docs]</a>    <span class="k">def</span> <span class="nf">make_uniform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjust edge probabilities so that the DAG expresses a uniform</span>
<span class="sd">        distribution on expressed trees.</span>

<span class="sd">        The probability assigned to each edge below a clade is</span>
<span class="sd">        proportional to the number of subtrees possible below that edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">):</span>
                    <span class="n">eset</span><span class="o">.</span><span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">_dp_data</span></div>

<div class="viewcode-block" id="HistoryDag.explode_nodes"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.explode_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">explode_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">expand_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Label</span><span class="p">]]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sequence_resolutions</span><span class="p">,</span>
        <span class="n">expand_node_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Label</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">expandable_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Explode nodes according to a provided function. Adds copies of each</span>
<span class="sd">        node to the DAG with exploded labels, but with the same parents and</span>
<span class="sd">        children as the original node.</span>

<span class="sd">        Args:</span>
<span class="sd">            expand_func: (Deprecated) A function that takes a node label, and returns an iterable</span>
<span class="sd">                containing &#39;exploded&#39; or &#39;disambiguated&#39; labels corresponding to the original.</span>
<span class="sd">                The wrapper :meth:`utils.explode_label` is provided to make such a function</span>
<span class="sd">                easy to write.</span>
<span class="sd">            expand_node_func: A function that takes a node and returns an iterable</span>
<span class="sd">                containing &#39;exploded&#39; or &#39;disambiguated&#39; labels corresponding to the</span>
<span class="sd">                node. If provided, expand_func will be ignored.</span>
<span class="sd">            expandable_func: A function that takes a node label, and returns whether the</span>
<span class="sd">                iterable returned by calling expand_func on that label would contain more</span>
<span class="sd">                than one item.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The number of new nodes added to the history DAG.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">expand_node_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">expand_node_func</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">expand_func</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">expandable_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">is_ambiguous</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="c1"># Check if expand_func(label) has at least two items, without</span>
                <span class="c1"># exhausting the (arbitrarily expensive) generator</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">expand_node_func</span><span class="p">(</span><span class="n">node</span><span class="p">))))</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">is_ambiguous</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">expandable_func</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
        <span class="n">nodedict</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()}</span>
        <span class="n">nodeorder</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())</span>
        <span class="n">new_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodeorder</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span> <span class="ow">and</span> <span class="n">is_ambiguous</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">resolution</span> <span class="ow">in</span> <span class="n">expand_node_func</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                    <span class="n">newnodetemp</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">()</span>
                    <span class="n">newnodetemp</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">resolution</span>
                    <span class="k">if</span> <span class="n">newnodetemp</span> <span class="ow">in</span> <span class="n">nodedict</span><span class="p">:</span>
                        <span class="n">newnode</span> <span class="o">=</span> <span class="n">nodedict</span><span class="p">[</span><span class="n">newnodetemp</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">newnode</span> <span class="o">=</span> <span class="n">newnodetemp</span>
                        <span class="n">nodedict</span><span class="p">[</span><span class="n">newnode</span><span class="p">]</span> <span class="o">=</span> <span class="n">newnode</span>
                        <span class="n">new_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
                    <span class="c1"># Add all edges into and out of node to newnode</span>
                    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                        <span class="n">newnode</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">):</span>
                        <span class="n">parent</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
                <span class="c1"># Delete old node</span>
                <span class="n">node</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">nodedict</span><span class="o">=</span><span class="n">nodedict</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.leaf_path_uncertainty_dag"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.leaf_path_uncertainty_dag">[docs]</a>    <span class="k">def</span> <span class="nf">leaf_path_uncertainty_dag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terminal_node</span><span class="p">,</span> <span class="n">node_data_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a DAG of possible paths leading to `terminal_node`</span>

<span class="sd">        Args:</span>
<span class="sd">            terminal_node: The returned path DAG will contain all paths from the</span>
<span class="sd">                UA node ending at this node.</span>
<span class="sd">            node_data_func: A function accepting a HistoryDagNode and returning</span>
<span class="sd">                data for the corresponding node in the path dag. Return type must</span>
<span class="sd">                be a valid dictionary key.</span>
<span class="sd">        Returns:</span>
<span class="sd">            child_dictionary: A dictionary keyed by return values of</span>
<span class="sd">            `node_data_func`, with each value a dictionary keyed by child nodes,</span>
<span class="sd">            with edge supports as values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
        <span class="n">edge_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_edges</span><span class="p">()</span>
        <span class="n">child_dictionary</span> <span class="o">=</span> <span class="p">{</span><span class="n">node_data_func</span><span class="p">(</span><span class="n">terminal_node</span><span class="p">):</span> <span class="nb">dict</span><span class="p">()}</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_above</span><span class="p">(</span><span class="n">terminal_node</span><span class="p">,</span> <span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="c1"># Traversal has not visited node, or any of its children yet!</span>
            <span class="n">node_key</span> <span class="o">=</span> <span class="n">node_data_func</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">child_dictionary</span><span class="p">[</span><span class="n">node_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">parent</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
                    <span class="n">parent_key</span> <span class="o">=</span> <span class="n">node_data_func</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                    <span class="n">parent_entry</span> <span class="o">=</span> <span class="n">child_dictionary</span><span class="p">[</span><span class="n">parent_key</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">node_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parent_entry</span><span class="p">:</span>
                        <span class="n">parent_entry</span><span class="p">[</span><span class="n">node_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_counts</span><span class="p">[(</span><span class="n">parent</span><span class="p">,</span> <span class="n">node</span><span class="p">)]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">parent_entry</span><span class="p">[</span><span class="n">node_key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">edge_counts</span><span class="p">[(</span><span class="n">parent</span><span class="p">,</span> <span class="n">node</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">child_dictionary</span></div>

<div class="viewcode-block" id="HistoryDag.leaf_path_uncertainty_graphviz"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.leaf_path_uncertainty_graphviz">[docs]</a>    <span class="k">def</span> <span class="nf">leaf_path_uncertainty_graphviz</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">terminal_node</span><span class="p">,</span>
        <span class="n">node_data_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="p">,</span>
        <span class="n">node_label_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">),</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a graphviz DAG of possible paths leading to `terminal_node`</span>

<span class="sd">        Args:</span>
<span class="sd">            terminal_node: The returned path DAG will contain all paths from the</span>
<span class="sd">                UA node ending at this node.</span>
<span class="sd">            node_data_func: A function accepting a HistoryDagNode and returning</span>
<span class="sd">                data for the corresponding node in the path dag. Return type must</span>
<span class="sd">                be a valid dictionary key.</span>
<span class="sd">            node_label_func: A function accepting an object of the type returned</span>
<span class="sd">                by `node_data_func`, and returning a label to be displayed on the</span>
<span class="sd">                corresponding node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total_trees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">Digraph</span><span class="p">(</span><span class="s2">&quot;Path DAG to leaf&quot;</span><span class="p">,</span> <span class="n">node_attr</span><span class="o">=</span><span class="p">{})</span>
        <span class="n">child_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_path_uncertainty_dag</span><span class="p">(</span>
            <span class="n">terminal_node</span><span class="p">,</span> <span class="n">node_data_func</span><span class="o">=</span><span class="n">node_data_func</span>
        <span class="p">)</span>

        <span class="n">label_ids</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">idnum</span><span class="p">)</span> <span class="k">for</span> <span class="n">idnum</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">child_d</span><span class="p">)}</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="p">{</span><span class="n">node_data_func</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">()}</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">child_d</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">source_nodes</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">(</span>
                    <span class="n">label_ids</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">node_label_func</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="s2">&quot;invtriangle&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">child_d</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">label_ids</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">node_label_func</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="s2">&quot;octagon&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">label_ids</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">node_label_func</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child_edge_d</span> <span class="ow">in</span> <span class="n">child_d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">support</span> <span class="ow">in</span> <span class="n">child_edge_d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">parent</span> <span class="o">==</span> <span class="n">child</span><span class="p">:</span>  <span class="c1"># skip self-edges</span>
                    <span class="k">continue</span>
                <span class="c1"># Shifts color pallete to less extreme lower bouund</span>
                <span class="n">color</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;0.0000 </span><span class="si">{</span><span class="n">support</span><span class="o">/</span><span class="n">total_trees</span> <span class="o">*</span> <span class="mf">0.9</span> <span class="o">+</span> <span class="mf">0.1</span><span class="si">}</span><span class="s2"> 1.000&quot;</span>
                <span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span>
                    <span class="n">label_ids</span><span class="p">[</span><span class="n">parent</span><span class="p">],</span>
                    <span class="n">label_ids</span><span class="p">[</span><span class="n">child</span><span class="p">],</span>
                    <span class="n">penwidth</span><span class="o">=</span><span class="s2">&quot;5&quot;</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">support</span><span class="o">/</span><span class="n">total_trees</span><span class="si">:</span><span class="s2">.2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">weight</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">support</span><span class="o">/</span><span class="n">total_trees</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="HistoryDag.summary"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print nicely formatted summary about the history DAG.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nodes:</span><span class="se">\t</span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trees:</span><span class="se">\t</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_counts_with_ambiguities</span><span class="p">())</span></div>

<div class="viewcode-block" id="HistoryDag.label_uncertainty_summary"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.label_uncertainty_summary">[docs]</a>    <span class="k">def</span> <span class="nf">label_uncertainty_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print information about internal nodes which have the same child</span>
<span class="sd">        clades but different labels.&quot;&quot;&quot;</span>
        <span class="n">duplicates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">Counter</span><span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">child_clades</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span>
            <span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Mean unique labels per unique child clade set:&quot;</span><span class="p">,</span>
            <span class="nb">sum</span><span class="p">(</span><span class="n">duplicates</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">duplicates</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximum duplication:&quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">duplicates</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Counts of duplication numbers by unique child clade set:&quot;</span><span class="p">,</span>
            <span class="n">Counter</span><span class="p">(</span><span class="n">duplicates</span><span class="p">),</span>
        <span class="p">)</span></div>

    <span class="c1"># ######## Abstract dp method and derivatives: ########</span>

<div class="viewcode-block" id="HistoryDag.postorder_history_accum"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.postorder_history_accum">[docs]</a>    <span class="k">def</span> <span class="nf">postorder_history_accum</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">leaf_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">],</span>
        <span class="n">edge_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">],</span>
        <span class="n">accum_within_clade</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">],</span>
        <span class="n">accum_between_clade</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">],</span>
        <span class="n">accum_above_edge</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Weight</span><span class="p">,</span> <span class="n">Weight</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Weight</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;A template method for leaf-to-root dynamic programming.</span>

<span class="sd">        Intermediate computations are stored in a `_dp_data` attribute on each node.</span>
<span class="sd">        Note that a `Weight` can be whatever you like, such as integers, Counters,</span>
<span class="sd">        strings, or dictionaries.</span>

<span class="sd">        Args:</span>
<span class="sd">            leaf_func: A function to assign weights to leaf nodes</span>
<span class="sd">            edge_func: A function to assign weights to edges. The parent node will</span>
<span class="sd">                always be the first argument.</span>
<span class="sd">            accum_within_clade: A function which accumulates a list of weights of subtrees</span>
<span class="sd">                below a single clade. That is, the weights are for alternative trees.</span>
<span class="sd">            accum_between_clade: A function which accumulates a list of weights of subtrees</span>
<span class="sd">                below different clades. That is, the weights are for different parts of the</span>
<span class="sd">                same tree.</span>
<span class="sd">            accum_above_edge: A function which adds the weight for a subtree to the weight</span>
<span class="sd">                of the edge above it. If `None`, this function will be inferred from</span>
<span class="sd">                `accum_between_clade`. The edge weight is the second argument.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The resulting weight computed for the History DAG UA (root) node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">accum_above_edge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">default_accum_above_edge</span><span class="p">(</span><span class="n">subtree_weight</span><span class="p">,</span> <span class="n">edge_weight</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">accum_between_clade</span><span class="p">([</span><span class="n">subtree_weight</span><span class="p">,</span> <span class="n">edge_weight</span><span class="p">])</span>

            <span class="n">accum_above_edge</span> <span class="o">=</span> <span class="n">default_accum_above_edge</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">node</span><span class="o">.</span><span class="n">_dp_data</span> <span class="o">=</span> <span class="n">leaf_func</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">_dp_data</span> <span class="o">=</span> <span class="n">accum_between_clade</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">accum_within_clade</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="n">accum_above_edge</span><span class="p">(</span>
                                    <span class="n">target</span><span class="o">.</span><span class="n">_dp_data</span><span class="p">,</span>
                                    <span class="n">edge_func</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">target</span><span class="p">),</span>
                                <span class="p">)</span>
                                <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">clade</span><span class="o">=</span><span class="n">clade</span><span class="p">)</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span>
                    <span class="p">]</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">_dp_data</span></div>

<div class="viewcode-block" id="HistoryDag.postorder_cladetree_accum"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.postorder_cladetree_accum">[docs]</a>    <span class="k">def</span> <span class="nf">postorder_cladetree_accum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Weight</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Deprecated name for :meth:`HistoryDag.postorder_history_accum`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_history_accum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.optimal_weight_annotate"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.optimal_weight_annotate">[docs]</a>    <span class="k">def</span> <span class="nf">optimal_weight_annotate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
            <span class="p">[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">wrapped_hamming_distance</span><span class="p">,</span>
        <span class="n">accum_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">,</span>
        <span class="n">optimal_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Weight</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A template method for finding the optimal tree weight in the DAG.</span>
<span class="sd">        Dynamically annotates each node in the DAG with the optimal weight of a</span>
<span class="sd">        clade sub-tree beneath it, so that the DAG root node is annotated with</span>
<span class="sd">        the optimal weight of a history in the DAG.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_func: A function which assigns starting weights to leaves.</span>
<span class="sd">            edge_weight_func: A function which assigns weights to DAG edges based on the</span>
<span class="sd">                parent node and the child node, in that order.</span>
<span class="sd">            accum_func: A function which takes a list of weights of different parts of a</span>
<span class="sd">                tree, and returns a weight, like sum.</span>
<span class="sd">            optimal_func: A function which takes a list of weights and returns the optimal</span>
<span class="sd">                one, like min.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The optimal weight of a tree under the DAG UA node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_history_accum</span><span class="p">(</span>
            <span class="n">start_func</span><span class="p">,</span>
            <span class="n">edge_weight_func</span><span class="p">,</span>
            <span class="n">optimal_func</span><span class="p">,</span>
            <span class="n">accum_func</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.weight_count"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.weight_count">[docs]</a>    <span class="k">def</span> <span class="nf">weight_count</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
            <span class="p">[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">wrapped_hamming_distance</span><span class="p">,</span>
        <span class="n">accum_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A template method for counting weights of trees expressed in the</span>
<span class="sd">        history DAG.</span>

<span class="sd">        Weights must be hashable, but may otherwise be of arbitrary type.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_func: A function which assigns a weight to each leaf node</span>
<span class="sd">            edge_func: A function which assigns a weight to pairs of labels, with the</span>
<span class="sd">                parent node label the first argument</span>
<span class="sd">            accum_func: A way to &#39;add&#39; a list of weights together</span>

<span class="sd">        Returns:</span>
<span class="sd">            A Counter keyed by weights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_history_accum</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">Counter</span><span class="p">([</span><span class="n">start_func</span><span class="p">(</span><span class="n">n</span><span class="p">)]),</span>
            <span class="k">lambda</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">:</span> <span class="n">Counter</span><span class="p">([</span><span class="n">edge_weight_func</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)]),</span>
            <span class="n">counter_sum</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">counter_prod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">accum_func</span><span class="p">),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.hamming_parsimony_count"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.hamming_parsimony_count">[docs]</a>    <span class="k">def</span> <span class="nf">hamming_parsimony_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deprecated in favor of</span>
<span class="sd">        :meth:`sequence_dag.SequenceHistoryDag.hamming_parsimony_count`.&quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;`HistoryDag.hamming_parsimony_count` is deprecated in favor of&quot;</span>
            <span class="s2">&quot; `sequence_dag.SequenceHistoryDag.hamming_parsimony_count`.&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_count</span><span class="p">()</span></div>

<div class="viewcode-block" id="HistoryDag.to_newicks"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.to_newicks">[docs]</a>    <span class="k">def</span> <span class="nf">to_newicks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of extended newick strings formed with label fields.</span>

<span class="sd">        Arguments are passed to :meth:`utils.make_newickcountfuncs`.</span>
<span class="sd">        Arguments are the same as for</span>
<span class="sd">        :meth:`historydag.HistoryDag.to_newick`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newicks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_count</span><span class="p">(</span><span class="o">**</span><span class="n">utils</span><span class="o">.</span><span class="n">make_newickcountfuncs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span><span class="o">.</span><span class="n">elements</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">newick</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;;&quot;</span> <span class="k">for</span> <span class="n">newick</span> <span class="ow">in</span> <span class="n">newicks</span><span class="p">]</span></div>

<div class="viewcode-block" id="HistoryDag.count_topologies"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.count_topologies">[docs]</a>    <span class="k">def</span> <span class="nf">count_topologies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collapse_leaves</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Counts the number of unique topologies in the history DAG. This is</span>
<span class="sd">        achieved by counting the number of unique newick strings with only</span>
<span class="sd">        leaves labeled.</span>

<span class="sd">        :meth:`count_histories` gives the total number of unique trees in the DAG, taking</span>
<span class="sd">        into account internal node labels.</span>

<span class="sd">        For large DAGs, this method is prohibitively slow. Use :meth:`count_topologies_fast` instead.</span>

<span class="sd">        Args:</span>
<span class="sd">            collapse_leaves: By default, topologies are counted as-is in the DAG. However,</span>
<span class="sd">                even if the DAG is collapsed by label, edges above leaf nodes will not be collapsed.</span>
<span class="sd">                if `collapse_leaves` is True, then the number of unique topologies with all</span>
<span class="sd">                leaf-adjacent edges collapsed will be counted. Assumes that the DAG is collapsed</span>
<span class="sd">                with :meth:`HistoryDag.convert_to_collapsed`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The number of topologies in the history DAG</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">make_newickcountfuncs</span><span class="p">(</span>
            <span class="n">internal_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">collapse_leaves</span><span class="o">=</span><span class="n">collapse_leaves</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_count</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>

<div class="viewcode-block" id="HistoryDag.count_topologies_fast"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.count_topologies_fast">[docs]</a>    <span class="k">def</span> <span class="nf">count_topologies_fast</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Counts the number of unique topologies in the history DAG.</span>

<span class="sd">        This is achieved by creating a new history DAG in which all</span>
<span class="sd">        internal nodes have matching labels.</span>

<span class="sd">        This is only guaranteed to match the output of ``count_topologies``</span>
<span class="sd">        if the DAG has all allowed edges added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unlabel</span><span class="p">()</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span></div>

<div class="viewcode-block" id="HistoryDag.count_trees"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.count_trees">[docs]</a>    <span class="k">def</span> <span class="nf">count_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deprecated name for :meth:`count_histories`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span></div>

<div class="viewcode-block" id="HistoryDag.count_histories"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.count_histories">[docs]</a>    <span class="k">def</span> <span class="nf">count_histories</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">expand_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Label</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">expand_count_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Annotates each node in the DAG with the number of clade sub-trees</span>
<span class="sd">        underneath.</span>

<span class="sd">        Args:</span>
<span class="sd">            expand_func: A function which takes a label and returns a list of labels, for</span>
<span class="sd">                example disambiguations of an ambiguous sequence. If provided, this method</span>
<span class="sd">                will count at least the number of histories that would be in the DAG,</span>
<span class="sd">                if :meth:`explode_nodes` were called with the same `expand_func`.</span>
<span class="sd">            expand_count_func: A function which takes a label and returns an integer value</span>
<span class="sd">                corresponding to the number of &#39;disambiguations&#39; of that label. If provided,</span>
<span class="sd">                `expand_func` will be used to find this value.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The total number of unique complete trees below the root node. If `expand_func`</span>
<span class="sd">            or `expand_count_func` is provided, the complete trees being counted are not</span>
<span class="sd">            guaranteed to be unique.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">expand_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">expand_count_func</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">expand_func</span><span class="p">(</span><span class="n">label</span><span class="p">)))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_history_accum</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">:</span> <span class="n">expand_count_func</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="p">),</span>
            <span class="nb">sum</span><span class="p">,</span>
            <span class="n">prod</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.count_nodes"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.count_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">count_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collapse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Counts the number of trees each node takes part in.</span>

<span class="sd">        Args:</span>
<span class="sd">            collapse: A flag that when set to true, treats nodes as clade unions and</span>
<span class="sd">                ignores label information. Then, the returned dictionary is keyed by</span>
<span class="sd">                clade union sets.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dicitonary mapping each node in the DAG to the number of trees</span>
<span class="sd">            that it takes part in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node2count</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">node2stats</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>
        <span class="n">reverse_postorder</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()))</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">reverse_postorder</span><span class="p">:</span>
            <span class="n">below</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_dp_data</span>
            <span class="n">curr_clade</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
                <span class="n">above</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">above</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="n">above_parent</span> <span class="o">=</span> <span class="n">node2stats</span><span class="p">[</span><span class="n">parent</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">below_parent</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                        <span class="c1"># Skip clade covered by node of interest</span>
                        <span class="k">if</span> <span class="n">clade</span> <span class="o">==</span> <span class="n">curr_clade</span> <span class="ow">or</span> <span class="n">parent</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
                            <span class="k">continue</span>
                        <span class="n">below_clade</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">sib</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">clade</span><span class="o">=</span><span class="n">clade</span><span class="p">):</span>
                            <span class="n">below_clade</span> <span class="o">+=</span> <span class="n">sib</span><span class="o">.</span><span class="n">_dp_data</span>
                        <span class="n">below_parent</span> <span class="o">*=</span> <span class="n">below_clade</span>

                    <span class="n">above</span> <span class="o">+=</span> <span class="n">above_parent</span> <span class="o">*</span> <span class="n">below_parent</span>

            <span class="n">node2count</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">above</span> <span class="o">*</span> <span class="n">below</span>
            <span class="n">node2stats</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">above</span><span class="p">,</span> <span class="n">below</span><span class="p">]</span>

        <span class="n">collapsed_n2c</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">collapse</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node2count</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">clade</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">clade</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">collapsed_n2c</span><span class="p">:</span>
                    <span class="n">collapsed_n2c</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">collapsed_n2c</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span> <span class="o">+=</span> <span class="n">node2count</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">collapsed_n2c</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node2count</span>
        <span class="k">return</span> <span class="n">node2count</span></div>

<div class="viewcode-block" id="HistoryDag.count_edges"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.count_edges">[docs]</a>    <span class="k">def</span> <span class="nf">count_edges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">collapsed</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Counts the number of trees each edge takes part in.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dicitonary mapping each edge in the DAG to the number of trees</span>
<span class="sd">            that it takes part in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edge2count</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">node2stats</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>
        <span class="n">reverse_postorder</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()))</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">reverse_postorder</span><span class="p">:</span>
            <span class="n">below</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_dp_data</span>
            <span class="n">curr_clade</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
                <span class="n">above</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">above</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="n">above_parent</span> <span class="o">=</span> <span class="n">node2stats</span><span class="p">[</span><span class="n">parent</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">below_parent</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                        <span class="c1"># Skip clade covered by node of interest</span>
                        <span class="k">if</span> <span class="n">clade</span> <span class="o">==</span> <span class="n">curr_clade</span> <span class="ow">or</span> <span class="n">parent</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
                            <span class="k">continue</span>
                        <span class="n">below_clade</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">sib</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">clade</span><span class="o">=</span><span class="n">clade</span><span class="p">):</span>
                            <span class="n">below_clade</span> <span class="o">+=</span> <span class="n">sib</span><span class="o">.</span><span class="n">_dp_data</span>
                        <span class="n">below_parent</span> <span class="o">*=</span> <span class="n">below_clade</span>

                    <span class="n">above</span> <span class="o">+=</span> <span class="n">above_parent</span> <span class="o">*</span> <span class="n">below_parent</span>

                    <span class="n">edge2count</span><span class="p">[(</span><span class="n">parent</span><span class="p">,</span> <span class="n">node</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">above_parent</span> <span class="o">*</span> <span class="n">below_parent</span><span class="p">)</span> <span class="o">*</span> <span class="n">below</span>
            <span class="n">node2stats</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">above</span><span class="p">,</span> <span class="n">below</span><span class="p">]</span>

        <span class="n">e2c</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">collapsed</span><span class="p">:</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">),</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">edge2count</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">parent_cu</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
                <span class="n">child_cu</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">parent_cu</span><span class="p">,</span> <span class="n">child_cu</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">e2c</span><span class="p">:</span>
                    <span class="n">e2c</span><span class="p">[(</span><span class="n">parent_cu</span><span class="p">,</span> <span class="n">child_cu</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">e2c</span><span class="p">[(</span><span class="n">parent_cu</span><span class="p">,</span> <span class="n">child_cu</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">count</span>
            <span class="k">return</span> <span class="n">e2c</span>

        <span class="k">return</span> <span class="n">edge2count</span></div>

<div class="viewcode-block" id="HistoryDag.most_supported_trees"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.most_supported_trees">[docs]</a>    <span class="k">def</span> <span class="nf">most_supported_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Trims the DAG to only express the trees that have the highest</span>
<span class="sd">        support.&quot;&quot;&quot;</span>
        <span class="n">node2count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_nodes</span><span class="p">()</span>
        <span class="n">total_trees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>
        <span class="n">clade2support</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">node2count</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">clade2support</span><span class="p">:</span>
                <span class="n">clade2support</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">clade2support</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()]</span> <span class="o">+=</span> <span class="n">count</span> <span class="o">/</span> <span class="n">total_trees</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trim_optimal_weight</span><span class="p">(</span>
            <span class="n">start_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">edge_weight_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">:</span> <span class="n">log</span><span class="p">(</span><span class="n">clade2support</span><span class="p">[</span><span class="n">n2</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()]),</span>
            <span class="n">accum_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">weights</span><span class="p">:</span> <span class="nb">sum</span><span class="p">([</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">]),</span>
            <span class="n">optimal_func</span><span class="o">=</span><span class="nb">max</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">_dp_data</span></div>

<div class="viewcode-block" id="HistoryDag.count_paths_to_leaf"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.count_paths_to_leaf">[docs]</a>    <span class="k">def</span> <span class="nf">count_paths_to_leaf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">leaf_label</span><span class="p">,</span>
        <span class="n">expand_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Label</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">expand_count_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Annotates each node in the DAG with the number of paths to</span>
<span class="sd">        ``leaf_label`` underneath.</span>

<span class="sd">        Args:</span>
<span class="sd">            leaf_label: The label of the leaf node of interest</span>
<span class="sd">            expand_func: A function which takes a label and returns a list of labels, for</span>
<span class="sd">                example disambiguations of an ambiguous sequence. If provided, this method</span>
<span class="sd">                will count at least the number of histories that would be in the DAG,</span>
<span class="sd">                if :meth:`explode_nodes` were called with the same `expand_func`.</span>
<span class="sd">            expand_count_func: A function which takes a label and returns an integer value</span>
<span class="sd">                corresponding to the number of &#39;disambiguations&#39; of that label. If provided,</span>
<span class="sd">                `expand_func` will be used to find this value.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The total number of unique paths to the leaf node of interest. If `expand_func`</span>
<span class="sd">            or `expand_count_func` is provided, the paths being counted are not guaranteed</span>
<span class="sd">            to be unique.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">expand_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">expand_count_func</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">expand_func</span><span class="p">(</span><span class="n">label</span><span class="p">)))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_history_accum</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">leaf_label</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="nb">sum</span><span class="p">,</span>
            <span class="nb">sum</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.weight_counts_with_ambiguities"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.weight_counts_with_ambiguities">[docs]</a>    <span class="k">def</span> <span class="nf">weight_counts_with_ambiguities</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">edge_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">,</span> <span class="n">Label</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">:</span> <span class="p">(</span>
            <span class="mi">0</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">UALabel</span><span class="p">)</span> <span class="k">else</span> <span class="n">utils</span><span class="o">.</span><span class="n">hamming_distance</span><span class="p">(</span><span class="n">l1</span><span class="o">.</span><span class="n">sequence</span><span class="p">,</span> <span class="n">l2</span><span class="o">.</span><span class="n">sequence</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="p">),</span>
        <span class="n">accum_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">,</span>
        <span class="n">expand_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Label</span><span class="p">]]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sequence_resolutions</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Template method for counting tree weights in the DAG, with exploded</span>
<span class="sd">        labels. Like :meth:`HistoryDag.weight_count`, but creates dictionaries</span>
<span class="sd">        of Counter objects at each node, keyed by possible sequences at that</span>
<span class="sd">        node. Analogous to :meth:`HistoryDag.count_histories` with</span>
<span class="sd">        `expand_func` provided.</span>

<span class="sd">        Weights must be hashable.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_func: A function which assigns a weight to each leaf node</span>
<span class="sd">            edge_func: A function which assigns a weight to pairs of labels, with the</span>
<span class="sd">                parent node label the first argument. Must correctly handle the UA</span>
<span class="sd">                node label which is a UALabel instead of a namedtuple.</span>
<span class="sd">            accum_func: A way to &#39;add&#39; a list of weights together</span>
<span class="sd">            expand_func: A function which takes a label and returns a list of labels, such</span>
<span class="sd">                as disambiguations of an ambiguous sequence.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A Counter keyed by weights.</span>
<span class="sd">            The total number of trees will be greater than count_histories(), as these are</span>
<span class="sd">            possible disambiguations of trees. These disambiguations may not be unique,</span>
<span class="sd">            but if two are the same, they come from different subtrees of the DAG.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">wrapped_expand_func</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">is_ua_node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_ua_node</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">label</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">expand_func</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="c1"># The old direct implementation not using postorder_history_accum was</span>
        <span class="c1"># more straightforward, and may be significantly faster.</span>
        <span class="k">def</span> <span class="nf">leaf_func</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="n">label</span><span class="p">:</span> <span class="n">Counter</span><span class="p">({</span><span class="n">start_func</span><span class="p">(</span><span class="n">node</span><span class="p">):</span> <span class="mi">1</span><span class="p">})</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">expand_func</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
            <span class="p">}</span>

        <span class="k">def</span> <span class="nf">edge_weight_func</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
            <span class="c1"># This will handle &#39;adding&#39; child node counts to the edge, so we</span>
            <span class="c1"># have accum_above_edge just return this result.</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="n">label</span><span class="p">:</span> <span class="n">counter_sum</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">counter_prod</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">target_wc</span><span class="p">,</span> <span class="n">Counter</span><span class="p">({</span><span class="n">edge_func</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">childlabel</span><span class="p">):</span> <span class="mi">1</span><span class="p">})],</span>
                            <span class="n">accum_func</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">childlabel</span><span class="p">,</span> <span class="n">target_wc</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">_dp_data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">childlabel</span><span class="p">,</span> <span class="n">target_wc</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">_dp_data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">wrapped_expand_func</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">())</span>
            <span class="p">}</span>

        <span class="k">def</span> <span class="nf">accum_within_clade</span><span class="p">(</span><span class="n">dictlist</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">dictlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">counter_sum</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dictlist</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">accum_between_clade</span><span class="p">(</span><span class="n">dictlist</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">dictlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="n">counter_prod</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dictlist</span><span class="p">],</span> <span class="n">accum_func</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span>
            <span class="p">}</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">postorder_history_accum</span><span class="p">(</span>
                <span class="n">leaf_func</span><span class="p">,</span>
                <span class="n">edge_weight_func</span><span class="p">,</span>
                <span class="n">accum_within_clade</span><span class="p">,</span>
                <span class="n">accum_between_clade</span><span class="p">,</span>
                <span class="n">accum_above_edge</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="HistoryDag.optimal_rf_distance"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.optimal_rf_distance">[docs]</a>    <span class="k">def</span> <span class="nf">optimal_rf_distance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">history</span><span class="p">:</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span>
        <span class="n">rooted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">optimal_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the optimal (min or max) RF distance to a given history.</span>

<span class="sd">        The given history must be on the same taxa as all trees in the DAG.</span>
<span class="sd">        Since computing reference splits is expensive, it is better to use</span>
<span class="sd">        :meth:`optimal_weight_annotate` and :meth:`utils.make_rfdistance_countfuncs`</span>
<span class="sd">        instead of making multiple calls to this method with the same reference</span>
<span class="sd">        history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">make_rfdistance_countfuncs</span><span class="p">(</span><span class="n">history</span><span class="p">,</span> <span class="n">rooted</span><span class="o">=</span><span class="n">rooted</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimal_weight_annotate</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">optimal_func</span><span class="o">=</span><span class="n">optimal_func</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.count_rf_distances"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.count_rf_distances">[docs]</a>    <span class="k">def</span> <span class="nf">count_rf_distances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">history</span><span class="p">:</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span> <span class="n">rooted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a Counter containing all RF distances to a given history.</span>

<span class="sd">        The given history must be on the same taxa as all trees in the DAG.</span>

<span class="sd">        Since computing reference splits is expensive, it is better to use</span>
<span class="sd">        :meth:`weight_count` and :meth:`utils.make_rfdistance_countfuncs`</span>
<span class="sd">        instead of making multiple calls to this method with the same reference</span>
<span class="sd">        history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">make_rfdistance_countfuncs</span><span class="p">(</span><span class="n">history</span><span class="p">,</span> <span class="n">rooted</span><span class="o">=</span><span class="n">rooted</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_count</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1"># ######## End Abstract DP method derivatives ########</span>

<div class="viewcode-block" id="HistoryDag.trim_optimal_weight"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.trim_optimal_weight">[docs]</a>    <span class="k">def</span> <span class="nf">trim_optimal_weight</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
            <span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="n">HistoryDagNode</span><span class="p">],</span> <span class="n">Weight</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">wrapped_hamming_distance</span><span class="p">,</span>
        <span class="n">accum_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">,</span>
        <span class="n">optimal_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">,</span>
        <span class="c1"># max_weight: Weight = None,</span>
        <span class="n">eq_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Weight</span><span class="p">,</span> <span class="n">Weight</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">:</span> <span class="n">w1</span> <span class="o">==</span> <span class="n">w2</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Weight</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Trims the DAG to only express trees with optimal weight. This is</span>
<span class="sd">        guaranteed to be possible when edge_weight_func depends only on the</span>
<span class="sd">        labels of an edge&#39;s parent and child node.</span>

<span class="sd">        Requires that weights are of a type that supports reliable equality</span>
<span class="sd">        testing. In particular, floats are not recommended. Instead, consider</span>
<span class="sd">        defining weights to be a precursor type, and define `optimal_func` to</span>
<span class="sd">        choose the one whose corresponding float is maximized/minimized.</span>

<span class="sd">        If floats must be used, a Numpy type may help.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_func: A function which assigns starting weights to leaves.</span>
<span class="sd">            edge_weight_func: A function which assigns weights to DAG edges based on the</span>
<span class="sd">                parent node and the child node, in that order.</span>
<span class="sd">            accum_func: A function which takes a list of weights of different parts of a tree,</span>
<span class="sd">                and returns a weight, like sum.</span>
<span class="sd">            optimal_func: A function which takes a list of weights and returns the optimal</span>
<span class="sd">                one, like min.</span>
<span class="sd">            eq_func: A function which tests equality, taking a pair of weights and returning a bool.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">opt_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimal_weight_annotate</span><span class="p">(</span>
            <span class="n">start_func</span><span class="o">=</span><span class="n">start_func</span><span class="p">,</span>
            <span class="n">edge_weight_func</span><span class="o">=</span><span class="n">edge_weight_func</span><span class="p">,</span>
            <span class="n">accum_func</span><span class="o">=</span><span class="n">accum_func</span><span class="p">,</span>
            <span class="n">optimal_func</span><span class="o">=</span><span class="n">optimal_func</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">weightlist</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="n">accum_func</span><span class="p">([</span><span class="n">target</span><span class="o">.</span><span class="n">_dp_data</span><span class="p">,</span> <span class="n">edge_weight_func</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">target</span><span class="p">)]),</span>
                        <span class="n">target</span><span class="p">,</span>
                        <span class="n">index</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="n">optimalweight</span> <span class="o">=</span> <span class="n">optimal_func</span><span class="p">([</span><span class="n">weight</span> <span class="k">for</span> <span class="n">weight</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">weightlist</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">weight</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">weightlist</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">eq_func</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">optimalweight</span><span class="p">):</span>
                        <span class="n">eset</span><span class="o">.</span><span class="n">remove_from_edgeset_byid</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Value returned by ``optimal_func`` </span><span class="si">{</span><span class="n">optimal_func</span><span class="si">}</span><span class="s2"> is not in the &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;list of weights passed to that function, according to eq_func </span><span class="si">{</span><span class="n">eq_func</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="n">eset</span><span class="o">.</span><span class="n">set_edge_stats</span><span class="p">(</span><span class="n">probs</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">opt_weight</span></div>

<div class="viewcode-block" id="HistoryDag.get_topologies"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.get_topologies">[docs]</a>    <span class="k">def</span> <span class="nf">get_topologies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collapse_leaves</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return a list of pseudo-newick representations of topologies in the</span>
<span class="sd">        history DAG.</span>

<span class="sd">        The newicks returned are not well-formed, and are for use with</span>
<span class="sd">        :meth:`HistoryDag.trim_topology`. Otherwise, this method would be equivalent to</span>
<span class="sd">        :meth:`HistoryDag.to_newicks` with keyword arguments ``internal_labels=False`` and</span>
<span class="sd">        ``collapsed_leaves`` as desired.</span>

<span class="sd">        Args:</span>
<span class="sd">            collapse_leaves: Whether to collapse leaf-adjacent edges between nodes with</span>
<span class="sd">                matching labels</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of strings, each representing a topology present in the history DAG.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">make_newickcountfuncs</span><span class="p">(</span>
            <span class="n">internal_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">collapse_leaves</span><span class="o">=</span><span class="n">collapse_leaves</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_count</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

<div class="viewcode-block" id="HistoryDag.trim_topology"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.trim_topology">[docs]</a>    <span class="k">def</span> <span class="nf">trim_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topology</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">collapse_leaves</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Trims the history DAG to express only trees matching the provided</span>
<span class="sd">        topology.</span>

<span class="sd">        Args:</span>
<span class="sd">            topology: A string like one output by :meth:`HistoryDag.get_topologies`</span>
<span class="sd">            collapse_leaves: must match the same argument provided to :meth:`HistoryDag.get_topologies`</span>
<span class="sd">                when creating the string passed as ``topology``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">min_func</span><span class="p">(</span><span class="n">newicks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="c1"># Each newick in presented to min_func will be well-formed, since</span>
            <span class="c1"># it will consist of a subtree newick added to a parent edge&#39;s</span>
            <span class="c1"># newick.</span>
            <span class="k">for</span> <span class="n">newick</span> <span class="ow">in</span> <span class="n">newicks</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">newick</span> <span class="ow">in</span> <span class="n">topology</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">newick</span>
            <span class="k">if</span> <span class="n">newicks</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;(;)&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;min_func() arg is an empty sequence&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trim_optimal_weight</span><span class="p">(</span>
            <span class="o">**</span><span class="n">utils</span><span class="o">.</span><span class="n">make_newickcountfuncs</span><span class="p">(</span>
                <span class="n">internal_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">collapse_leaves</span><span class="o">=</span><span class="n">collapse_leaves</span>
            <span class="p">),</span>
            <span class="n">optimal_func</span><span class="o">=</span><span class="n">min_func</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.recompute_parents"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.recompute_parents">[docs]</a>    <span class="k">def</span> <span class="nf">recompute_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Repopulate ``HistoryDagNode.parent`` attributes.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="n">node</span><span class="o">.</span><span class="n">parents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.convert_to_collapsed"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.convert_to_collapsed">[docs]</a>    <span class="k">def</span> <span class="nf">convert_to_collapsed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Rebuilds the DAG so that no edge connects two nodes with the same</span>
<span class="sd">        label, unless one is a leaf node.</span>

<span class="sd">        The resulting DAG should express at least the collapsed</span>
<span class="sd">        histories present in the original.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())</span>
        <span class="n">nodedict</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span>
        <span class="n">edgequeue</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">parent</span><span class="p">,</span> <span class="n">target</span><span class="p">]</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">nodes</span> <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="k">while</span> <span class="n">edgequeue</span><span class="p">:</span>
            <span class="n">parent</span><span class="p">,</span> <span class="n">child</span> <span class="o">=</span> <span class="n">edgequeue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">clade</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">parent</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">child</span><span class="o">.</span><span class="n">label</span>
                <span class="ow">and</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">nodedict</span>
                <span class="ow">and</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">nodedict</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">child</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="n">parent_clade_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
                <span class="n">new_parent_clades</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="nb">frozenset</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="p">{</span><span class="n">clade</span><span class="p">}</span>
                <span class="p">)</span> <span class="o">|</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">newparenttemp</span> <span class="o">=</span> <span class="n">empty_node</span><span class="p">(</span>
                    <span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">new_parent_clades</span><span class="p">,</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">newparenttemp</span> <span class="ow">in</span> <span class="n">nodedict</span><span class="p">:</span>
                    <span class="n">newparent</span> <span class="o">=</span> <span class="n">nodedict</span><span class="p">[</span><span class="n">newparenttemp</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newparent</span> <span class="o">=</span> <span class="n">newparenttemp</span>
                    <span class="n">nodedict</span><span class="p">[</span><span class="n">newparent</span><span class="p">]</span> <span class="o">=</span> <span class="n">newparent</span>
                <span class="c1"># Add parents of parent to newparent</span>
                <span class="k">for</span> <span class="n">grandparent</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="n">grandparent</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">newparent</span><span class="p">)</span>  <span class="c1"># check parents logic</span>
                    <span class="n">edgequeue</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">grandparent</span><span class="p">,</span> <span class="n">newparent</span><span class="p">])</span>
                <span class="c1"># Add children of other clades to newparent</span>
                <span class="k">for</span> <span class="n">otherclade</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">otherclade</span> <span class="o">!=</span> <span class="n">clade</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">othertarget</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">otherclade</span><span class="p">]</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
                            <span class="n">newparent</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">othertarget</span><span class="p">)</span>
                            <span class="n">edgequeue</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">newparent</span><span class="p">,</span> <span class="n">othertarget</span><span class="p">])</span>
                <span class="c1"># Add children of old child to newparent</span>
                <span class="k">for</span> <span class="n">grandchild</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                    <span class="n">newparent</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">grandchild</span><span class="p">)</span>
                    <span class="n">edgequeue</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">newparent</span><span class="p">,</span> <span class="n">grandchild</span><span class="p">])</span>
                <span class="c1"># Remove the edge we were fixing from old parent</span>
                <span class="n">parent</span><span class="o">.</span><span class="n">remove_edge_by_clade_and_id</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">clade</span><span class="p">)</span>
                <span class="c1"># Clean up the DAG:</span>
                <span class="c1"># Delete old parent if it is no longer a valid node</span>
                <span class="k">if</span> <span class="n">parent_clade_edges</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Remove old parent as child of all of its parents</span>
                    <span class="c1"># no need for recursion here, all of its parents had</span>
                    <span class="c1"># edges added to new parent from the same clade.</span>
                    <span class="n">upclade</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">grandparent</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">parents</span><span class="p">):</span>
                        <span class="n">grandparent</span><span class="o">.</span><span class="n">remove_edge_by_clade_and_id</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">upclade</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">child2</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                        <span class="n">child2</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">child2</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                            <span class="n">child2</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">nodedict</span><span class="o">=</span><span class="n">nodedict</span><span class="p">)</span>
                    <span class="n">nodedict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

                <span class="c1"># Remove child, if child no longer has parents</span>
                <span class="k">if</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="c1"># This recursively removes children of child too, if necessary</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">nodedict</span><span class="o">=</span><span class="n">nodedict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span></div>

<div class="viewcode-block" id="HistoryDag.add_node_at_all_possible_places"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.add_node_at_all_possible_places">[docs]</a>    <span class="k">def</span> <span class="nf">add_node_at_all_possible_places</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_leaf_id</span><span class="p">,</span> <span class="n">id_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sequence&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inserts a sequence into the dag such that every tree in the dag now</span>
<span class="sd">        contains that new node.</span>

<span class="sd">        This method adds the new node as a leaf node by connecting it as</span>
<span class="sd">        a child of every non-leaf node in the original dag. The</span>
<span class="sd">        resulting dag has one new node corresponding to the added</span>
<span class="sd">        sequence as well as copies of all internal nodes corresponding</span>
<span class="sd">        to parents (and more ancestral nodes) to the added sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">postorder</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">new_leaf_id</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">id_name</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">postorder</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="p">):</span>
            <span class="c1"># make sure all connections are correctly built before manipulating dag</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>

            <span class="c1"># create a new node corresponding to new_sequence</span>
            <span class="n">new_leaf</span> <span class="o">=</span> <span class="n">empty_node</span><span class="p">(</span>
                <span class="n">postorder</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">id_name</span><span class="p">:</span> <span class="n">new_leaf_id</span><span class="p">}),</span> <span class="p">{},</span> <span class="kc">None</span>
            <span class="p">)</span>

            <span class="n">dagnodes</span> <span class="o">=</span> <span class="p">{</span><span class="n">new_leaf</span><span class="p">:</span> <span class="n">new_leaf</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">postorder</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()):</span>
                    <span class="c1"># create a copy of the node that has new_leaf as a direct child</span>
                    <span class="n">clades</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">frozenset</span><span class="p">([</span><span class="n">new_leaf</span><span class="o">.</span><span class="n">label</span><span class="p">])]</span>
                    <span class="n">node_copy_as_parent</span> <span class="o">=</span> <span class="n">empty_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">clades</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="n">dagnodes</span><span class="p">[</span><span class="n">node_copy_as_parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_copy_as_parent</span>

                    <span class="c1"># for each child clade, create a copy of the node as an ancestor</span>
                    <span class="c1"># of new_leaf through that clade</span>
                    <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clade</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">clades</span> <span class="o">=</span> <span class="p">[</span>
                                <span class="n">c</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">clade</span> <span class="k">else</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">clade</span> <span class="o">|</span> <span class="p">{</span><span class="n">new_leaf</span><span class="o">.</span><span class="n">label</span><span class="p">})</span>
                                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span>
                            <span class="p">]</span>
                            <span class="n">node_copy_as_ancestor</span> <span class="o">=</span> <span class="n">empty_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">clades</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                            <span class="n">dagnodes</span><span class="p">[</span><span class="n">node_copy_as_ancestor</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_copy_as_ancestor</span>

                    <span class="c1"># if the current node is internal to any trees in the dag, then keep</span>
                    <span class="c1"># a copy of the node that does not have new_node as a descendant</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">]):</span>
                        <span class="n">nodecopy</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">()</span>
                        <span class="n">dagnodes</span><span class="p">[</span><span class="n">nodecopy</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodecopy</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nodecopy</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">()</span>
                    <span class="n">dagnodes</span><span class="p">[</span><span class="n">nodecopy</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodecopy</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">history_dag_from_nodes</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">dagnodes</span><span class="p">))</span><span class="o">.</span><span class="n">dagroot</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.insert_node"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.insert_node">[docs]</a>    <span class="k">def</span> <span class="nf">insert_node</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_leaf_id</span><span class="p">,</span>
        <span class="n">id_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sequence&quot;</span><span class="p">,</span>
        <span class="n">dist</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
            <span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="n">HistoryDagNode</span><span class="p">],</span> <span class="n">Weight</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">wrapped_hamming_distance</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inserts a sequence into the DAG.</span>

<span class="sd">        Sequence will be inserted as a child of the dagnode(s)</span>
<span class="sd">        realizing the minimum overall distance between sequences, and also added</span>
<span class="sd">        to the dag as a child of other nodes in such a way as to guarantee</span>
<span class="sd">        that every tree in the DAG now contains the new sequence.</span>

<span class="sd">        The choice of other nodes is computed by looking at the set of</span>
<span class="sd">        nodes that are `incompatible` with the first minimizing node.</span>
<span class="sd">        For a full description of this, see the docstring for the method-local</span>
<span class="sd">        function ``incompatible``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># all nodes in the dag except for the UA</span>
        <span class="n">postorder</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">new_leaf_id</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">id_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">postorder</span><span class="p">]):</span>

            <span class="k">def</span> <span class="nf">insert_node_as_sibling</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">sib</span><span class="p">):</span>
                <span class="n">altered_nodes</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="k">def</span> <span class="nf">follow_up</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">old_node_cu</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">old_node_cu</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                            <span class="n">old_p</span> <span class="o">=</span> <span class="n">p</span>
                            <span class="n">p_clade_union</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
                            <span class="n">edgeset</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">old_node_cu</span><span class="p">)</span>
                            <span class="n">p</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()]</span> <span class="o">=</span> <span class="n">edgeset</span>
                            <span class="n">altered_nodes</span><span class="p">[</span><span class="n">old_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
                            <span class="n">follow_up</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p_clade_union</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">sib</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">clade_union</span><span class="p">():</span>
                        <span class="n">old_parent</span> <span class="o">=</span> <span class="n">parent</span>
                        <span class="n">parent_clade_union</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
                        <span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">])]</span> <span class="o">=</span> <span class="n">EdgeSet</span><span class="p">([</span><span class="n">node</span><span class="p">])</span>
                        <span class="n">altered_nodes</span><span class="p">[</span><span class="n">old_parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span>
                        <span class="n">follow_up</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">parent_clade_union</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">altered_nodes</span>

            <span class="k">def</span> <span class="nf">insert_node_as_child</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
                <span class="n">altered_nodes</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="k">def</span> <span class="nf">follow_up</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">old_node_cu</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">old_node_cu</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                            <span class="n">old_p</span> <span class="o">=</span> <span class="n">p</span>
                            <span class="n">p_clade_union</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
                            <span class="n">edgeset</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">old_node_cu</span><span class="p">)</span>
                            <span class="n">p</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()]</span> <span class="o">=</span> <span class="n">edgeset</span>
                            <span class="n">altered_nodes</span><span class="p">[</span><span class="n">old_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
                            <span class="n">follow_up</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p_clade_union</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">clade_union</span><span class="p">():</span>
                    <span class="n">old_parent</span> <span class="o">=</span> <span class="n">parent</span>
                    <span class="n">parent_clade_union</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
                    <span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">])]</span> <span class="o">=</span> <span class="n">EdgeSet</span><span class="p">([</span><span class="n">node</span><span class="p">])</span>
                    <span class="n">altered_nodes</span><span class="p">[</span><span class="n">old_parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span>
                    <span class="n">follow_up</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">parent_clade_union</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">altered_nodes</span>

            <span class="k">def</span> <span class="nf">find_min_dist_nodes</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">node_set</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Finds the set of nodes in arg `node_set` that realize the</span>
<span class="sd">                minimum distance to `new_node` (sort so that leaf nodes are at</span>
<span class="sd">                the end of the list)&quot;&quot;&quot;</span>
                <span class="n">return_set</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">min_dist</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_set</span><span class="p">:</span>
                    <span class="n">this_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">new_node</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">this_dist</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">:</span>
                        <span class="n">return_set</span> <span class="o">=</span> <span class="p">[(</span><span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">(),</span> <span class="n">node</span><span class="p">)]</span>
                        <span class="n">min_dist</span> <span class="o">=</span> <span class="n">this_dist</span>
                    <span class="k">elif</span> <span class="n">this_dist</span> <span class="o">&lt;=</span> <span class="n">min_dist</span><span class="p">:</span>
                        <span class="n">return_set</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">(),</span> <span class="n">node</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="n">return_set</span><span class="p">)))[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">def</span> <span class="nf">incompatible</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Checks if nodes n1 and n2 are `incompatible` in the sense</span>
<span class="sd">                that, based on their clade sets, they cannot both come from the</span>
<span class="sd">                same tree in the DAG.</span>

<span class="sd">                Note that, just because 2 nodes might be compatible does</span>
<span class="sd">                not mean that they actually are in the same tree. Merely</span>
<span class="sd">                that they could be.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="n">n1</span><span class="o">.</span><span class="n">is_root</span><span class="p">()</span> <span class="ow">or</span> <span class="n">n2</span><span class="o">.</span><span class="n">is_root</span><span class="p">():</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">n1</span> <span class="o">==</span> <span class="n">n2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">n1</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">B</span> <span class="k">for</span> <span class="n">B</span> <span class="ow">in</span> <span class="n">n2</span><span class="o">.</span><span class="n">child_clades</span><span class="p">()]):</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">n2</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">B</span> <span class="k">for</span> <span class="n">B</span> <span class="ow">in</span> <span class="n">n1</span><span class="o">.</span><span class="n">child_clades</span><span class="p">()]):</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="n">leaf_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">:</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()}</span>

            <span class="k">def</span> <span class="nf">incompatible_set</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">nodeset</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Returns the set of all nodes incompatible to `node` that</span>
<span class="sd">                satisfy the conditions:</span>

<span class="sd">                1. incompatible nodes lie in the path between the leaf</span>
<span class="sd">                nodes reachable by arg `node` and the UA,</span>
<span class="sd">                2. only the subset of incompatible nodes that are also in</span>
<span class="sd">                the set of nodes arg `nodeset`</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">leaf_label</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">():</span>
                    <span class="k">yield from</span> <span class="p">(</span>
                        <span class="n">n</span>
                        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_above</span><span class="p">(</span>
                            <span class="n">leaf_dict</span><span class="p">[</span><span class="n">leaf_label</span><span class="p">],</span> <span class="n">recompute_parents</span><span class="o">=</span><span class="kc">False</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="ow">in</span> <span class="n">nodeset</span> <span class="ow">and</span> <span class="n">incompatible</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
                    <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">empty_node</span><span class="p">(</span>
                <span class="n">postorder</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">id_name</span><span class="p">:</span> <span class="n">new_leaf_id</span><span class="p">}),</span> <span class="p">{},</span> <span class="kc">None</span>
            <span class="p">)</span>
            <span class="n">changed_nodes</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">incompatible_nodes_so_far</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">postorder</span><span class="p">)</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">incompatible_nodes_so_far</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">min_dist_nodes</span> <span class="o">=</span> <span class="n">find_min_dist_nodes</span><span class="p">(</span>
                    <span class="n">new_node</span><span class="p">,</span> <span class="n">incompatible_nodes_so_far</span><span class="p">,</span> <span class="n">dist</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">other_node</span> <span class="ow">in</span> <span class="n">min_dist_nodes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">other_node</span> <span class="ow">in</span> <span class="n">incompatible_nodes_so_far</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">other_node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">changed_nodes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">changed_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                                    <span class="n">insert_node_as_sibling</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">other_node</span><span class="p">)</span>
                                <span class="p">)</span>
                                <span class="n">incompatible_nodes_so_far</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">incompatible_nodes_so_far</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">other_node</span><span class="p">)</span>
                            <span class="n">incompatible_nodes_so_far</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                                <span class="n">incompatible_set</span><span class="p">(</span><span class="n">other_node</span><span class="p">,</span> <span class="n">incompatible_nodes_so_far</span><span class="p">)</span>
                            <span class="p">)</span>
                            <span class="n">changed_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                                <span class="n">insert_node_as_child</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">other_node</span><span class="p">)</span>
                            <span class="p">)</span>
                            <span class="n">incompatible_nodes_so_far</span> <span class="o">=</span> <span class="p">[</span>
                                <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">changed_nodes</span> <span class="k">else</span> <span class="n">changed_nodes</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">incompatible_nodes_so_far</span>
                            <span class="p">]</span>

            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">edgeset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">edgeset</span><span class="o">.</span><span class="n">set_targets</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">n</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">changed_nodes</span> <span class="k">else</span> <span class="n">changed_nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">edgeset</span><span class="o">.</span><span class="n">targets</span>
                    <span class="p">]</span>
                <span class="p">)</span></div>

    <span class="c1"># ######## DAG Traversal Methods ########</span>

<div class="viewcode-block" id="HistoryDag.postorder_above"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.postorder_above">[docs]</a>    <span class="k">def</span> <span class="nf">postorder_above</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">terminal_node</span><span class="p">,</span> <span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">recompute_parents</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recursive postorder traversal of all ancestors of a (possibly</span>
<span class="sd">        internal) node. This traversal is postorder with respect to reversed</span>
<span class="sd">        edge directions. With respect to standard edge directions (pointing</span>
<span class="sd">        towards leaves), the traversal order guarantees that all of a node&#39;s</span>
<span class="sd">        parents will be visited before the node itself.</span>

<span class="sd">        Args:</span>
<span class="sd">            terminal_node: The node whose ancestors should be included in the</span>
<span class="sd">                traversal. This must actually be a node in `self`, not simply</span>
<span class="sd">                compare equal to a node in `self`.</span>
<span class="sd">            skip_ua_node: If True, the UA node will not be included in the traversal</span>
<span class="sd">            recompute_parents: If False, node parent sets will not be recomputed.</span>
<span class="sd">                This makes many repeated calls to postorder_above much faster.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Generator on nodes that lie on any path between node_as_leaf and UA node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">recompute_parents</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">HistoryDagNode</span><span class="p">):</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">id</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">skip_ua_node</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">parent</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()):</span>
                        <span class="k">yield from</span> <span class="n">traverse</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">node</span>

        <span class="k">yield from</span> <span class="n">traverse</span><span class="p">(</span><span class="n">terminal_node</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.postorder"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.postorder">[docs]</a>    <span class="k">def</span> <span class="nf">postorder</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">include_root</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Recursive postorder traversal of the history DAG.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Generator on nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">HistoryDagNode</span><span class="p">):</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">id</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="k">yield from</span> <span class="n">traverse</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">node</span>

        <span class="k">yield from</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.preorder"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.preorder">[docs]</a>    <span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_root</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Recursive postorder traversal of the history DAG.</span>

<span class="sd">        Careful! This is not guaranteed to visit a parent node before any of its children.</span>
<span class="sd">        for that, need reverse postorder traversal.</span>

<span class="sd">        If skip_ua_node is passed, the universal ancestor node will be skipped.</span>
<span class="sd">        skip_root is provided as a backwards-compatible synonym of skip_ua_node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Generator on nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">skip_root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skip_ua_node</span> <span class="o">=</span> <span class="n">skip_root</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">HistoryDagNode</span><span class="p">):</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="k">yield</span> <span class="n">node</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">id</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="k">yield from</span> <span class="n">traverse</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

        <span class="n">gen</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">skip_ua_node</span><span class="p">:</span>
            <span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="k">yield from</span> <span class="n">gen</span></div></div>


<div class="viewcode-block" id="EdgeSet"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.EdgeSet">[docs]</a><span class="k">class</span> <span class="nc">EdgeSet</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A container class for edge target nodes, and associated probabilities</span>
<span class="sd">    and weights.</span>

<span class="sd">    Goal: associate targets (edges) with arbitrary parameters, but support</span>
<span class="sd">    set-like operations like lookup and enforce that elements are unique.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="EdgeSet.__init__"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.EdgeSet.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">probs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Takes no arguments, or an ordered iterable containing target</span>
<span class="sd">        nodes.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">targets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">targets</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;__init__() takes 0 or 1 positional arguments but </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="si">}</span><span class="s2"> were given.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_targets</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">probs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">))</span>
        <span class="p">)</span>

<div class="viewcode-block" id="EdgeSet.set_targets"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.EdgeSet.set_targets">[docs]</a>    <span class="k">def</span> <span class="nf">set_targets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">probs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the target nodes of this node.</span>

<span class="sd">        If no weights or probabilities are provided, then these will be</span>
<span class="sd">        set to 0 and 1/n, respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">targets</span><span class="p">))</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;duplicate target nodes provided: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">targets</span><span class="p">))</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span><span class="si">}</span><span class="s2"> unique.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">targets</span> <span class="o">=</span> <span class="n">targets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_targetset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="k">if</span> <span class="n">probs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">probs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">probs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_stats</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">probs</span><span class="p">)</span></div>

<div class="viewcode-block" id="EdgeSet.set_edge_stats"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.EdgeSet.set_edge_stats">[docs]</a>    <span class="k">def</span> <span class="nf">set_edge_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">probs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the edge weights and/or probabilities of this EdgeSet.&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;length of provided weights list must match number of target nodes&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="k">if</span> <span class="n">probs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;length of provided probabilities list must match number of target nodes&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">probs</span> <span class="o">=</span> <span class="n">probs</span></div>

<div class="viewcode-block" id="EdgeSet.shallowcopy"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.EdgeSet.shallowcopy">[docs]</a>    <span class="k">def</span> <span class="nf">shallowcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;EdgeSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return an identical EdgeSet object, which points to the same target</span>
<span class="sd">        nodes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">EdgeSet</span><span class="p">(</span>
            <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">],</span>
            <span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="n">probs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">probs</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">remove_from_edgeset_byid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_node</span><span class="p">):</span>
        <span class="n">idlist</span> <span class="o">=</span> <span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">target_node</span><span class="p">)</span> <span class="ow">in</span> <span class="n">idlist</span><span class="p">:</span>
            <span class="n">idx_to_remove</span> <span class="o">=</span> <span class="n">idlist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">target_node</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx_to_remove</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">probs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx_to_remove</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx_to_remove</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_targetset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>

<div class="viewcode-block" id="EdgeSet.sample"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.EdgeSet.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns a randomly sampled child edge, and its corresponding weight.</span>

<span class="sd">        When possible, only edges pointing to child nodes on which</span>
<span class="sd">        ``selection_function`` evaluates to True will be sampled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">probs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">factor</span> <span class="o">*</span> <span class="n">prob</span> <span class="k">for</span> <span class="n">factor</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">probs</span><span class="p">)]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">))),</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">index</span><span class="p">])</span></div>

<div class="viewcode-block" id="EdgeSet.add_to_edgeset"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.EdgeSet.add_to_edgeset">[docs]</a>    <span class="k">def</span> <span class="nf">add_to_edgeset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prob_norm</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add a target node to the EdgeSet.</span>

<span class="sd">        currently does nothing if edge is already present. Also does nothing</span>
<span class="sd">        if the target node has one child clade, and parent node is not the DAG root.</span>

<span class="sd">        Args:</span>
<span class="sd">            target: target node</span>
<span class="sd">            weight: edge weight</span>
<span class="sd">            prob: edge probability. If not provided, edge probability will be</span>
<span class="sd">                1 / n where n is the number of edges in the edgeset.</span>
<span class="sd">            prob_norm: if True, probability vector will be normalized.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Whether an edge was added</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Edges that target UA nodes are not allowed. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Target node has label </span><span class="si">{</span><span class="n">target</span><span class="o">.</span><span class="n">label</span><span class="si">}</span><span class="s2"> and therefore &quot;</span>
                <span class="s2">&quot;is assumed to be the DAG UA root node.&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_targetset</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_targetset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">prob</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">prob</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">prob_norm</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">probs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">prob</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">probs</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">probs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span></div></div>


<span class="c1"># ######## DAG Creation Functions ########</span>


<div class="viewcode-block" id="empty_node"><a class="viewcode-back" href="../../stubs/historydag.empty_node.html#historydag.empty_node">[docs]</a><span class="k">def</span> <span class="nf">empty_node</span><span class="p">(</span>
    <span class="n">label</span><span class="p">:</span> <span class="n">Label</span><span class="p">,</span> <span class="n">clades</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="n">Label</span><span class="p">]],</span> <span class="n">attr</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDagNode</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return a HistoryDagNode with the given label and clades, with no</span>
<span class="sd">    children.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">HistoryDagNode</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="p">{</span><span class="n">clade</span><span class="p">:</span> <span class="n">EdgeSet</span><span class="p">()</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">clades</span><span class="p">},</span> <span class="n">attr</span><span class="p">)</span></div>


<div class="viewcode-block" id="from_tree"><a class="viewcode-back" href="../../stubs/historydag.from_tree.html#historydag.from_tree">[docs]</a><span class="k">def</span> <span class="nf">from_tree</span><span class="p">(</span>
    <span class="n">treeroot</span><span class="p">:</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">,</span>
    <span class="n">label_features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">label_functions</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">attr_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">child_node_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
        <span class="p">[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">,</span>
    <span class="n">leaf_node_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
        <span class="p">[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">,</span>
    <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Build a tree-shaped :meth:`historydag.HistoryDag` (a &#39;history&#39;) object</span>
<span class="sd">    from the provided tree data.</span>

<span class="sd">    Default arguments are suitable for loading a :class:`ete3.Tree`, but by providing</span>
<span class="sd">    appropriate `child_node_func` and `leaf_node_func`, any data structure implementing</span>
<span class="sd">    a tree can be used.</span>

<span class="sd">    Args:</span>
<span class="sd">        treeroot: The root node of a tree to be converted to HistoryDag history</span>
<span class="sd">        label_features: tree node attribute names to be used as HistoryDagNode label fields.</span>
<span class="sd">            Each attribute name must be accessible by ``getattr(treenode, name)``.</span>
<span class="sd">            Field names provided in `label_functions` will take precedence.</span>
<span class="sd">        label_functions: dictionary keyed by additional label field names, containing</span>
<span class="sd">            functions mapping tree nodes to intended label field values.</span>
<span class="sd">        attr_func: function to populate HistoryDag node `attr` attribute,</span>
<span class="sd">            which is not used to distinguish nodes, and may be overwritten</span>
<span class="sd">            by `attr` of another node with the same label and child clades.</span>
<span class="sd">        child_node_func: function taking a tree node and returning an iterable</span>
<span class="sd">            containing the node&#39;s children. By default, accesses node&#39;s</span>
<span class="sd">            `children` attribute.</span>
<span class="sd">        leaf_node_func: function accepting a tree node and returning an iterable</span>
<span class="sd">            containing the leaf nodes accessible from that node.</span>
<span class="sd">        edge_weight_func: function accepting a tree node and returning the weight</span>
<span class="sd">            of that node&#39;s parent edge.</span>

<span class="sd">    Returns:</span>
<span class="sd">        HistoryDag object, which has the same topology as the input tree, with the required</span>
<span class="sd">        UA node added as a new root.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># see https://stackoverflow.com/questions/50298582/why-does-python-asyncio-loop-call-soon-overwrite-data</span>
    <span class="c1"># or https://stackoverflow.com/questions/25670516/strange-overwriting-occurring-when-using-lambda-functions-as-dict-values</span>
    <span class="c1"># for why we can&#39;t just use lambda funcs defined in dict comprehension.</span>
    <span class="k">def</span> <span class="nf">getnamefunc</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">getter</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">getter</span>

    <span class="n">feature_maps</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">getnamefunc</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">label_features</span><span class="p">}</span>
    <span class="n">feature_maps</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">label_functions</span><span class="p">)</span>
    <span class="n">Label</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span><span class="s2">&quot;Label&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="n">label</span><span class="p">,</span> <span class="n">Any</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">feature_maps</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>  <span class="c1"># type: ignore</span>

    <span class="k">def</span> <span class="nf">node_label</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">):</span>
        <span class="c1"># This should not fail silently! Only DAG UA node is allowed to have</span>
        <span class="c1"># default (None) label values.</span>
        <span class="k">return</span> <span class="n">Label</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">feature_maps</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>

    <span class="k">def</span> <span class="nf">leaf_names</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">node_label</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">leaf_node_func</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_unrooted_from_tree</span><span class="p">(</span><span class="n">treeroot</span><span class="p">):</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="n">HistoryDagNode</span><span class="p">(</span>
            <span class="n">node_label</span><span class="p">(</span><span class="n">treeroot</span><span class="p">),</span>
            <span class="p">{</span>
                <span class="n">leaf_names</span><span class="p">(</span><span class="n">child</span><span class="p">):</span> <span class="n">EdgeSet</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">_unrooted_from_tree</span><span class="p">(</span><span class="n">child</span><span class="p">)],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="n">edge_weight_func</span><span class="p">(</span><span class="n">child</span><span class="p">)]</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">child_node_func</span><span class="p">(</span><span class="n">treeroot</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="n">attr_func</span><span class="p">(</span><span class="n">treeroot</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">dag</span>

    <span class="c1"># Check for unique leaf labels:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">leaf_node_func</span><span class="p">(</span><span class="n">treeroot</span><span class="p">)))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaf_names</span><span class="p">(</span><span class="n">treeroot</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;This tree&#39;s leaves are not labeled uniquely. Check your tree, &quot;</span>
            <span class="s2">&quot;or modify the label fields so that leaves are unique.</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Checking for unifurcation is handled in HistoryDagNode.__init__.</span>

    <span class="n">dag</span> <span class="o">=</span> <span class="n">_unrooted_from_tree</span><span class="p">(</span><span class="n">treeroot</span><span class="p">)</span>
    <span class="n">dagroot</span> <span class="o">=</span> <span class="n">UANode</span><span class="p">(</span><span class="n">EdgeSet</span><span class="p">([</span><span class="n">dag</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="n">edge_weight_func</span><span class="p">(</span><span class="n">treeroot</span><span class="p">)]))</span>
    <span class="k">return</span> <span class="n">HistoryDag</span><span class="p">(</span><span class="n">dagroot</span><span class="p">)</span></div>


<div class="viewcode-block" id="history_dag_from_trees"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.history_dag_from_trees">[docs]</a><span class="k">def</span> <span class="nf">history_dag_from_trees</span><span class="p">(</span>
    <span class="n">treelist</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span>
    <span class="n">label_features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a :class:`historydag.HistoryDag` from a list of trees.</span>

<span class="sd">    Default arguments are suitable for loading lists of :class:`ete3.Tree`s, but</span>
<span class="sd">    any tree data structure can be used by providing appropriate functions to</span>
<span class="sd">    `child_node_func` and `leaf_node_func` keyword arguments.</span>

<span class="sd">    Args:</span>
<span class="sd">        treelist: List of root nodes of input trees.</span>
<span class="sd">        label_features: tree node attribute names to be used as HistoryDagNode label fields.</span>
<span class="sd">            Each attribute name must be accessible by ``getattr(treenode, name)``.</span>
<span class="sd">            Field names provided in `label_functions` keyword argument will take precedence.</span>
<span class="sd">        kwargs: Passed to :meth:`historydag.from_tree`. See docstring</span>
<span class="sd">            for that method for argument details</span>

<span class="sd">    Returns:</span>
<span class="sd">        :class:`historydag.HistoryDag` constructed from input trees.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">history_dag_from_histories</span><span class="p">(</span>
        <span class="p">[</span><span class="n">from_tree</span><span class="p">(</span><span class="n">treeroot</span><span class="p">,</span> <span class="n">label_features</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">treeroot</span> <span class="ow">in</span> <span class="n">treelist</span><span class="p">]</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="history_dag_from_etes"><a class="viewcode-back" href="../../stubs/historydag.history_dag_from_etes.html#historydag.history_dag_from_etes">[docs]</a><span class="k">def</span> <span class="nf">history_dag_from_etes</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Deprecated name for :meth:`historydag.history_dag_from_trees`&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">history_dag_from_trees</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="from_newick"><a class="viewcode-back" href="../../stubs/historydag.from_newick.html#historydag.from_newick">[docs]</a><span class="k">def</span> <span class="nf">from_newick</span><span class="p">(</span>
    <span class="n">tree</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">label_features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">label_functions</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">newick_format</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="n">attr_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Make a history DAG using a newick string. Internally, utilizes newick</span>
<span class="sd">    parsing features provided by ete3, then calls :meth:`from_tree` on the</span>
<span class="sd">    resulting ete3.Tree object.</span>

<span class="sd">    Args:</span>
<span class="sd">        tree: newick string representation of a tree. May contain extended node data</span>
<span class="sd">            in &#39;extended newick format&#39; used by ete3.</span>
<span class="sd">        label_features: (passed to :meth:`from_tree`) list of features to be used as label</span>
<span class="sd">            fields in resulting history DAG.  &#39;name&#39; refers to the node name string in the</span>
<span class="sd">            standard newick format. See ete3 docs for more details.</span>
<span class="sd">        newick_format: ete3 format number of passed newick string. See ete3 docs for details.</span>
<span class="sd">        label_functions: (passed to :meth:`from_tree`)</span>
<span class="sd">        attr_func: (passed to :meth:`from_tree`)</span>

<span class="sd">    Returns:</span>
<span class="sd">        HistoryDag object, which has the same topology as the input newick tree, with the</span>
<span class="sd">        required UA node added as a new root.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">etetree</span> <span class="o">=</span> <span class="n">ete3</span><span class="o">.</span><span class="n">Tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">newick_format</span><span class="p">)</span>
    <span class="c1"># from_tree checks that leaves are labeled uniquely. If this function is</span>
    <span class="c1"># ever rewritten to avoid ete newick parsing, we&#39;d need to do that here.</span>
    <span class="k">return</span> <span class="n">from_tree</span><span class="p">(</span>
        <span class="n">etetree</span><span class="p">,</span> <span class="n">label_features</span><span class="p">,</span> <span class="n">label_functions</span><span class="o">=</span><span class="n">label_functions</span><span class="p">,</span> <span class="n">attr_func</span><span class="o">=</span><span class="n">attr_func</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="history_dag_from_newicks"><a class="viewcode-back" href="../../stubs/historydag.history_dag_from_newicks.html#historydag.history_dag_from_newicks">[docs]</a><span class="k">def</span> <span class="nf">history_dag_from_newicks</span><span class="p">(</span>
    <span class="n">newicklist</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">label_features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">label_functions</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">attr_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">newick_format</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Build a history DAG from a list of newick strings.</span>

<span class="sd">    See :meth:`from_newick` for argument details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">history_dag_from_histories</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">from_newick</span><span class="p">(</span>
                <span class="n">tree</span><span class="p">,</span>
                <span class="n">label_features</span><span class="p">,</span>
                <span class="n">label_functions</span><span class="o">=</span><span class="n">label_functions</span><span class="p">,</span>
                <span class="n">attr_func</span><span class="o">=</span><span class="n">attr_func</span><span class="p">,</span>
                <span class="n">newick_format</span><span class="o">=</span><span class="n">newick_format</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">newicklist</span>
        <span class="p">]</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="history_dag_from_histories"><a class="viewcode-back" href="../../stubs/historydag.history_dag_from_histories.html#historydag.history_dag_from_histories">[docs]</a><span class="k">def</span> <span class="nf">history_dag_from_histories</span><span class="p">(</span><span class="n">treelist</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">HistoryDag</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Build a history DAG from a list of history DAGs which are histories.&quot;&quot;&quot;</span>
    <span class="n">dag</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">treelist</span><span class="p">))</span>
    <span class="n">dag</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">treelist</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dag</span></div>


<div class="viewcode-block" id="history_dag_from_clade_trees"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.history_dag_from_clade_trees">[docs]</a><span class="k">def</span> <span class="nf">history_dag_from_clade_trees</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Deprecated name for :meth:`history_dag_from_histories`&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">history_dag_from_histories</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="history_dag_from_nodes"><a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.history_dag_from_nodes">[docs]</a><span class="k">def</span> <span class="nf">history_dag_from_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Take an iterable containing HistoryDagNodes, and build a HistoryDag from</span>
<span class="sd">    those nodes.&quot;&quot;&quot;</span>
    <span class="c1"># use dictionary to preserve order</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">():</span> <span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span>
    <span class="c1"># check for UA node in passed set, and recover if present:</span>
    <span class="n">ua_node</span> <span class="o">=</span> <span class="n">UANode</span><span class="p">(</span><span class="n">EdgeSet</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">ua_node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">ua_node</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">ua_node</span><span class="p">]</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">()</span>
    <span class="n">nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ua_node</span><span class="p">)</span>
    <span class="n">clade_dict</span> <span class="o">=</span> <span class="n">_clade_union_dict</span><span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">edge_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">node</span><span class="p">:</span> <span class="p">[</span><span class="n">child</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">clade_dict</span><span class="p">[</span><span class="n">clade</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span>
    <span class="p">}</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="s2">&quot;&quot;</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">children</span> <span class="ow">in</span> <span class="n">edge_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">children</span><span class="p">}</span>
    <span class="n">source_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">children</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">edge_dict</span><span class="p">[</span><span class="n">ua_node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">children</span> <span class="ow">in</span> <span class="n">edge_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">HistoryDag</span><span class="p">(</span><span class="n">ua_node</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Will Dumm.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>