<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>historydag.dag &mdash; historydag  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> historydag
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html#modules">Modules</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">historydag</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>historydag.dag</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for historydag.dag</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;A module providing the class HistoryDag, and supporting functions.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">graphviz</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">ete3</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Generator</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">NamedTuple</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">FrozenSet</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="kn">from</span> <span class="nn">historydag</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">historydag.utils</span> <span class="kn">import</span> <span class="n">UALabel</span><span class="p">,</span> <span class="n">Weight</span><span class="p">,</span> <span class="n">Label</span><span class="p">,</span> <span class="n">NTLabel</span><span class="p">,</span> <span class="n">prod</span>
<span class="kn">from</span> <span class="nn">historydag.counterops</span> <span class="kn">import</span> <span class="n">counter_sum</span><span class="p">,</span> <span class="n">counter_prod</span>


<span class="k">class</span> <span class="nc">HistoryDagNode</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A recursive representation of a history DAG object</span>
<span class="sd">    - a dictionary keyed by clades (frozensets) containing EdgeSet objects</span>
<span class="sd">    - a label, which is a namedtuple.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Label</span><span class="p">,</span> <span class="n">clades</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">UALabel</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clades</span> <span class="o">=</span> <span class="n">clades</span>
        <span class="c1"># If passed a nonempty dictionary, need to add self to children&#39;s parents</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="n">attr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dp_data</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">edgeset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">edgeset</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_root</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Internal nodes (those which are not the DAG UA root node) &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;may not have exactly one child clade; Unifurcations cannot be expressed &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;in the history DAG. A HistoryDagNode with </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2"> and clades </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">clades</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2"> is not allowed.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitions</span><span class="p">()))</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">HistoryDagNode</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitions</span><span class="p">())</span> <span class="o">==</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">partitions</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">node_self</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a HistoryDagNode object with the same clades and label, but</span>
<span class="sd">        no descendant edges.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">HistoryDagNode</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="p">{</span><span class="n">clade</span><span class="p">:</span> <span class="n">EdgeSet</span><span class="p">()</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">},</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">under_clade</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="n">NTLabel</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the union of this node&#39;s child clades&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">UALabel</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">frozenset</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">frozenset</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether this is a leaf node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_root</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether this is a DAG root node, or UA (universal ancestor)</span>
<span class="sd">        node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">UALabel</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">partitions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">frozenset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the node&#39;s child clades.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">clade</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Label</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns generator object containing child nodes.</span>

<span class="sd">        Args:</span>
<span class="sd">            clade: If clade is provided, returns generator object of edge targets from that</span>
<span class="sd">        clade. If no clade is provided, generator includes all children of self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">clade</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">target</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span> <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">child</span> <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span>
        <span class="n">weight</span><span class="p">:</span> <span class="n">Weight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prob_norm</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Adds edge, if allowed and not already present. Returns whether edge was added.&quot;&quot;&quot;</span>
        <span class="c1"># target clades must union to a clade of self</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">under_clade</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;Target clades&#39; union is not a clade of this parent node: &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot; not in &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">add_to_edgeset</span><span class="p">(</span>
                <span class="n">target</span><span class="p">,</span>
                <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span>
                <span class="n">prob</span><span class="o">=</span><span class="n">prob</span><span class="p">,</span>
                <span class="n">prob_norm</span><span class="o">=</span><span class="n">prob_norm</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodedict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Recursively removes node self and any orphaned children from dag.</span>
<span class="sd">        May not work on root.</span>
<span class="sd">        Does not check to make sure that parent clade still has descendant edges.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">nodedict</span><span class="p">:</span>
            <span class="n">nodedict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                <span class="n">child</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">nodedict</span><span class="o">=</span><span class="n">nodedict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">under_clade</span><span class="p">()]</span><span class="o">.</span><span class="n">remove_from_edgeset_byid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">removed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Samples a clade tree (a sub-history DAG containing the root and all</span>
<span class="sd">        leaf nodes). Returns a new HistoryDagNode object.&quot;&quot;&quot;</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_self</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">sampled_target</span><span class="p">,</span> <span class="n">target_weight</span> <span class="o">=</span> <span class="n">eset</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>
            <span class="n">sample</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span><span class="o">.</span><span class="n">add_to_edgeset</span><span class="p">(</span>
                <span class="n">sampled_target</span><span class="o">.</span><span class="n">_sample</span><span class="p">(),</span>
                <span class="n">weight</span><span class="o">=</span><span class="n">target_weight</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">sample</span>

    <span class="k">def</span> <span class="nf">_get_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return a generator to iterate through all trees expressed by the DAG.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">genexp_func</span><span class="p">(</span><span class="n">clade</span><span class="p">):</span>
            <span class="c1"># Return generator expression of all possible choices of tree</span>
            <span class="c1"># structure from dag below clade</span>
            <span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
                <span class="n">eset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">clade</span><span class="p">,</span> <span class="n">targettree</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">targettree</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">_get_trees</span><span class="p">()</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">f</span>

        <span class="n">optionlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">genexp_func</span><span class="p">(</span><span class="n">clade</span><span class="p">)</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">]</span>

        <span class="c1"># TODO is this duplicated code?</span>
        <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">utils</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">optionlist</span><span class="p">):</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_self</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">targettree</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">option</span><span class="p">:</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span><span class="o">.</span><span class="n">add_to_edgeset</span><span class="p">(</span>
                    <span class="n">targettree</span><span class="p">,</span>
                    <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="k">yield</span> <span class="n">tree</span>

    <span class="k">def</span> <span class="nf">_newick_label</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;unnamed&quot;</span><span class="p">),</span>
        <span class="n">features</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">feature_funcs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return an extended newick format node label.</span>

<span class="sd">        Args:</span>
<span class="sd">            name_func: A function which maps nodes to names</span>
<span class="sd">            features: A list of label fields to be recorded in extended newick format</span>
<span class="sd">            feature_funcs: A dictionary keyed by extended newick field names containing</span>
<span class="sd">                functions which map nodes to field values. These override fields named</span>
<span class="sd">                in `features`, if a key in `feature_funcs` is also contained in `features`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A string which can be used as a node name in a newick string.</span>
<span class="sd">            For example, `namefuncresult[&amp;&amp;NHX:feature1=val1:feature2=val2]`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_root</span><span class="p">():</span>
            <span class="k">return</span> <span class="s2">&quot;UA_node&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">_fields</span>
            <span class="c1"># Use dict to avoid duplicate fields</span>
            <span class="n">nameval_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">val</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">features</span>
            <span class="p">}</span>
            <span class="n">nameval_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">feature_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
            <span class="n">featurestr</span> <span class="o">=</span> <span class="s2">&quot;:&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">nameval_dict</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">name_func</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[&amp;&amp;NHX:</span><span class="si">{</span><span class="n">featurestr</span><span class="si">}</span><span class="s2">]&quot;</span> <span class="k">if</span> <span class="n">featurestr</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="HistoryDag"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag">[docs]</a><span class="k">class</span> <span class="nc">HistoryDag</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;An object to represent a collection of internally labeled trees.</span>
<span class="sd">    A wrapper object to contain exposed HistoryDag methods and point to a HistoryDagNode root</span>

<span class="sd">    Args:</span>
<span class="sd">        dagroot: The root node of the history DAG</span>
<span class="sd">        attr: An attribute to contain data which will be preserved by copying (default and empty dict)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HistoryDag.__init__"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dagroot</span><span class="p">:</span> <span class="n">HistoryDagNode</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="p">{}):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="n">attr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span> <span class="o">=</span> <span class="n">dagroot</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Eventually this can be done by comparing bytestrings, but we need</span>
        <span class="c1"># some sorting to be done first, to ensure two dags that represent</span>
        <span class="c1"># identical trees return True. TODO</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converts HistoryDag to a bytestring-serializable dictionary.</span>

<span class="sd">        Since a HistoryDag is a recursive data structure, and contains label</span>
<span class="sd">        types defined in function scope, modifications must be made for pickling.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary containing:</span>
<span class="sd">            * label_fields: The names of label fields.</span>
<span class="sd">            * label_list: labels used in nodes, without duplicates. Indices are</span>
<span class="sd">                mapped to nodes in node_list</span>
<span class="sd">            * node_list: node tuples containing</span>
<span class="sd">                (node label index in label_list, frozenset of frozensets of leaf label indices, node.attr).</span>
<span class="sd">            * edge_list: a tuple for each edge:</span>
<span class="sd">                    (origin node index, target node index, edge weight, edge probability)&quot;&quot;&quot;</span>
        <span class="n">label_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">_fields</span>
        <span class="n">label_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">node_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edge_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">label_indices</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Label</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">node_indices</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">):</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())}</span>

        <span class="k">def</span> <span class="nf">cladesets</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">clades</span> <span class="o">=</span> <span class="p">{</span>
                <span class="nb">frozenset</span><span class="p">({</span><span class="n">label_indices</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">clade</span><span class="p">})</span>
                <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">clades</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">label_indices</span><span class="p">:</span>
                <span class="n">label_indices</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">label_list</span><span class="p">)</span>
                <span class="n">label_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">ignore_ualabel</span><span class="p">(</span><span class="kc">None</span><span class="p">)(</span><span class="nb">tuple</span><span class="p">)(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
                <span class="k">assert</span> <span class="n">label_list</span><span class="p">[</span>
                    <span class="n">label_indices</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">]</span>
                <span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">UALabel</span><span class="p">)</span>
            <span class="n">node_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">label_indices</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">],</span> <span class="n">cladesets</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">node</span><span class="o">.</span><span class="n">attr</span><span class="p">))</span>
            <span class="n">node_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">):</span>
                    <span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">node_idx</span><span class="p">,</span>
                            <span class="n">node_indices</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">target</span><span class="p">)],</span>
                            <span class="n">eset</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                            <span class="n">eset</span><span class="o">.</span><span class="n">probs</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
        <span class="n">serial_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;label_fields&quot;</span><span class="p">:</span> <span class="n">label_fields</span><span class="p">,</span>
            <span class="s2">&quot;label_list&quot;</span><span class="p">:</span> <span class="n">label_list</span><span class="p">,</span>
            <span class="s2">&quot;node_list&quot;</span><span class="p">:</span> <span class="n">node_list</span><span class="p">,</span>
            <span class="s2">&quot;edge_list&quot;</span><span class="p">:</span> <span class="n">edge_list</span><span class="p">,</span>
            <span class="s2">&quot;attr&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">serial_dict</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">serial_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rebuilds a HistoryDagNode using a serial_dict output by</span>
<span class="sd">        __getstate__&quot;&quot;&quot;</span>
        <span class="n">label_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]</span> <span class="o">=</span> <span class="n">serial_dict</span><span class="p">[</span><span class="s2">&quot;label_list&quot;</span><span class="p">]</span>
        <span class="n">node_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]</span> <span class="o">=</span> <span class="n">serial_dict</span><span class="p">[</span><span class="s2">&quot;node_list&quot;</span><span class="p">]</span>
        <span class="n">edge_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="n">serial_dict</span><span class="p">[</span><span class="s2">&quot;edge_list&quot;</span><span class="p">]</span>
        <span class="n">label_fields</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">serial_dict</span><span class="p">[</span><span class="s2">&quot;label_fields&quot;</span><span class="p">]</span>
        <span class="n">Label</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span><span class="s2">&quot;Label&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="n">label</span><span class="p">,</span> <span class="nb">any</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">label_fields</span><span class="p">])</span>  <span class="c1"># type: ignore</span>

        <span class="k">def</span> <span class="nf">unpack_labels</span><span class="p">(</span><span class="n">labelset</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">Label</span><span class="p">(</span><span class="o">*</span><span class="n">label_list</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">labelset</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="n">node_postorder</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">HistoryDagNode</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">utils</span><span class="o">.</span><span class="n">UALabel</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">label_list</span><span class="p">[</span><span class="n">labelidx</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="k">else</span> <span class="n">Label</span><span class="p">(</span><span class="o">*</span><span class="n">label_list</span><span class="p">[</span><span class="n">labelidx</span><span class="p">])</span>
                <span class="p">),</span>
                <span class="p">{</span><span class="n">unpack_labels</span><span class="p">(</span><span class="n">clade</span><span class="p">):</span> <span class="n">EdgeSet</span><span class="p">()</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">clades</span><span class="p">},</span>
                <span class="n">attr</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">labelidx</span><span class="p">,</span> <span class="n">clades</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">node_list</span>
        <span class="p">]</span>
        <span class="c1"># Last node in list is root</span>
        <span class="k">for</span> <span class="n">origin_idx</span><span class="p">,</span> <span class="n">target_idx</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="n">edge_list</span><span class="p">:</span>
            <span class="n">node_postorder</span><span class="p">[</span><span class="n">origin_idx</span><span class="p">]</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span>
                <span class="n">node_postorder</span><span class="p">[</span><span class="n">target_idx</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="n">prob</span><span class="p">,</span> <span class="n">prob_norm</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span> <span class="o">=</span> <span class="n">node_postorder</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="n">serial_dict</span><span class="p">[</span><span class="s2">&quot;attr&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">())</span>

<div class="viewcode-block" id="HistoryDag.get_trees"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.get_trees">[docs]</a>    <span class="k">def</span> <span class="nf">get_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return a generator containing all trees in the history DAG.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cladetree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">_get_trees</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">HistoryDag</span><span class="p">(</span><span class="n">cladetree</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.sample"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Samples a clade tree from the history DAG.</span>
<span class="sd">        (A clade tree is a sub-history DAG containing the root and all</span>
<span class="sd">        leaf nodes). Returns a new HistoryDagNode object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">HistoryDag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">_sample</span><span class="p">())</span></div>

<div class="viewcode-block" id="HistoryDag.is_clade_tree"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.is_clade_tree">[docs]</a>    <span class="k">def</span> <span class="nf">is_clade_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether history DAG is a clade tree.</span>

<span class="sd">        That is, each node-clade pair has exactly one descendant edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="HistoryDag.copy"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Uses bytestring serialization, and is guaranteed to copy:</span>

<span class="sd">        * node labels</span>
<span class="sd">        * node attr attributes</span>
<span class="sd">        * edge weights</span>
<span class="sd">        * edge probabilities</span>

<span class="sd">        However, other object attributes will not be copied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">serialize</span><span class="p">())</span></div>

<div class="viewcode-block" id="HistoryDag.merge"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Graph union this history DAG with another.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dagroot</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The given HistoryDag must be a root node on identical taxa.</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="si">}</span><span class="se">\n</span><span class="s2">vs</span><span class="se">\n</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">dagroot</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">selforder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()</span>
        <span class="n">otherorder</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">postorder</span><span class="p">()</span>
        <span class="c1"># hash and __eq__ are implemented for nodes, but we need to retrieve</span>
        <span class="c1"># the actual instance that&#39;s the same as a proposed node-to-add:</span>
        <span class="n">nodedict</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">selforder</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">otherorder</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodedict</span><span class="p">:</span>
                <span class="n">pnode</span> <span class="o">=</span> <span class="n">nodedict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pnode</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">node_self</span><span class="p">()</span>
                <span class="n">nodedict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pnode</span>

            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">edgeset</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">edgeset</span><span class="p">:</span>
                    <span class="n">pnode</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">nodedict</span><span class="p">[</span><span class="n">child</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.add_all_allowed_edges"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.add_all_allowed_edges">[docs]</a>    <span class="k">def</span> <span class="nf">add_all_allowed_edges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_from_root</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">adjacent_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">preserve_parent_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Add all allowed edges to the DAG.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_from_root: If False, no edges will be added that start at the DAG root.</span>
<span class="sd">                Useful when attempting to constrain root label.</span>
<span class="sd">            adjacent_labels: If False, no edges will be added between nodes with the same</span>
<span class="sd">                labels. Useful when attempting to maintain the history DAG in a &#39;collapsed&#39;</span>
<span class="sd">                state.</span>
<span class="sd">            preserve_parent_labels: If True, ensures that for any edge added between a</span>
<span class="sd">                parent and child node, the parent node label was already among the original</span>
<span class="sd">                parent labels of the child node. This ensures that parsimony score is preserved.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The number of edges added to the history DAG</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_added</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">clade_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="n">NTLabel</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">node</span><span class="o">.</span><span class="n">under_clade</span><span class="p">():</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">preserve_parent_labels</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
            <span class="n">uplabels</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">node</span><span class="p">:</span> <span class="p">{</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">}</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()</span>
            <span class="p">}</span>

        <span class="c1"># discard root node</span>
        <span class="n">gen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">()</span>
        <span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">:</span>
            <span class="n">clade_dict</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">under_clade</span><span class="p">()]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">new_from_root</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">is_root</span><span class="p">():</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">clade_dict</span><span class="p">[</span><span class="n">clade</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">adjacent_labels</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">elif</span> <span class="p">(</span>
                            <span class="n">preserve_parent_labels</span> <span class="ow">is</span> <span class="kc">True</span>
                            <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">uplabels</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
                        <span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">n_added</span> <span class="o">+=</span> <span class="n">node</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n_added</span></div>

<div class="viewcode-block" id="HistoryDag.to_newick"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.to_newick">[docs]</a>    <span class="nd">@utils</span><span class="o">.</span><span class="n">_cladetree_method</span>
    <span class="k">def</span> <span class="nf">to_newick</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;unnamed&quot;</span><span class="p">,</span>
        <span class="n">features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">feature_funcs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converts clade tree to extended newick format.</span>
<span class="sd">        Supports arbitrary node names and a</span>
<span class="sd">        sequence feature. For use on a history DAG which is a clade tree.</span>

<span class="sd">        For extracting newick representations of trees in a general history DAG, see</span>
<span class="sd">        :meth:`HistoryDag.to_newicks`.</span>

<span class="sd">        Args:</span>
<span class="sd">            name_func: A map from nodes to newick node names</span>
<span class="sd">            features: A list of label field names to be included in extended newick data.</span>
<span class="sd">                If `None`, all label fields will be included. To include none of them,</span>
<span class="sd">                pass an empty list.</span>
<span class="sd">            feature_funcs: A dictionary keyed by extended newick field names, containing</span>
<span class="sd">                functions specifying how to populate that field for each node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A newick string. If `features` is an empty list, and feature_funcs is empty,</span>
<span class="sd">                then this will be a standard newick string. Otherwise, it will have ete3&#39;s</span>
<span class="sd">                extended newick format.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">newick</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">_newick_label</span><span class="p">(</span>
                    <span class="n">name_func</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span> <span class="n">feature_funcs</span><span class="o">=</span><span class="n">feature_funcs</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">childnewicks</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">newick</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span> <span class="k">for</span> <span class="n">node2</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">()])</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="s2">&quot;(&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">childnewicks</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                    <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">_newick_label</span><span class="p">(</span>
                        <span class="n">name_func</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span> <span class="n">feature_funcs</span><span class="o">=</span><span class="n">feature_funcs</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">newick</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">()))</span> <span class="o">+</span> <span class="s2">&quot;;&quot;</span></div>

<div class="viewcode-block" id="HistoryDag.to_ete"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.to_ete">[docs]</a>    <span class="nd">@utils</span><span class="o">.</span><span class="n">_cladetree_method</span>
    <span class="k">def</span> <span class="nf">to_ete</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;unnamed&quot;</span><span class="p">,</span>
        <span class="n">features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">feature_funcs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert a history DAG which is a clade tree to an ete tree.</span>

<span class="sd">        Args:</span>
<span class="sd">            name_func: A map from nodes to newick node names</span>
<span class="sd">            features: A list of label field names to be included in extended newick data.</span>
<span class="sd">                If `None`, all label fields will be included. To include none of them,</span>
<span class="sd">                pass an empty list.</span>
<span class="sd">            feature_funcs: A dictionary keyed by extended newick field names, containing</span>
<span class="sd">                functions specifying how to populate that field for each node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An ete3 Tree with the same topology as self, and node names and attributes</span>
<span class="sd">            as specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First build a dictionary of ete3 nodes keyed by HDagNodes.</span>
        <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labelfeatures</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labelfeatures</span> <span class="o">=</span> <span class="n">features</span>

        <span class="k">def</span> <span class="nf">etenode</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">HistoryDagNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">:</span>
            <span class="n">newnode</span> <span class="o">=</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">()</span>
            <span class="n">newnode</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name_func</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">labelfeatures</span><span class="p">:</span>
                <span class="n">newnode</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">feature</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">feature</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">feature_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">newnode</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">newnode</span>

        <span class="n">nodedict</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">etenode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">skip_root</span><span class="o">=</span><span class="kc">True</span><span class="p">)}</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodedict</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                <span class="n">nodedict</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">child</span><span class="o">=</span><span class="n">nodedict</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>

        <span class="c1"># Since self is cladetree, dagroot can have only one child</span>
        <span class="k">return</span> <span class="n">nodedict</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span></div>

<div class="viewcode-block" id="HistoryDag.to_graphviz"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.to_graphviz">[docs]</a>    <span class="k">def</span> <span class="nf">to_graphviz</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labelfunc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">namedict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Label</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">show_partitions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gv</span><span class="o">.</span><span class="n">Digraph</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converts history DAG to graphviz (dot format) Digraph object.</span>

<span class="sd">        Args:</span>
<span class="sd">            labelfunc: A function to label nodes. If None, nodes will be labeled by</span>
<span class="sd">                their DAG node labels, or their label hash if label data is too large.</span>
<span class="sd">            namedict: A dictionary from node labels to label strings. Labelfunc will be</span>
<span class="sd">                used instead, if both are provided.</span>
<span class="sd">            show_partitions: Whether to include child clades in output.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">taxa</span><span class="p">(</span><span class="n">clade</span><span class="p">):</span>
            <span class="n">ls</span> <span class="o">=</span> <span class="p">[</span><span class="n">labeller</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span> <span class="k">for</span> <span class="n">taxon</span> <span class="ow">in</span> <span class="n">clade</span><span class="p">]</span>
            <span class="n">ls</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">return</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span>

        <span class="nd">@utils</span><span class="o">.</span><span class="n">ignore_ualabel</span><span class="p">(</span><span class="s2">&quot;UA_node&quot;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">labeller</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">namedict</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">namedict</span><span class="p">[</span><span class="n">label</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">label</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mi">11</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">labelfunc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">default_labelfunc</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">labeller</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

            <span class="n">labelfunc</span> <span class="o">=</span> <span class="n">default_labelfunc</span>

        <span class="n">G</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">Digraph</span><span class="p">(</span><span class="s2">&quot;labeled partition DAG&quot;</span><span class="p">,</span> <span class="n">node_attr</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="s2">&quot;record&quot;</span><span class="p">})</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span> <span class="ow">or</span> <span class="n">show_partitions</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)),</span> <span class="sa">f</span><span class="s2">&quot;&lt;label&gt; </span><span class="si">{</span><span class="n">labelfunc</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">splits</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="n">taxa</span><span class="p">(</span><span class="n">clade</span><span class="p">)</span><span class="si">}</span><span class="s2">&gt; </span><span class="si">{</span><span class="n">taxa</span><span class="p">(</span><span class="n">clade</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">{{</span><span class="s2"> &lt;label&gt; </span><span class="si">{</span><span class="n">labelfunc</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2"> |</span><span class="se">{{</span><span class="si">{</span><span class="n">splits</span><span class="si">}</span><span class="se">}}</span><span class="s2"> </span><span class="se">}}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="k">if</span> <span class="n">prob</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
                        <span class="n">label</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;p:</span><span class="si">{</span><span class="n">prob</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="n">weight</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">label</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;w:</span><span class="si">{</span><span class="n">weight</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">taxa</span><span class="p">(</span><span class="n">clade</span><span class="p">)</span> <span class="k">if</span> <span class="n">show_partitions</span> <span class="k">else</span> <span class="s1">&#39;label&#39;</span><span class="si">}</span><span class="s2">:s&quot;</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s2">:n&quot;</span><span class="p">,</span>
                        <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="HistoryDag.internal_avg_parents"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.internal_avg_parents">[docs]</a>    <span class="k">def</span> <span class="nf">internal_avg_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the average number of parents among internal nodes.</span>
<span class="sd">        A simple measure of similarity between the trees that the DAG expresses.</span>
<span class="sd">        However, keep in mind that two trees with the same topology but different labels</span>
<span class="sd">        would be considered entirely unalike by this measure.&quot;&quot;&quot;</span>
        <span class="n">nonleaf_parents</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">())</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cumsum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="nb">sum</span> <span class="ow">in</span> <span class="n">nonleaf_parents</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">cumsum</span> <span class="o">+=</span> <span class="nb">sum</span>
        <span class="c1"># Exclude root:</span>
        <span class="k">return</span> <span class="n">cumsum</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.make_uniform"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.make_uniform">[docs]</a>    <span class="k">def</span> <span class="nf">make_uniform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjust edge probabilities so that the DAG expresses a uniform</span>
<span class="sd">        distribution on expressed trees.</span>

<span class="sd">        The probability assigned to each edge below a clade is</span>
<span class="sd">        proportional to the number of subtrees possible below that edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_trees</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">):</span>
                    <span class="n">eset</span><span class="o">.</span><span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">_dp_data</span></div>

<div class="viewcode-block" id="HistoryDag.explode_nodes"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.explode_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">explode_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">expand_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Label</span><span class="p">]]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sequence_resolutions</span><span class="p">,</span>
        <span class="n">expandable_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Explode nodes according to a provided function.</span>
<span class="sd">        Adds copies of each node</span>
<span class="sd">        to the DAG with exploded labels, but with the same parents and children as the</span>
<span class="sd">        original node.</span>

<span class="sd">        Args:</span>
<span class="sd">            expand_func: A function that takes a node label, and returns an iterable</span>
<span class="sd">                containing &#39;exploded&#39; or &#39;disambiguated&#39; labels corresponding to the original.</span>
<span class="sd">                The wrapper :meth:`utils.explode_label` is provided to make such a function</span>
<span class="sd">                easy to write.</span>
<span class="sd">            expandable_func: A function that takes a node label, and returns whether the</span>
<span class="sd">                iterable returned by calling expand_func on that label would contain more</span>
<span class="sd">                than one item.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The number of new nodes added to the history DAG.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">expandable_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">is_ambiguous</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
                <span class="c1"># Check if expand_func(label) has at least two items, without</span>
                <span class="c1"># exhausting the (arbitrarily expensive) generator</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">expand_func</span><span class="p">(</span><span class="n">label</span><span class="p">))))</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_ambiguous</span> <span class="o">=</span> <span class="n">expandable_func</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
        <span class="n">nodedict</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()}</span>
        <span class="n">nodeorder</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())</span>
        <span class="n">new_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodeorder</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_root</span><span class="p">()</span> <span class="ow">and</span> <span class="n">is_ambiguous</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Passed expand_func would explode a leaf node. &quot;</span>
                        <span class="s2">&quot;Leaf nodes may not be exploded.&quot;</span>
                    <span class="p">)</span>
                <span class="k">for</span> <span class="n">resolution</span> <span class="ow">in</span> <span class="n">expand_func</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">):</span>
                    <span class="n">newnodetemp</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">node_self</span><span class="p">()</span>
                    <span class="n">newnodetemp</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">resolution</span>
                    <span class="k">if</span> <span class="n">newnodetemp</span> <span class="ow">in</span> <span class="n">nodedict</span><span class="p">:</span>
                        <span class="n">newnode</span> <span class="o">=</span> <span class="n">nodedict</span><span class="p">[</span><span class="n">newnodetemp</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">newnode</span> <span class="o">=</span> <span class="n">newnodetemp</span>
                        <span class="n">nodedict</span><span class="p">[</span><span class="n">newnode</span><span class="p">]</span> <span class="o">=</span> <span class="n">newnode</span>
                        <span class="n">new_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
                    <span class="c1"># Add all edges into and out of node to newnode</span>
                    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                        <span class="n">newnode</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                        <span class="n">parent</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
                <span class="c1"># Delete old node</span>
                <span class="n">node</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">nodedict</span><span class="o">=</span><span class="n">nodedict</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.summary"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print nicely formatted summary about the history DAG.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nodes:</span><span class="se">\t</span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trees:</span><span class="se">\t</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">count_trees</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_counts_with_ambiguities</span><span class="p">())</span></div>

    <span class="c1"># ######## Abstract dp method and derivatives: ########</span>

<div class="viewcode-block" id="HistoryDag.postorder_cladetree_accum"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.postorder_cladetree_accum">[docs]</a>    <span class="k">def</span> <span class="nf">postorder_cladetree_accum</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">leaf_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">],</span>
        <span class="n">edge_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">],</span>
        <span class="n">accum_within_clade</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">],</span>
        <span class="n">accum_between_clade</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">],</span>
        <span class="n">accum_above_edge</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Weight</span><span class="p">,</span> <span class="n">Weight</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Weight</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;A template method for leaf-to-root dynamic programming.</span>

<span class="sd">        Intermediate computations are stored in a `_dp_data` attribute on each node.</span>
<span class="sd">        Note that a `Weight` can be whatever you like, such as integers, Counters,</span>
<span class="sd">        strings, or dictionaries.</span>

<span class="sd">        Args:</span>
<span class="sd">            leaf_func: A function to assign weights to leaf nodes</span>
<span class="sd">            edge_func: A function to assign weights to edges. The parent node will</span>
<span class="sd">                always be the first argument.</span>
<span class="sd">            accum_within_clade: A function which accumulates a list of weights of subtrees</span>
<span class="sd">                below a single clade. That is, the weights are for alternative trees.</span>
<span class="sd">            accum_between_clade: A function which accumulates a list of weights of subtrees</span>
<span class="sd">                below different clades. That is, the weights are for different parts of the</span>
<span class="sd">                same tree.</span>
<span class="sd">            accum_above_edge: A function which adds the weight for a subtree to the weight</span>
<span class="sd">                of the edge above it. If `None`, this function will be inferred from</span>
<span class="sd">                `accum_between_clade`. The edge weight is the second argument.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The resulting weight computed for the History DAG UA (root) node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">accum_above_edge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">default_accum_above_edge</span><span class="p">(</span><span class="n">subtree_weight</span><span class="p">,</span> <span class="n">edge_weight</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">accum_between_clade</span><span class="p">([</span><span class="n">subtree_weight</span><span class="p">,</span> <span class="n">edge_weight</span><span class="p">])</span>

            <span class="n">accum_above_edge</span> <span class="o">=</span> <span class="n">default_accum_above_edge</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">node</span><span class="o">.</span><span class="n">_dp_data</span> <span class="o">=</span> <span class="n">leaf_func</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">_dp_data</span> <span class="o">=</span> <span class="n">accum_between_clade</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">accum_within_clade</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="n">accum_above_edge</span><span class="p">(</span>
                                    <span class="n">target</span><span class="o">.</span><span class="n">_dp_data</span><span class="p">,</span>
                                    <span class="n">edge_func</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">target</span><span class="p">),</span>
                                <span class="p">)</span>
                                <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">clade</span><span class="o">=</span><span class="n">clade</span><span class="p">)</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span>
                    <span class="p">]</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">_dp_data</span></div>

<div class="viewcode-block" id="HistoryDag.optimal_weight_annotate"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.optimal_weight_annotate">[docs]</a>    <span class="k">def</span> <span class="nf">optimal_weight_annotate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
            <span class="p">[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span>
        <span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">:</span> <span class="n">utils</span><span class="o">.</span><span class="n">wrapped_hamming_distance</span><span class="p">(</span><span class="n">n1</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">n2</span><span class="o">.</span><span class="n">label</span><span class="p">),</span>
        <span class="n">accum_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">,</span>
        <span class="n">optimal_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A template method for finding the optimal tree weight in the DAG.</span>
<span class="sd">        Dynamically annotates each node in the DAG with the optimal weight of a clade</span>
<span class="sd">        sub-tree beneath it, so that the DAG root node is annotated with the optimal</span>
<span class="sd">        weight of a clade tree in the DAG.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_func: A function which assigns starting weights to leaves.</span>
<span class="sd">            edge_weight_func: A function which assigns weights to DAG edges based on the</span>
<span class="sd">                parent node and the child node, in that order.</span>
<span class="sd">            accum_func: A function which takes a list of weights of different parts of a</span>
<span class="sd">                tree, and returns a weight, like sum.</span>
<span class="sd">            optimal_func: A function which takes a list of weights and returns the optimal</span>
<span class="sd">                one, like min.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The optimal weight of a tree under the DAG UA node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_cladetree_accum</span><span class="p">(</span>
            <span class="n">start_func</span><span class="p">,</span>
            <span class="n">edge_weight_func</span><span class="p">,</span>
            <span class="n">optimal_func</span><span class="p">,</span>
            <span class="n">accum_func</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.weight_count"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.weight_count">[docs]</a>    <span class="k">def</span> <span class="nf">weight_count</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
            <span class="p">[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span>
        <span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">:</span> <span class="n">utils</span><span class="o">.</span><span class="n">wrapped_hamming_distance</span><span class="p">(</span><span class="n">n1</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">n2</span><span class="o">.</span><span class="n">label</span><span class="p">),</span>
        <span class="n">accum_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A template method for counting weights of trees expressed in the history DAG.</span>

<span class="sd">        Weights must be hashable, but may otherwise be of arbitrary type.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_func: A function which assigns a weight to each leaf node</span>
<span class="sd">            edge_func: A function which assigns a weight to pairs of labels, with the</span>
<span class="sd">                parent node label the first argument</span>
<span class="sd">            accum_func: A way to &#39;add&#39; a list of weights together</span>

<span class="sd">        Returns:</span>
<span class="sd">            A Counter keyed by weights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_cladetree_accum</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">Counter</span><span class="p">([</span><span class="n">start_func</span><span class="p">(</span><span class="n">n</span><span class="p">)]),</span>
            <span class="k">lambda</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">:</span> <span class="n">Counter</span><span class="p">([</span><span class="n">edge_weight_func</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)]),</span>
            <span class="n">counter_sum</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">counter_prod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">accum_func</span><span class="p">),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.hamming_parsimony_count"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.hamming_parsimony_count">[docs]</a>    <span class="k">def</span> <span class="nf">hamming_parsimony_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Count the hamming parsimony scores of all trees in the history DAG.</span>

<span class="sd">        Returns a Counter with integer keys.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_count</span><span class="p">(</span><span class="o">**</span><span class="n">utils</span><span class="o">.</span><span class="n">hamming_distance_countfuncs</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.to_newicks"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.to_newicks">[docs]</a>    <span class="k">def</span> <span class="nf">to_newicks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of extended newick strings formed with label fields.</span>

<span class="sd">        For arguments, see :meth:`utils.make_newickcountfuncs`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newicks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_count</span><span class="p">(</span><span class="o">**</span><span class="n">utils</span><span class="o">.</span><span class="n">make_newickcountfuncs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span><span class="o">.</span><span class="n">elements</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">newick</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;;&quot;</span> <span class="k">for</span> <span class="n">newick</span> <span class="ow">in</span> <span class="n">newicks</span><span class="p">]</span></div>

<div class="viewcode-block" id="HistoryDag.count_topologies"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.count_topologies">[docs]</a>    <span class="k">def</span> <span class="nf">count_topologies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collapse_leaves</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Counts the number of unique topologies in the history DAG. This is</span>
<span class="sd">        achieved by counting the number of unique newick strings with only</span>
<span class="sd">        leaves labeled.</span>

<span class="sd">        :meth:`count_trees` gives the total number of unique trees in the DAG, taking</span>
<span class="sd">        into account internal node labels.</span>

<span class="sd">        Args:</span>
<span class="sd">            collapse_leaves: By default, topologies are counted as-is in the DAG. However,</span>
<span class="sd">                even if the DAG is collapsed by label, edges above leaf nodes will not be collapsed.</span>
<span class="sd">                if `collapse_leaves` is True, then the number of unique topologies with all</span>
<span class="sd">                leaf-adjacent edges collapsed will be counted. Assumes that the DAG is collapsed</span>
<span class="sd">                with :meth:`HistoryDag.convert_to_collapsed`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The number of topologies in the history DAG</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">make_newickcountfuncs</span><span class="p">(</span>
            <span class="n">internal_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">collapse_leaves</span><span class="o">=</span><span class="n">collapse_leaves</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_count</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>

<div class="viewcode-block" id="HistoryDag.count_trees"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.count_trees">[docs]</a>    <span class="k">def</span> <span class="nf">count_trees</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">expand_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Label</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">expand_count_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Annotates each node in the DAG with the number of clade sub-trees underneath.</span>

<span class="sd">        Args:</span>
<span class="sd">            expand_func: A function which takes a label and returns a list of labels, for</span>
<span class="sd">                example disambiguations of an ambiguous sequence. If provided, this method</span>
<span class="sd">                will count at least the number of clade trees that would be in the DAG,</span>
<span class="sd">                if :meth:`explode_nodes` were called with the same `expand_func`.</span>
<span class="sd">            expand_count_func: A function which takes a label and returns an integer value</span>
<span class="sd">                corresponding to the number of &#39;disambiguations&#39; of that label. If provided,</span>
<span class="sd">                `expand_func` will be used to find this value.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The total number of unique complete trees below the root node. If `expand_func`</span>
<span class="sd">            or `expand_count_func` is provided, the complete trees being counted are not</span>
<span class="sd">            guaranteed to be unique.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">expand_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">expand_count_func</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">expand_func</span><span class="p">(</span><span class="n">label</span><span class="p">)))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_cladetree_accum</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">:</span> <span class="n">expand_count_func</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="p">),</span>
            <span class="nb">sum</span><span class="p">,</span>
            <span class="n">prod</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.weight_counts_with_ambiguities"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.weight_counts_with_ambiguities">[docs]</a>    <span class="k">def</span> <span class="nf">weight_counts_with_ambiguities</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">edge_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">,</span> <span class="n">Label</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">wrapped_hamming_distance</span><span class="p">,</span>
        <span class="n">accum_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">,</span>
        <span class="n">expand_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Label</span><span class="p">]]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sequence_resolutions</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Template method for counting tree weights in the DAG, with exploded labels.</span>
<span class="sd">        Like :meth:`weight_counts`, but creates dictionaries of Counter objects at each</span>
<span class="sd">        node, keyed by possible sequences at that node. Analogous to :meth:`count_trees`</span>
<span class="sd">        with `expand_func` provided.</span>

<span class="sd">        Weights must be hashable.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_func: A function which assigns a weight to each leaf node</span>
<span class="sd">            edge_func: A function which assigns a weight to pairs of labels, with the</span>
<span class="sd">                parent node label the first argument</span>
<span class="sd">            accum_func: A way to &#39;add&#39; a list of weights together</span>
<span class="sd">            expand_func: A function which takes a label and returns a list of labels, such</span>
<span class="sd">                as disambiguations of an ambiguous sequence.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A Counter keyed by weights.</span>
<span class="sd">            The total number of trees will be greater than count_trees(), as these are</span>
<span class="sd">            possible disambiguations of trees. These disambiguations may not be unique,</span>
<span class="sd">            but if two are the same, they come from different subtrees of the DAG.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The old direct implementation not using postorder_cladetree_accum was</span>
        <span class="c1"># more straightforward, and may be significantly faster.</span>
        <span class="k">def</span> <span class="nf">leaf_func</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="n">label</span><span class="p">:</span> <span class="n">Counter</span><span class="p">({</span><span class="n">start_func</span><span class="p">(</span><span class="n">node</span><span class="p">):</span> <span class="mi">1</span><span class="p">})</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">expand_func</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
            <span class="p">}</span>

        <span class="k">def</span> <span class="nf">edge_weight_func</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
            <span class="c1"># This will handle &#39;adding&#39; child node counts to the edge, so we</span>
            <span class="c1"># have accum_above_edge just return this result.</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="n">label</span><span class="p">:</span> <span class="n">counter_sum</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">counter_prod</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">target_wc</span><span class="p">,</span> <span class="n">Counter</span><span class="p">({</span><span class="n">edge_func</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">childlabel</span><span class="p">):</span> <span class="mi">1</span><span class="p">})],</span>
                            <span class="n">accum_func</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">childlabel</span><span class="p">,</span> <span class="n">target_wc</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">_dp_data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">childlabel</span><span class="p">,</span> <span class="n">target_wc</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">_dp_data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">expand_func</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
            <span class="p">}</span>

        <span class="k">def</span> <span class="nf">accum_within_clade</span><span class="p">(</span><span class="n">dictlist</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">dictlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">counter_sum</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dictlist</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">accum_between_clade</span><span class="p">(</span><span class="n">dictlist</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">dictlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="n">counter_prod</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dictlist</span><span class="p">],</span> <span class="n">accum_func</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span>
            <span class="p">}</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">postorder_cladetree_accum</span><span class="p">(</span>
                <span class="n">leaf_func</span><span class="p">,</span>
                <span class="n">edge_weight_func</span><span class="p">,</span>
                <span class="n">accum_within_clade</span><span class="p">,</span>
                <span class="n">accum_between_clade</span><span class="p">,</span>
                <span class="n">accum_above_edge</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="c1"># ######## End Abstract DP method derivatives ########</span>

<div class="viewcode-block" id="HistoryDag.trim_optimal_weight"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.trim_optimal_weight">[docs]</a>    <span class="k">def</span> <span class="nf">trim_optimal_weight</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
            <span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="n">HistoryDagNode</span><span class="p">],</span> <span class="n">Weight</span>
        <span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">:</span> <span class="n">utils</span><span class="o">.</span><span class="n">wrapped_hamming_distance</span><span class="p">(</span><span class="n">n1</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">n2</span><span class="o">.</span><span class="n">label</span><span class="p">),</span>
        <span class="n">accum_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">,</span>
        <span class="n">optimal_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">,</span>
        <span class="n">eq_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Weight</span><span class="p">,</span> <span class="n">Weight</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">:</span> <span class="n">w1</span> <span class="o">==</span> <span class="n">w2</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Trims the DAG to only express trees with optimal weight. This is</span>
<span class="sd">        guaranteed to be possible when edge_weight_func depends only on the</span>
<span class="sd">        labels of an edge&#39;s parent and child node.</span>

<span class="sd">        Requires that weights are of a type that supports reliable equality</span>
<span class="sd">        testing. In particular, floats are not recommended. Instead, consider</span>
<span class="sd">        defining weights to be a precursor type, and define `optimal_func` to</span>
<span class="sd">        choose the one whose corresponding float is maximized/minimized.</span>

<span class="sd">        If floats must be used, a Numpy type may help.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_func: A function which assigns starting weights to leaves.</span>
<span class="sd">            edge_weight_func: A function which assigns weights to DAG edges based on the</span>
<span class="sd">                parent node and the child node, in that order.</span>
<span class="sd">            accum_func: A function which takes a list of weights of different parts of a tree,</span>
<span class="sd">                and returns a weight, like sum.</span>
<span class="sd">            optimal_func: A function which takes a list of weights and returns the optimal</span>
<span class="sd">                one, like min.</span>
<span class="sd">            eq_func: A function which tests equality, taking a pair of weights and returning a bool.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimal_weight_annotate</span><span class="p">(</span>
            <span class="n">start_func</span><span class="o">=</span><span class="n">start_func</span><span class="p">,</span>
            <span class="n">edge_weight_func</span><span class="o">=</span><span class="n">edge_weight_func</span><span class="p">,</span>
            <span class="n">accum_func</span><span class="o">=</span><span class="n">accum_func</span><span class="p">,</span>
            <span class="n">optimal_func</span><span class="o">=</span><span class="n">optimal_func</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># It may not be okay to use preorder here. May need reverse postorder</span>
        <span class="c1"># instead?</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">weightlist</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="n">accum_func</span><span class="p">([</span><span class="n">target</span><span class="o">.</span><span class="n">_dp_data</span><span class="p">,</span> <span class="n">edge_weight_func</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">target</span><span class="p">)]),</span>
                        <span class="n">target</span><span class="p">,</span>
                        <span class="n">index</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="n">optimalweight</span> <span class="o">=</span> <span class="n">optimal_func</span><span class="p">([</span><span class="n">weight</span> <span class="k">for</span> <span class="n">weight</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">weightlist</span><span class="p">])</span>
                <span class="n">newtargets</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">newweights</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">weight</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">weightlist</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">eq_func</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">optimalweight</span><span class="p">):</span>
                        <span class="n">newtargets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                        <span class="n">newweights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                <span class="n">eset</span><span class="o">.</span><span class="n">targets</span> <span class="o">=</span> <span class="n">newtargets</span>
                <span class="n">eset</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">newweights</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
                <span class="n">eset</span><span class="o">.</span><span class="n">probs</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span></div>

<div class="viewcode-block" id="HistoryDag.get_topologies"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.get_topologies">[docs]</a>    <span class="k">def</span> <span class="nf">get_topologies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collapse_leaves</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return a list of pseudo-newick representations of topologies in the</span>
<span class="sd">        history DAG.</span>

<span class="sd">        The newicks returned are not well-formed, and are for use with</span>
<span class="sd">        :meth:`HistoryDag.trim_topology`. Otherwise, this method would be equivalent to</span>
<span class="sd">        :meth:`HistoryDag.to_newicks` with keyword arguments ``internal_labels=False`` and</span>
<span class="sd">        ``collapsed_leaves`` as desired.</span>

<span class="sd">        Args:</span>
<span class="sd">            collapse_leaves: Whether to collapse leaf-adjacent edges between nodes with</span>
<span class="sd">                matching labels</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of strings, each representing a topology present in the history DAG.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">make_newickcountfuncs</span><span class="p">(</span>
            <span class="n">internal_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">collapse_leaves</span><span class="o">=</span><span class="n">collapse_leaves</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_count</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

<div class="viewcode-block" id="HistoryDag.trim_topology"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.trim_topology">[docs]</a>    <span class="k">def</span> <span class="nf">trim_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topology</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">collapse_leaves</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Trims the history DAG to express only trees matching the provided</span>
<span class="sd">        topology.</span>

<span class="sd">        Args:</span>
<span class="sd">            topology: A string like one output by :meth:`HistoryDag.get_topologies`</span>
<span class="sd">            collapse_leaves: must match the same argument provided to :meth:`HistoryDag.get_topologies`</span>
<span class="sd">                when creating the string passed as ``topology``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">min_func</span><span class="p">(</span><span class="n">newicks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="c1"># Each newick in presented to min_func will be well-formed, since</span>
            <span class="c1"># it will consist of a subtree newick added to a parent edge&#39;s</span>
            <span class="c1"># newick.</span>
            <span class="k">for</span> <span class="n">newick</span> <span class="ow">in</span> <span class="n">newicks</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">newick</span> <span class="ow">in</span> <span class="n">topology</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">newick</span>
            <span class="k">if</span> <span class="n">newicks</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;(;)&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;min_func() arg is an empty sequence&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trim_optimal_weight</span><span class="p">(</span>
            <span class="o">**</span><span class="n">utils</span><span class="o">.</span><span class="n">make_newickcountfuncs</span><span class="p">(</span>
                <span class="n">internal_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">collapse_leaves</span><span class="o">=</span><span class="n">collapse_leaves</span>
            <span class="p">),</span>
            <span class="n">optimal_func</span><span class="o">=</span><span class="n">min_func</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.recompute_parents"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.recompute_parents">[docs]</a>    <span class="k">def</span> <span class="nf">recompute_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Repopulate ``HistoryDagNode.parent`` attributes.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="n">node</span><span class="o">.</span><span class="n">parents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.convert_to_collapsed"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.convert_to_collapsed">[docs]</a>    <span class="k">def</span> <span class="nf">convert_to_collapsed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Rebuilds the DAG so that no edge connects two nodes with the same label,</span>
<span class="sd">        unless one is a leaf node.</span>

<span class="sd">        The resulting DAG should express at least the collapsed clade trees present</span>
<span class="sd">        in the original.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())</span>
        <span class="n">nodedict</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span>
        <span class="n">edgequeue</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">parent</span><span class="p">,</span> <span class="n">target</span><span class="p">]</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">nodes</span> <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="k">while</span> <span class="n">edgequeue</span><span class="p">:</span>
            <span class="n">parent</span><span class="p">,</span> <span class="n">child</span> <span class="o">=</span> <span class="n">edgequeue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">clade</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">under_clade</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">parent</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">child</span><span class="o">.</span><span class="n">label</span>
                <span class="ow">and</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">nodedict</span>
                <span class="ow">and</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">nodedict</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">child</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="n">parent_clade_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
                <span class="n">new_parent_clades</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="nb">frozenset</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="p">{</span><span class="n">clade</span><span class="p">}</span>
                <span class="p">)</span> <span class="o">|</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">newparenttemp</span> <span class="o">=</span> <span class="n">empty_node</span><span class="p">(</span>
                    <span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">new_parent_clades</span><span class="p">,</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">newparenttemp</span> <span class="ow">in</span> <span class="n">nodedict</span><span class="p">:</span>
                    <span class="n">newparent</span> <span class="o">=</span> <span class="n">nodedict</span><span class="p">[</span><span class="n">newparenttemp</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newparent</span> <span class="o">=</span> <span class="n">newparenttemp</span>
                    <span class="n">nodedict</span><span class="p">[</span><span class="n">newparent</span><span class="p">]</span> <span class="o">=</span> <span class="n">newparent</span>
                <span class="c1"># Add parents of parent to newparent</span>
                <span class="k">for</span> <span class="n">grandparent</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="n">grandparent</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">newparent</span><span class="p">)</span>  <span class="c1"># check parents logic</span>
                    <span class="n">edgequeue</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">grandparent</span><span class="p">,</span> <span class="n">newparent</span><span class="p">])</span>
                <span class="c1"># Add children of other clades to newparent</span>
                <span class="k">for</span> <span class="n">otherclade</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">otherclade</span> <span class="o">!=</span> <span class="n">clade</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">othertarget</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">otherclade</span><span class="p">]</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
                            <span class="n">newparent</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">othertarget</span><span class="p">)</span>
                            <span class="n">edgequeue</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">newparent</span><span class="p">,</span> <span class="n">othertarget</span><span class="p">])</span>
                <span class="c1"># Add children of old child to newparent</span>
                <span class="k">for</span> <span class="n">grandchild</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                    <span class="n">newparent</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">grandchild</span><span class="p">)</span>
                    <span class="n">edgequeue</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">newparent</span><span class="p">,</span> <span class="n">grandchild</span><span class="p">])</span>
                <span class="c1"># Remove the edge we were fixing from old parent</span>
                <span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span><span class="o">.</span><span class="n">remove_from_edgeset_byid</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="c1"># Clean up the DAG:</span>
                <span class="c1"># Delete old parent if it is no longer a valid node</span>
                <span class="k">if</span> <span class="n">parent_clade_edges</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Remove old parent as child of all of its parents</span>
                    <span class="c1"># no need for recursion here, all of its parents had</span>
                    <span class="c1"># edges added to new parent from the same clade.</span>
                    <span class="n">upclade</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">under_clade</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">grandparent</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                        <span class="n">grandparent</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">upclade</span><span class="p">]</span><span class="o">.</span><span class="n">remove_from_edgeset_byid</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">child2</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                        <span class="n">child2</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">child2</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                            <span class="n">child2</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">nodedict</span><span class="o">=</span><span class="n">nodedict</span><span class="p">)</span>
                    <span class="n">nodedict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

                <span class="c1"># Remove child, if child no longer has parents</span>
                <span class="k">if</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="c1"># This recursively removes children of child too, if necessary</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">nodedict</span><span class="o">=</span><span class="n">nodedict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span></div>

    <span class="c1"># ######## DAG Traversal Methods ########</span>

<div class="viewcode-block" id="HistoryDag.postorder"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.postorder">[docs]</a>    <span class="k">def</span> <span class="nf">postorder</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">include_root</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Recursive postorder traversal of the history DAG.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Generator on nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">HistoryDagNode</span><span class="p">):</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">id</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="k">yield from</span> <span class="n">traverse</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">node</span>

        <span class="k">yield from</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="p">)</span></div>

<div class="viewcode-block" id="HistoryDag.preorder"><a class="viewcode-back" href="../../stubs/historydag.HistoryDag.html#historydag.HistoryDag.preorder">[docs]</a>    <span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skip_root</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Recursive postorder traversal of the history DAG.</span>

<span class="sd">        Careful! This is not guaranteed to visit a parent node before any of its children.</span>
<span class="sd">        for that, need reverse postorder traversal.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Generator on nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">HistoryDagNode</span><span class="p">):</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="k">yield</span> <span class="n">node</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">id</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="k">yield from</span> <span class="n">traverse</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

        <span class="n">gen</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">skip_root</span><span class="p">:</span>
            <span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="k">yield from</span> <span class="n">gen</span></div></div>


<span class="k">class</span> <span class="nc">EdgeSet</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A container class for edge target nodes, and associated probabilities and weights.</span>
<span class="sd">    Goal: associate targets (edges) with arbitrary parameters, but support</span>
<span class="sd">    set-like operations like lookup and enforce that elements are unique.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">probs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Takes no arguments, or an ordered iterable containing target nodes&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected at most one argument, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">targets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

            <span class="k">if</span> <span class="n">probs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">probs</span> <span class="o">=</span> <span class="n">probs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">probs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">targets</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">probs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_targetset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_targetset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_targetset</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;First argument may not contain duplicate target nodes&quot;</span><span class="p">)</span>
        <span class="c1"># Should probably also check to see that all passed lists have same length</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">shallowcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;EdgeSet&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return an identical EdgeSet object, which points to the same target</span>
<span class="sd">        nodes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">EdgeSet</span><span class="p">(</span>
            <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">],</span>
            <span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="n">probs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">probs</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_from_edgeset_byid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_node</span><span class="p">):</span>
        <span class="n">idlist</span> <span class="o">=</span> <span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">target_node</span><span class="p">)</span> <span class="ow">in</span> <span class="n">idlist</span><span class="p">:</span>
            <span class="n">idx_to_remove</span> <span class="o">=</span> <span class="n">idlist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">target_node</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx_to_remove</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">probs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx_to_remove</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx_to_remove</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_targetset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns a randomly sampled child edge, and its corresponding</span>
<span class="sd">        weight.&quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">))),</span> <span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">probs</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span>
            <span class="mi">0</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">add_to_edgeset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prob_norm</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add a target node to the EdgeSet.</span>

<span class="sd">        currently does nothing if edge is already present. Also does nothing</span>
<span class="sd">        if the target node has one child clade, and parent node is not the DAG root.</span>

<span class="sd">        Args:</span>
<span class="sd">            target: target node</span>
<span class="sd">            weight: edge weight</span>
<span class="sd">            prob: edge probability. If not provided, edge probability will be</span>
<span class="sd">                1 / n where n is the number of edges in the edgeset.</span>
<span class="sd">            prob_norm: if True, probability vector will be normalized.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Whether an edge was added</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">is_root</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Edges that target UA nodes are not allowed. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Target node has label </span><span class="si">{</span><span class="n">target</span><span class="o">.</span><span class="n">label</span><span class="si">}</span><span class="s2"> and therefore &quot;</span>
                <span class="s2">&quot;is assumed to be the DAG UA root node.&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_targetset</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_targetset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">prob</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">prob</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">prob_norm</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">probs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">prob</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">probs</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">probs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>


<span class="c1"># ######## DAG Creation Functions ########</span>


<span class="k">def</span> <span class="nf">empty_node</span><span class="p">(</span>
    <span class="n">label</span><span class="p">:</span> <span class="n">Label</span><span class="p">,</span> <span class="n">clades</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="n">Label</span><span class="p">]],</span> <span class="n">attr</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDagNode</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return a HistoryDagNode with the given label and clades, with no</span>
<span class="sd">    children.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">HistoryDagNode</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="p">{</span><span class="n">clade</span><span class="p">:</span> <span class="n">EdgeSet</span><span class="p">()</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">clades</span><span class="p">},</span> <span class="n">attr</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">from_tree</span><span class="p">(</span>
    <span class="n">tree</span><span class="p">:</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">,</span>
    <span class="n">label_features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">label_functions</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">attr_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Build a full tree from an ete3 TreeNode.</span>

<span class="sd">    Args:</span>
<span class="sd">        tree: ete3 tree to be converted to HistoryDag clade tree</span>
<span class="sd">        label_features: node attribute names to be used to distinguish nodes. Field names</span>
<span class="sd">            provided in `label_functions` will take precedence.</span>
<span class="sd">        label_functions: dictionary keyed by additional label field names, containing</span>
<span class="sd">            functions mapping tree nodes to intended label field value.</span>
<span class="sd">        attr_func: function to populate HistoryDag node `attr` attribute,</span>
<span class="sd">            which is not used to distinguish nodes, and may be overwritten</span>
<span class="sd">            by `attr` of another node with the same label and child clades.</span>

<span class="sd">    Returns:</span>
<span class="sd">        HistoryDag object, which has the same topology as the input tree, with the required</span>
<span class="sd">        UA node added as a new root.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># see https://stackoverflow.com/questions/50298582/why-does-python-asyncio-loop-call-soon-overwrite-data</span>
    <span class="c1"># or https://stackoverflow.com/questions/25670516/strange-overwriting-occurring-when-using-lambda-functions-as-dict-values</span>
    <span class="c1"># for why we can&#39;t just use lambda funcs defined in dict comprehension.</span>
    <span class="k">def</span> <span class="nf">getnamefunc</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">getter</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">getter</span>

    <span class="n">feature_maps</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">getnamefunc</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">label_features</span><span class="p">}</span>
    <span class="n">feature_maps</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">label_functions</span><span class="p">)</span>
    <span class="n">Label</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span><span class="s2">&quot;Label&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="n">label</span><span class="p">,</span> <span class="n">Any</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">feature_maps</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>  <span class="c1"># type: ignore</span>

    <span class="k">def</span> <span class="nf">node_label</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">):</span>
        <span class="c1"># This should not fail silently! Only DAG UA node is allowed to have</span>
        <span class="c1"># default (None) label values.</span>
        <span class="k">return</span> <span class="n">Label</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">feature_maps</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>

    <span class="k">def</span> <span class="nf">leaf_names</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">((</span><span class="n">node_label</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">_unrooted_from_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="n">HistoryDagNode</span><span class="p">(</span>
            <span class="n">node_label</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span>
            <span class="p">{</span>
                <span class="n">leaf_names</span><span class="p">(</span><span class="n">child</span><span class="p">):</span> <span class="n">EdgeSet</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">_unrooted_from_tree</span><span class="p">(</span><span class="n">child</span><span class="p">)],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">dist</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span>
            <span class="p">},</span>
            <span class="n">attr_func</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">dag</span>

    <span class="c1"># Check for unique leaf labels:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaf_names</span><span class="p">(</span><span class="n">tree</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;This tree&#39;s leaves are not labeled uniquely. Check your tree, &quot;</span>
            <span class="s2">&quot;or modify the label fields so that leaves are unique.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">leaf_names</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="c1"># Checking for unifurcation is handled in HistoryDagNode.__init__.</span>

    <span class="n">dag</span> <span class="o">=</span> <span class="n">_unrooted_from_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="n">dagroot</span> <span class="o">=</span> <span class="n">HistoryDagNode</span><span class="p">(</span>
        <span class="n">UALabel</span><span class="p">(),</span>
        <span class="p">{</span>
            <span class="nb">frozenset</span><span class="p">({</span><span class="n">taxon</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">clades</span> <span class="k">for</span> <span class="n">taxon</span> <span class="ow">in</span> <span class="n">s</span><span class="p">}):</span> <span class="n">EdgeSet</span><span class="p">(</span>
                <span class="p">[</span><span class="n">dag</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="n">tree</span><span class="o">.</span><span class="n">dist</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">},</span>
        <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">dagroot</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">dag</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">HistoryDag</span><span class="p">(</span><span class="n">dagroot</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">from_newick</span><span class="p">(</span>
    <span class="n">tree</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">label_features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">label_functions</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">newick_format</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="n">attr_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Make a history DAG using a newick string. Internally, utilizes newick</span>
<span class="sd">    parsing features provided by ete3, then calls :meth:`from_tree` on the</span>
<span class="sd">    resulting ete3.Tree object.</span>

<span class="sd">    Args:</span>
<span class="sd">        tree: newick string representation of a tree. May contain extended node data</span>
<span class="sd">            in &#39;extended newick format&#39; used by ete3.</span>
<span class="sd">        label_features: (passed to :meth:`from_tree`) list of features to be used as label</span>
<span class="sd">            fields in resulting history DAG.  &#39;name&#39; refers to the node name string in the</span>
<span class="sd">            standard newick format. See ete3 docs for more details.</span>
<span class="sd">        newick_format: ete3 format number of passed newick string. See ete3 docs for details.</span>
<span class="sd">        label_functions: (passed to :meth:`from_tree`)</span>
<span class="sd">        attr_func: (passed to :meth:`from_tree`)</span>

<span class="sd">    Returns:</span>
<span class="sd">        HistoryDag object, which has the same topology as the input newick tree, with the</span>
<span class="sd">        required UA node added as a new root.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">etetree</span> <span class="o">=</span> <span class="n">ete3</span><span class="o">.</span><span class="n">Tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">newick_format</span><span class="p">)</span>
    <span class="c1"># from_tree checks that leaves are labeled uniquely. If this function is</span>
    <span class="c1"># ever rewritten to avoid ete newick parsing, we&#39;d need to do that here.</span>
    <span class="k">return</span> <span class="n">from_tree</span><span class="p">(</span>
        <span class="n">etetree</span><span class="p">,</span> <span class="n">label_features</span><span class="p">,</span> <span class="n">label_functions</span><span class="o">=</span><span class="n">label_functions</span><span class="p">,</span> <span class="n">attr_func</span><span class="o">=</span><span class="n">attr_func</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">history_dag_from_newicks</span><span class="p">(</span>
    <span class="n">newicklist</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">label_features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">label_functions</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">attr_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">newick_format</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Build a history DAG from a list of newick strings.</span>

<span class="sd">    See :meth:`from_newick` for argument details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">history_dag_from_clade_trees</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">from_newick</span><span class="p">(</span>
                <span class="n">tree</span><span class="p">,</span>
                <span class="n">label_features</span><span class="p">,</span>
                <span class="n">label_functions</span><span class="o">=</span><span class="n">label_functions</span><span class="p">,</span>
                <span class="n">attr_func</span><span class="o">=</span><span class="n">attr_func</span><span class="p">,</span>
                <span class="n">newick_format</span><span class="o">=</span><span class="n">newick_format</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">newicklist</span>
        <span class="p">]</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">history_dag_from_etes</span><span class="p">(</span>
    <span class="n">treelist</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span>
    <span class="n">label_features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">label_functions</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">attr_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Build a history DAG from a list of ete3 Trees.</span>

<span class="sd">    See :meth:`from_tree` for argument details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">history_dag_from_clade_trees</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">from_tree</span><span class="p">(</span>
                <span class="n">tree</span><span class="p">,</span>
                <span class="n">label_features</span><span class="p">,</span>
                <span class="n">label_functions</span><span class="o">=</span><span class="n">label_functions</span><span class="p">,</span>
                <span class="n">attr_func</span><span class="o">=</span><span class="n">attr_func</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">treelist</span>
        <span class="p">]</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">history_dag_from_clade_trees</span><span class="p">(</span><span class="n">treelist</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">HistoryDag</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Build a history DAG from a list of history DAGs which are clade</span>
<span class="sd">    trees.&quot;&quot;&quot;</span>
    <span class="c1"># merge checks that all clade trees have the same leaf label set.</span>
    <span class="c1"># Is copying the first enough to avoid mutating treelist?</span>
    <span class="n">dag</span> <span class="o">=</span> <span class="n">treelist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">treelist</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">dag</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dag</span>


<span class="c1"># ######## Miscellaneous Functions ########</span>


<span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">bstring</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;reloads a HistoryDag serialized object, as ouput by</span>
<span class="sd">    HistoryDagNode.serialize.&quot;&quot;&quot;</span>
    <span class="n">serial_dict</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">bstring</span><span class="p">)</span>
    <span class="n">dag</span> <span class="o">=</span> <span class="n">HistoryDag</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="n">dag</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">serial_dict</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dag</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Will Dumm.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>