# -*- coding: utf-8 -*-
"""gctreePartitions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Spf6T4W3xAhvO0EYcgWmJ5qS1mwwJvVP
"""

# Commented out IPython magic to ensure Python compatibility.
!pip install ete3 PyQt5
!git clone https://github.com/matsengrp/gctree.git
# %cd gctree
!git checkout 56-disambiguate-optimally
!pip install -e .

import ete3
import string
import os
import graphviz as gv
import pickle
import pprint
import random
from gctree import phylip_parse as pps
from gctree.utils import hamming_distance
os.environ['QT_QPA_PLATFORM'] = "offscreen"

# # a dictionary mapping each node to its set of descendant leaves, generated by tip-to-root accumulation
# node2leaves = tree.get_cached_content()
# dag = nx.DiGraph
# # traverse the nodes and use the dictionary to generate partitions
# for node in tree.traverse():
#     if node.children:
#       partition = frozenset({frozenset(leaf.name for leaf in node2leaves[child]) for child in node.children})
#       print(partition)

def maxpaths(tree: ete3.TreeNode):
  paths = []
  def pathsUnder(node: ete3.TreeNode, prepath: list):
    prepath.append(node)
    if node.is_leaf():
      paths.append(prepath)
    else:
      for child in node.children:
        pathsUnder(child, prepath.copy())
  pathsUnder(tree, [])
  return(paths)

class SdagNode:
  """ A recursive representation of an sDAG
  - a dictionary keyed by clades (frozensets) containing EdgeSet objects
  - a label
  """

  def __init__(self, label, clades: dict = {}):
    self.clades = clades
    # If passed a nonempty dictionary, need to add self to children's parents
    self.label = label
    self.parents = set()
    if self.clades:
      for child in self.children():
        child.parents.add(self)
  
  def __repr__(self):
    return(str((self.label, set(self.clades.keys()))))
  
  def __hash__(self):
    return(hash((self.label, frozenset(self.clades.keys()))))

  def __eq__(self, other):
    return(self.__hash__() == other.__hash__())
  
  def node_self(self):
    return(SdagNode(self.label, {clade: EdgeSet() for clade in self.clades}))
  
  def merge(self, node):
    """ performs post order traversal to add node and all of its children,
    without introducing duplicate nodes in self. Requires given node is a root"""
    if not hash(self) == hash(node):
      raise ValueError(f"The given node must be a root node on identical taxa.\n{self}\nvs\n{node}")
    selforder = postorder(self)
    nodeorder = postorder(node)
    hashdict = {hash(n): n for n in selforder}
    for n in nodeorder:
      if hash(n) in hashdict:
        pnode = hashdict[hash(n)]
      else:
        pnode = n.node_self()
        hashdict[hash(n)] = pnode
  
      for _, edgeset in n.clades.items():
        for child, weight, _ in edgeset:
          pnode.add_edge(hashdict[hash(child)], weight=weight)


  def add_edge(self, target, weight=0):
    # target clades must union to a clade of self
    if target.is_leaf():
        key = frozenset([target.label])
    else:
        key = frozenset().union(*target.clades.keys())
    if not key in self.clades:
      raise KeyError("Target clades' union is not a clade of this parent node")
    else:
      self.clades[key].add(target, weight=weight)
      target.parents.add(self)
    
  def is_leaf(self):
    return(not bool(self.clades))
  
  def partitions(self):
    return(self.clades.keys())
  
  def children(self, clade=None):
    """ If clade is provided, returns generator object of edge targets from that
    clade. If no clade is provided, generator includes all children of self.
    """
    if clade is None:
      return((target for clade in self.clades for target, _, _ in self.clades[clade]))
    else:
      return (child for child, _, _ in self.clades[clade])

  def to_graphviz(self, namedict):
    """ Converts to graphviz Digraph object. Namedict must associate sequences
    of all leaf nodes to a name
    """
    def taxa(clade):
      l = [str(namedict[taxon]) for taxon in clade]
      l.sort()
      return(','.join(l))
    
    G = gv.Digraph('labeled partition DAG', node_attr={'shape':'record'})
    for node in postorder(self):
      if node.is_leaf():
        G.node(str(id(node)), f'<label> {namedict[node.label]}')
      else:
        splits = '|'.join([f'<{taxa(clade)}> {taxa(clade)}' for clade in node.clades])
        G.node(str(id(node)), f'{{ <label> {hash(node.label)} |{{{splits}}} }}')
        for clade in node.clades:
          for target, weight, prob in node.clades[clade]:
            label = ''
            if prob < 1.0:
              label += f'p:{prob:.2f}'
            if weight > 0.0:
              label += f'w:{weight}'
            G.edge(f'{id(node)}:{taxa(clade)}', f'{id(target)}:label',
                   label=label)
    return(G)
  
  def weight(self):
    "Sums weights of all edges in the DAG"
    nodes = postorder(self)
    edgesetsums = (sum(edgeset.weights) for node in nodes
                   for edgeset in node.clades.values())
    return(sum(edgesetsums))

  def internal_avg_parents(self):
    """Returns the average number of parents among internal nodes
    A simple measure of similarity of trees that the DAG expresses. """
    nonleaf_parents = (len(n.parents) for n in postorder(self)
                       if not n.is_leaf())
    n = 0
    cumsum = 0
    for sum in nonleaf_parents:
      n += 1
      cumsum += sum
    # Exclude root:
    return(cumsum / float(n - 1))

  def sample(self):
    """ Samples a sub-history-DAG that is also a tree containing the root and
    all leaf nodes. Returns a new SdagNode object"""
    sample = self.node_self()
    for clade, eset in self.clades.items():
      sampled_target, target_weight = eset.sample()
      sample.clades[clade].add(sampled_target.sample(), weight=target_weight)
    return(sample)

    

class EdgeSet:
  """ Goal: associate targets (edges) with arbitrary parameters, but support
  set-like operations like lookup and enforce that elements are unique."""
  def __init__(self, *args, weights: list=None, probs: list=None):
    """ Takes no arguments, or an ordered iterable containing target nodes """
    if len(args) > 1:
      raise TypeError(f"Expected at most one argument, got {len(args)}")
    elif args:
      self.targets = list(args[0])
      n = len(self.targets)
      if weights is not None:
        self.weights = weights
      else:
        self.weights = [0]*n
      
      if probs is not None:
        self.probs = probs
      else:
        self.probs = [float(1)/n]*n
    else:
      self.targets = []
      self.weights = []
      self.probs = []
      self._hashes = set()

    self._hashes = {hash(self.targets[i]): i for i in range(len(self.targets))}
    if not len(self._hashes) == len(self.targets):
      raise TypeError("First argument may not contain duplicate target nodes")
    # Should probably also check to see that all passed lists have same length
  
  def __iter__(self):
    return ((self.targets[i], self.weights[i] , self.probs[i]) for i in range(len(self.targets)))

  def sample(self):
    choice = random.choices(self.targets, weights=self.probs, k=1)
    return(choice[0], self.weights[self._hashes[hash(choice[0])]])
  
  def add(self, target, weight=0, prob=None):
    """ currently does nothing if edge is already present """
    if not hash(target) in self._hashes:
      self._hashes[hash(target)] = len(self.targets)
      self.targets.append(target)
      self.weights.append(weight)

      if prob is None:
        prob = float(1)/len(self.targets)
      self.probs = list(map(lambda x: x * (1 - prob) / sum(self.probs), self.probs))
      self.probs.append(prob)
    else:
      index = self._hashes[hash(target)]
      # self.weight[index] = weight # Could do something here!!



def from_tree(tree: ete3.TreeNode):
  def leaf_names(r: ete3.TreeNode):
      return(frozenset((node.sequence for node in r.get_leaves())))
  def _unrooted_from_tree(tree):
    dag = SdagNode(tree.sequence,
                   {leaf_names(child): EdgeSet([_unrooted_from_tree(child)],
                                               weights=[child.dist])
                   for child in tree.get_children()})
    return(dag)
  dag = _unrooted_from_tree(tree)
  dagroot = SdagNode('root',
                     {frozenset({taxon for s in dag.clades for taxon in s}): EdgeSet([dag], weights=[tree.dist])})
  dagroot.add_edge(dag, weight=0)
  return(dagroot)


def from_newick(tree: string):
  etetree = ete3.Tree(tree, format=8)
  return(from_tree(etetree))


def postorder(dag: SdagNode):
  visited = set()
  def traverse(node: SdagNode):
    visited.add(id(node))
    if not node.is_leaf():
      for child in node.children():
        if not id(child) in visited:
          yield from traverse(child)
    yield node
  yield from traverse(dag)


def sdag_from_newicks(newicklist):
  treelist = list(map(lambda x: ete3.Tree(x, format=8), newicklist))
  for tree in treelist:
    for node in tree.traverse():
      node.sequence = node.name
  return(sdag_from_etes(treelist))


def sdag_from_etes(treelist):
  dag = from_tree(treelist[0])
  for tree in treelist[1:]:
    dag.merge(from_tree(tree))
  return(dag)


s = SdagNode('a', clades={frozenset({'a', 'b'}): set(), frozenset({'c', 'd'}): set()})
print(s.clades[frozenset({'a', 'b'})])

""" SdagNode tests:"""

newickstring1 = ("(((4[&&NHX:name=4:sequence=C],(6[&&NHX:name=6:sequence=C],"
                "7[&&NHX:name=7:sequence=A])5[&&NHX:name=5:sequence=M])3[&&NHX:name=3:sequence=M],"
                "8[&&NHX:name=8:sequence=A],(11[&&NHX:name=11:sequence=A],"
                "10[&&NHX:name=10:sequence=G])9[&&NHX:name=9:sequence=R])"
                "2[&&NHX:name=2:sequence=R])1[&&NHX:name=1:sequence=G];")

newickstring2 = ("(((4[&&NHX:name=4:sequence=K],(6[&&NHX:name=6:sequence=J],"
                "7[&&NHX:name=7:sequence=I])5[&&NHX:name=5:sequence=H])3[&&NHX:name=3:sequence=G],"
                "8[&&NHX:name=8:sequence=F],(11[&&NHX:name=11:sequence=E],"
                "10[&&NHX:name=10:sequence=D])9[&&NHX:name=9:sequence=C])"
                "2[&&NHX:name=2:sequence=B])1[&&NHX:name=1:sequence=A];")

newickstring3 = ("(((4[&&NHX:name=4:sequence=K],(6[&&NHX:name=6:sequence=J],"
                "7[&&NHX:name=7:sequence=I])5[&&NHX:name=5:sequence=H])2[&&NHX:name=2:sequence=B],"
                "8[&&NHX:name=8:sequence=F],(11[&&NHX:name=11:sequence=E],"
                "10[&&NHX:name=10:sequence=D])9[&&NHX:name=9:sequence=C])"
                "3[&&NHX:name=3:sequence=G])1[&&NHX:name=1:sequence=A];")

namedict = {'A':1, 'B': 2, 'C': 9, 'D': 10, 'E': 11, 'F': 8, 'G': 3, 'H': 5, 'I': 7, 'J': 6, 'K': 4, 'root': 'root'}
def test_init():
  r = SdagNode('a')
  assert r.is_leaf() == True
  r = SdagNode('a', clades={frozenset(['a', 'b']): EdgeSet(), frozenset(['c', 'd']): EdgeSet()})
  assert r.is_leaf() == False
  s = SdagNode('b', clades={frozenset(['a', 'b']): EdgeSet(), frozenset(['c', 'd']): EdgeSet([r])})
  assert s.is_leaf() == False

def test_edge():
  r = SdagNode('a')
  r2 = SdagNode('b', {frozenset({'z', 'y'}):EdgeSet(), frozenset({'a'}): EdgeSet()})
  s = SdagNode('b', clades={frozenset(['a']): EdgeSet(), frozenset(['c', 'd']): EdgeSet()})
  s.add_edge(r)
  try:
    s.add_edge(r2)
    assert False
  except KeyError:
    pass

def test_from_tree():
  tree = ete3.Tree(newickstring2, format=1)
  print(tree.sequence)
  dag = from_tree(tree)
  G = dag.to_graphviz(namedict)
  return(G)

def test_postorder():
  tree = ete3.Tree(newickstring2, format=1)
  dag = from_tree(tree)
  assert [namedict[node.label] for node in postorder(dag)] == [4, 6, 7, 5, 3, 8, 11, 10, 9, 2, 1, 'root']
  # print([namedict[node.label] for node in postorder(dag)])

def test_children():
  tree = ete3.Tree(newickstring2, format=1)
  dag = from_tree(tree)
  print([child.label for child in dag.children()])
  for child in dag.children():
    print([cc.label for cc in child.children()])
    for ccc in child.children():
      print([cccc.label for cccc in ccc.children()])

def test_merge():
  tree1 = ete3.Tree(newickstring2, format=1)
  dag1 = from_tree(tree1)
  tree2 = ete3.Tree(newickstring3, format=1)
  dag2 = from_tree(tree2)
  dag1.merge(dag2)
  return(dag1.to_graphviz(namedict))

def test_weight():
  tree1 = ete3.Tree(newickstring2, format=1)
  dag1 = from_tree(tree1)
  tree2 = ete3.Tree(newickstring3, format=1)
  dag2 = from_tree(tree2)
  dag1.merge(dag2)
  return(dag1.to_graphviz(namedict))
  assert dag1.weight() == 16

def test_internal_avg_parents():
  tree1 = ete3.Tree(newickstring2, format=1)
  dag1 = from_tree(tree1)
  tree2 = ete3.Tree(newickstring3, format=1)
  dag2 = from_tree(tree2)
  dag1.merge(dag2)
  return(dag1.to_graphviz(namedict))
  assert dag1.internal_avg_parents() == 9/7

def test_sample():
  newicks = ["((a, b)b, c)c;",
           "((a, b)c, c)c;",
           "((a, b)a, c)c;",
           "((a, b)r, c)r;"]
  newicks = ["((1, 2)2, 3)3;",
           "((1, 2)3, 3)3;",
           "((1, 2)1, 3)3;",
           "((1, 2)4, 3)4;"]
  namedict = {str(x): x for x in range(5)}
  dag = sdag_from_newicks(newicks)
  sample = dag.sample()
  return(sample.to_graphviz(namedict))


test_init()
test_edge()
G = test_from_tree()
test_postorder()
G = test_merge()
test_children()
G = test_weight()
test_internal_avg_parents()
G = test_sample()
G

hash('G')

""" EdgeSet Tests """

def test_init():
  tree = ete3.Tree(newickstring2, format=1)
  dag = from_tree(tree)
  tree1 = ete3.Tree(newickstring2, format=1)
  dag1 = from_tree(tree1)
  e = EdgeSet()
  e1 = EdgeSet([dag])
  try:
    e2 = EdgeSet([dag, dag1])
    raise TypeError("EdgeSet init is allowing identical dags to be added")
  except TypeError:
    pass

def test_iter():
  tree = ete3.Tree(newickstring2, format=1)
  dag = from_tree(tree.children[0])
  tree1 = ete3.Tree(newickstring3, format=1)
  dag1 = from_tree(tree1.children[0])
  e2 = EdgeSet([next(dag.children()), next(dag1.children())])
  for target, weight, prob in e2:
    pass

test_init()
test_iter()

newicks = ["((a, b)b, c)c;",
           "((a, b)c, c)c;",
           "((a, b)a, c)c;",
           "((a, b)r, c)r;"]


d = sdag_from_newicks(newicks)
G = d.to_graphviz()
G

def total_weight(tree: ete3.TreeNode) -> float:
  return(sum(node.dist for node in tree.traverse()))


from gctree import phylip_parse as pps
treelist = pps.parse_outfile('outfile', root="GL")
namedict = {leaf.sequence: leaf.name for leaf in treelist[0].get_leaves()}

sdag = sdag_from_etes(treelist)
print(sdag.internal_avg_parents())
treeweights = [total_weight(tree) for tree in treelist]
sdag.to_graphviz(namedict)

recalculate_weight
random.seed(8)
sampleweights = []
specialtrees = {73.0: [], 74.0: []}
for i in range(10000):
  tree = sdag.sample()
  treeweight = tree.weight()
  if treeweight < 75.0:
    specialtrees[treeweight].append(tree)
  sampleweights.append(treeweight)

n = treeweights.index(76.0)
weirdtree = treelist[n]
total_weight(weirdtree)
ts = ete3.TreeStyle()
ts.show_branch_length = True
# weirdtree.render("%%inline", tree_style=ts)
dag = from_tree(weirdtree)
dag.to_graphviz()
n

from collections import Counter

# plt.hist(sampleweights, density=True)  # density=False would make counts
# plt.ylabel('frequency')
# plt.xlabel('weight');
def hist(c: Counter, samples=1):
  l = list(c.items())
  l.sort()
  print(f"Weight | Frequency",
        "\n------------------")
  for weight, freq in l:
    print(f"{weight}   | {freq/samples}")

print("In dnapars trees:")
hist(Counter(treeweights), samples=263)
print("\nIn trees sampled from sDAG:")
hist(Counter(sampleweights), samples=10000)

n = treeweights.index(51.0)
treelist[n].render("%%inline", tree_style=ts)

from gctree.utils import hamming_distance

sum([hamming_distance(node.sequence, node.up.sequence) for node in treelist[n].iter_descendants()])

print(n)
ts = ete3.TreeStyle()
ts.show_branch_length = True
from_tree(treelist[n]).to_graphviz()
for i in range(500):
  random.seed(i)
  problemtrees = pps.parse_outfile('outfile', root="GL")
  wts = [total_weight(tree) for tree in problemtrees]
  if min(wts) < 75.0:
    print(min(wts))
    break

n = treeweights.index(76.0)
problemtree = treelist[n]
realts = pps.parse_outfile('76tree', root="GL")
realt = realts[0]
g = problemtree.traverse()
gp = realt.traverse()
while True:
  node = next(g)
  nodep = next(gp)
  if not node.sequence == nodep.sequence:
    break

treelist2 = pps.parse_outfile('outfile', root="GL")
treeweights2 = [total_weight(tree) for tree in treelist2]
hist(Counter(treeweights2), samples=263)
strees = pickle.dumps( treelist2 )
for i in range(1000):
  treelist2 = pps.parse_outfile('outfile', root="GL")
  if not pickle.dumps( treelist2 ) == strees:
    print("Not equal!!")
    break
  print(i)

treelist2 = pps.parse_outfile('outfile', root="GL")
pickle.dumps(treelist) == pickle.dumps(treelist2)
with open('ambiguoustree.p', 'wb') as f:
  f.write(pickle.dumps(treelist))

with open('ambiguoustree.p', 'rb') as f:
  tree = pickle.load(f)
for node in tree.traverse():
  node.sequence = node.sequence[145]
  node.dist = 0
tree = tree.children[0].detach()
tree = tree.children[1].detach()
tree.remove_child(tree.children[1])
print(tree.get_leaf_names())
print(tree.write(features=['name', 'sequence'], format=1))

dag = from_tree(tree)
dag.to_graphviz()

from gctree.utils import hamming_distance
t = ete3.TreeNode(newick="(((4[&&NHX:name=4:sequence=C],(6[&&NHX:name=6:sequence=C],7[&&NHX:name=7:sequence=A])5[&&NHX:name=5:sequence=M])3[&&NHX:name=3:sequence=M],8[&&NHX:name=8:sequence=A],(11[&&NHX:name=11:sequence=A],10[&&NHX:name=10:sequence=G])9[&&NHX:name=9:sequence=R])2[&&NHX:name=2:sequence=R])1[&&NHX:name=1:sequence=G];", format=1)
# t = pps.disambiguate(t)
for node in t.iter_descendants():
  node.dist = hamming_distance(node.up.sequence, node.sequence)
from_tree(t).to_graphviz()

t = ete3.TreeNode(newick="(((4[&&NHX:name=4:sequence=C],(6[&&NHX:name=6:sequence=C],7[&&NHX:name=7:sequence=A])5[&&NHX:name=5:sequence=N])3[&&NHX:name=3:sequence=N],8[&&NHX:name=8:sequence=A],(11[&&NHX:name=11:sequence=A],10[&&NHX:name=10:sequence=G])9[&&NHX:name=9:sequence=N])2[&&NHX:name=2:sequence=N])1[&&NHX:name=1:sequence=G];", format=1)
node = t.children[0]
import numpy as np
children = [np.array([1,2,1,2, np.inf]), np.array([np.inf, np.inf, 0, np.inf, np.inf])]
bases = "AGCT-"
cost_adjust = {base: np.array([int(not i == j) for j in range(5)]) for i, base in enumerate(bases)}
for i in range(5):
  print(sum([min(childcv + cost_adjust[bases[i]]) for childcv in children]))

ldef is_leaf(n):
  if n.up is None:
    return(False)
  else:
    return(n.up.child_leaf)
tr = ete3.TreeNode(newick="(((A)B)C)D;", format=8)
tr.child_leaf = False
for node in tr.iter_descendants():
  if node.is_leaf():
    node.up.child_leaf = True
  else:
    node.up.child_leaf = False
for node in tr.iter_descendants(strategy="preorder", is_leaf_fn=is_leaf):
  print(node)
tr.del_feature(child_leaf)
tr.child_leaf

ts = ete3.TreeStyle()
ts.show_branch_length = True
tree.render("%%inline", tree_style=ts)
# tree.children[0].children[1].dist

dag = from_tree(forest.forest[0].tree.children[0])
for gctree in forest.forest[1:]:
  dag.merge(from_tree(gctree.tree.children[0]))
dag

s = set()
s.add(1)
74.0 < 75

l = [1,2]
l.reverse()
print(l)

def taxa(clade):
      return(''.join(clade))
r = SdagNode('a')
r2 = SdagNode('b', {frozenset({'z', 'y'}):[], frozenset({'a'}): []})
s = SdagNode('b', clades={frozenset(['a']): [], frozenset(['c', 'd']): []})
s.add_edge(r)
node = s
splits = '|'.join([f'<{taxa(clade)}> {taxa(clade)}' for clade in node.clades])
print(splits)

s.clades

s.children(frozenset({'a'}))

tree = ete3.Tree("(( (a, b, c)A, (d, e, f, g)D)AD, (h, i, j)H)HAD;", format=8)
dag = from_tree(tree)

dag.clades[frozenset({'a', 'b', 'c', 'd', 'e', 'f', 'g'})][0].clades

print(frozenset({'a', 'b'}))

''.join({'a', 'b'})

tree = ete3.Tree("(( (a, b, c)A, (d, e, f, g)D)AD, (h, i, j)H)HAD;", format=8)
dag = from_tree(tree)
l = [child for clade in dag.clades for child in dag.children(clade=clade)]
l[0].clades[frozenset({'a', 'b', 'c'})][0].clades[frozenset({'a'})][0]

s = gv.Digraph('structs', node_attr={'shape':'record'})
s.node('s1', '{ <top> |{<left> a | <middle> b | <right> c} }')
s

s1 = frozenset({'a', 'b', 'c'})
s2 = frozenset({'b', 'd', 'j'})
l = [s1, s2]
frozenset({item for s in l for item in s})

d = {1:2, 3:4}
list(d.keys())

def f(*args):
  print(args)
f(1,2)

f()

list(map(f, [1,2,3]))

tree1 = ete3.Tree("(( (a, b, c)A, (d, e, f, g)D)AD, (h, i, j)H)HAD;", format=8)
dag1 = from_tree(tree1)
tree2 = ete3.Tree("((a, b, c)A, (d, e, f)K, (g, h, i, j)H)HADD;", format=8)
dag2 = from_tree(tree2)
for t in tree2.get_leaves():
  print(t.dist)

