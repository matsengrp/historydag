<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>historydag.dag &mdash; historydag  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">Description</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html#classes">Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html#functions">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html#modules">Modules</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">historydag</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">historydag.dag</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for historydag.dag</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;A module providing the class HistoryDag, and supporting functions.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>
<span class="kn">import</span> <span class="nn">graphviz</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">ete3</span>
<span class="kn">from</span> <span class="nn">frozendict</span> <span class="kn">import</span> <span class="n">frozendict</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Generator</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">NamedTuple</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">FrozenSet</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">historydag</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">historydag.utils</span> <span class="kn">import</span> <span class="n">Weight</span><span class="p">,</span> <span class="n">Label</span><span class="p">,</span> <span class="n">UALabel</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">TaxaError</span>
<span class="kn">from</span> <span class="nn">historydag.counterops</span> <span class="kn">import</span> <span class="n">counter_sum</span><span class="p">,</span> <span class="n">counter_prod</span>
<span class="kn">import</span> <span class="nn">historydag.parsimony_utils</span> <span class="k">as</span> <span class="nn">parsimony_utils</span>
<span class="kn">from</span> <span class="nn">historydag.dag_node</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">HistoryDagNode</span><span class="p">,</span>
    <span class="n">UANode</span><span class="p">,</span>
    <span class="n">EdgeSet</span><span class="p">,</span>
    <span class="n">empty_node</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="IntersectionError">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.IntersectionError">[docs]</a>
<span class="k">class</span> <span class="nc">IntersectionError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="k">pass</span></div>



<span class="k">def</span> <span class="nf">_clade_union_dict</span><span class="p">(</span><span class="n">nodeseq</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
    <span class="n">clade_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="n">Label</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodeseq</span><span class="p">:</span>
        <span class="n">clade_union</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">clade_union</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">clade_dict</span><span class="p">:</span>
            <span class="n">clade_dict</span><span class="p">[</span><span class="n">clade_union</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">clade_dict</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">clade_dict</span>


<span class="k">def</span> <span class="nf">_none_override_ternary</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">if_true</span><span class="p">,</span> <span class="n">if_false</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">condition</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">if_true</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">if_false</span>


<span class="k">def</span> <span class="nf">get_default_args</span><span class="p">(</span><span class="n">argnamelist</span><span class="p">,</span> <span class="n">positional_count</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">weight_count_args</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="c1"># To make argument management simpler, we require this:</span>
            <span class="k">if</span> <span class="n">nargs</span> <span class="o">&lt;</span> <span class="n">positional_count</span> <span class="ow">or</span> <span class="n">nargs</span> <span class="o">&gt;</span> <span class="n">positional_count</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2"> requires exactly </span><span class="si">{</span><span class="n">positional_count</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;positional argument but received </span><span class="si">{</span><span class="n">nargs</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">argname</span> <span class="ow">in</span> <span class="n">argnamelist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">argname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">argname</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">kwargs</span><span class="p">[</span><span class="n">argname</span><span class="p">]</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">_default_args</span><span class="p">[</span><span class="n">argname</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2"> requires a value for the keyword argument &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">argname</span><span class="si">}</span><span class="s2">, since </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not define a default&quot;</span>
                        <span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wrapper</span>

    <span class="k">return</span> <span class="n">weight_count_args</span>


<div class="viewcode-block" id="convert">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.convert">[docs]</a>
<span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">dag</span><span class="p">,</span> <span class="n">newclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert ``dag`` to the HistoryDag subclass ``newclass``.</span>

<span class="sd">    This is a wrapper for the ``newclass.from_history_dag`` method,</span>
<span class="sd">    which for most subclasses should be identical to</span>
<span class="sd">    :meth:`HistoryDag.from_history_dag`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">newclass</span><span class="o">.</span><span class="n">from_history_dag</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span></div>



<span class="c1"># Preorder tree creation class</span>

<span class="n">TreeBuilderNode</span> <span class="o">=</span> <span class="n">Any</span>


<div class="viewcode-block" id="PreorderTreeBuilder">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.PreorderTreeBuilder">[docs]</a>
<span class="k">class</span> <span class="nc">PreorderTreeBuilder</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Any class implementing a PreorderTreeBuilder interface can be used as a</span>
<span class="sd">    tree sample constructor in :meth:`HistoryDag.fast_sample`. Subclasses</span>
<span class="sd">    implementing this interface may implement an arbitrary constructor</span>
<span class="sd">    interface, as the user will be responsible for creating instances to be</span>
<span class="sd">    used for sampling. In addition, subclasses must implement the following</span>
<span class="sd">    methods:</span>

<span class="sd">    Methods:</span>
<span class="sd">        add_node: This method must accept a :class:HistoryDagNode object ``dag_node`` and, optionally</span>
<span class="sd">            a TreeBuilderNode instance ``parent``, representing the parent node of the node to be added,</span>
<span class="sd">            and returns a TreeBuilderNode instance representing the added node in the sampled</span>
<span class="sd">            tree. TreeBuilderNode can be any type which is convenient for the internal</span>
<span class="sd">            implementation of the PreorderTreeBuilder subclass. This method can expect to be</span>
<span class="sd">            called on nodes in a sampled tree in a pre-ordering. A parent node will always be</span>
<span class="sd">            provided unless `dag_node` is the root node.</span>
<span class="sd">        get_finished_tree: This method takes no arguments and returns the data defining the</span>
<span class="sd">            sampled tree, after any necessary clean-up or final tree construction steps. Its</span>
<span class="sd">            return value is the return value of :meth:`HistoryDag.fast_sample`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>



<div class="viewcode-block" id="EteTreeBuilder">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.EteTreeBuilder">[docs]</a>
<span class="k">class</span> <span class="nc">EteTreeBuilder</span><span class="p">(</span><span class="n">PreorderTreeBuilder</span><span class="p">):</span>
<div class="viewcode-block" id="EteTreeBuilder.__init__">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.EteTreeBuilder.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;unnamed&quot;</span><span class="p">,</span>
        <span class="n">features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">feature_funcs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">treeroot</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name_func</span> <span class="o">=</span> <span class="n">name_func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_funcs</span> <span class="o">=</span> <span class="n">feature_funcs</span>

        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">feature_func</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">feature</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">feature_funcs</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span> <span class="o">=</span> <span class="n">feature_func</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">feature_funcs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span></div>


    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dag_node</span><span class="p">:</span> <span class="n">HistoryDagNode</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">:</span>
        <span class="c1"># Skip the UA Node</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dag_node</span><span class="p">,</span> <span class="n">UANode</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">newnode</span> <span class="o">=</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">()</span>
        <span class="n">newnode</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_func</span><span class="p">(</span><span class="n">dag_node</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">feature</span><span class="p">,</span> <span class="n">feature_func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_funcs</span><span class="p">:</span>
            <span class="n">newnode</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="n">feature_func</span><span class="p">(</span><span class="n">dag_node</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">treeroot</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">treeroot</span> <span class="o">=</span> <span class="n">newnode</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">child</span><span class="o">=</span><span class="n">newnode</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newnode</span>

    <span class="k">def</span> <span class="nf">get_finished_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">treeroot</span></div>



<div class="viewcode-block" id="PreorderHistoryBuilder">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.PreorderHistoryBuilder">[docs]</a>
<span class="k">class</span> <span class="nc">PreorderHistoryBuilder</span><span class="p">(</span><span class="n">PreorderTreeBuilder</span><span class="p">):</span>
<div class="viewcode-block" id="PreorderHistoryBuilder.__init__">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.PreorderHistoryBuilder.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dag_type</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dag_type</span> <span class="o">=</span> <span class="n">dag_type</span></div>


    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dag_node</span><span class="p">:</span> <span class="n">HistoryDagNode</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">HistoryDagNode</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDagNode</span><span class="p">:</span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="n">dag_node</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_node</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root_node</span> <span class="o">=</span> <span class="n">new_node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">parent</span><span class="p">,</span> <span class="n">new_node</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new_node</span>

    <span class="k">def</span> <span class="nf">get_finished_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">):</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dag_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">)</span></div>



<div class="viewcode-block" id="HistoryDag">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag">[docs]</a>
<span class="k">class</span> <span class="nc">HistoryDag</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;An object to represent a collection of internally labeled trees. A</span>
<span class="sd">    wrapper object to contain exposed HistoryDag methods and point to a</span>
<span class="sd">    HistoryDagNode root.</span>

<span class="sd">    Args:</span>
<span class="sd">        dagroot: The root node of the history DAG</span>
<span class="sd">        attr: An attribute to contain data which will be preserved by copying (default and empty dict)</span>


<span class="sd">    Subclassing HistoryDag:</span>
<span class="sd">    HistoryDag may be subclassed without overriding __init__, by defining a `_required_label_fields` class variable</span>
<span class="sd">    for any subclasses.</span>

<span class="sd">    The value of `_required_label_fields` should be a dictionary keyed by label fields that are expected by methods</span>
<span class="sd">    of the subclass. Each dictionary entry shall be of the form `required_field: [(from_fields, conversion_func), ...]`, where</span>
<span class="sd">    the dict value is a list of tuples, with each `conversion_func` a function mapping `HistoryDagNode`s to the value of</span>
<span class="sd">    that node label&#39;s `required_field` field, and `from_fields` a tuple containing all label fields expected by that function.</span>

<span class="sd">    Keyword arguments passed to :meth:`HistoryDag.from_history_dag` will be passed to conversion functions provided in the</span>
<span class="sd">    appropriate subclass&#39;s `_required_label_fields` attribute. Be sure to document each subclass, including available</span>
<span class="sd">    conversion functions and their keywords, in each subclass&#39;s docstring.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_required_label_fields</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">_default_args</span> <span class="o">=</span> <span class="n">frozendict</span><span class="p">(</span><span class="n">parsimony_utils</span><span class="o">.</span><span class="n">hamming_distance_countfuncs</span><span class="p">)</span> <span class="o">|</span> <span class="p">{</span>
        <span class="s2">&quot;start_func&quot;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">0</span><span class="p">),</span>
        <span class="s2">&quot;edge_func&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">:</span> <span class="p">(</span>
            <span class="mi">0</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">UALabel</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">parsimony_utils</span><span class="o">.</span><span class="n">default_nt_transitions</span><span class="o">.</span><span class="n">weighted_hamming_distance</span><span class="p">(</span>
                <span class="n">l1</span><span class="o">.</span><span class="n">sequence</span><span class="p">,</span> <span class="n">l2</span><span class="o">.</span><span class="n">sequence</span>
            <span class="p">)</span>
        <span class="p">),</span>
        <span class="s2">&quot;expand_func&quot;</span><span class="p">:</span> <span class="n">parsimony_utils</span><span class="o">.</span><span class="n">default_nt_transitions</span><span class="o">.</span><span class="n">ambiguity_map</span><span class="o">.</span><span class="n">get_sequence_resolution_func</span><span class="p">(</span>
            <span class="s2">&quot;sequence&quot;</span>
        <span class="p">),</span>
        <span class="s2">&quot;optimal_func&quot;</span><span class="p">:</span> <span class="nb">min</span><span class="p">,</span>
    <span class="p">}</span>

<div class="viewcode-block" id="HistoryDag.from_history_dag">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.from_history_dag">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_history_dag</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">dag</span><span class="p">:</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span> <span class="n">label_fields</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts HistoryDag instances between subclasses of HistoryDag. No</span>
<span class="sd">        copy is performed, so the passed `dag` will in general be modified.</span>

<span class="sd">        Args:</span>
<span class="sd">            dag: A HistoryDag (or subclass) instance</span>
<span class="sd">            label_fields: A list specifying the order of label fields in node labels on the resulting HistoryDag</span>
<span class="sd">            kwargs: Any additional arguments required for label conversions. For details, see the class docstring</span>
<span class="sd">                for the subclass into which the conversion is taking place.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The converted HistoryDag object, carrying the type from which this static method was called.</span>
<span class="sd">            After conversion to the new HistoryDag subclass ``to_cls``, the following will be true about node labels:</span>

<span class="sd">            * If passed ``label_fields`` is None, then existing label fields will be preserved, except that missing</span>
<span class="sd">              required label fields will be recovered if possible, and the existing label fields used to recover</span>
<span class="sd">              them will be omitted. Recovered label fields will appear before the existing label fields.</span>
<span class="sd">            * If passed ``label_fields`` is not None, then it must include all fields expected in node labels</span>
<span class="sd">              in the converted history DAG object, otherwise an exception will be raised.</span>
<span class="sd">            * Converted node label field order will match the order of passed ``label_fields``.</span>
<span class="sd">            * All label fields passed in ``label_fields`` will be included</span>
<span class="sd">              in converted node labels, if possible. Otherwise, an exception will be raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">label_fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">label_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">label_fields</span><span class="p">)</span>
        <span class="n">required_fields_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_required_label_fields</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">label_fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">required_fields_set</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">label_fields</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="c1"># This would be handled by __init__ anyway, but this prevents</span>
            <span class="c1"># any changes from being applied first and provides better</span>
            <span class="c1"># error message</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If passed, `label_fields` must contain all required label fields&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;for </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">required_fields_set</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">label_fields</span> <span class="o">==</span> <span class="n">dag</span><span class="o">.</span><span class="n">label_fields</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">label_fields</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">required_fields_set</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">label_fields</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="c1"># No label modification is needed</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">dagroot</span><span class="p">,</span> <span class="n">dag</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_existing_field</span><span class="p">(</span><span class="n">fieldname</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">get_field</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">HistoryDagNode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">get_field</span>

        <span class="k">def</span> <span class="nf">raise_unable_error</span><span class="p">(</span><span class="n">fieldname</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">label_fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">label_fields</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; Label field &#39;</span><span class="si">{</span><span class="n">fieldname</span><span class="si">}</span><span class="s2">&#39; is not present in existing label fields.&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unable to convert </span><span class="si">{</span><span class="n">dag</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> with label fields </span><span class="si">{</span><span class="n">dag</span><span class="o">.</span><span class="n">label_fields</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;, which requires label field &#39;</span><span class="si">{</span><span class="n">fieldname</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">required_fields_set</span><span class="p">:</span>
                <span class="n">fromtuples</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_required_label_fields</span><span class="p">[</span><span class="n">fieldname</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fromtuples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="s2">&quot; Automatic conversion from label fields&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="s1">&#39; or &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">converttuple</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">converttuple</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">fromtuples</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="s2">&quot; is supported.&quot;</span>
                    <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

        <span class="n">precursor_fields</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">find_conversion_func</span><span class="p">(</span><span class="n">fieldname</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">label_fields</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">get_existing_field</span><span class="p">(</span><span class="n">fieldname</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">required_fields_set</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">from_fields</span><span class="p">,</span> <span class="n">conversion_func</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_required_label_fields</span><span class="p">[</span>
                    <span class="n">fieldname</span>
                <span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">from_fields</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">label_fields</span><span class="p">)):</span>
                        <span class="n">precursor_fields</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">from_fields</span><span class="p">)</span>
                        <span class="k">return</span> <span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">conversion_func</span><span class="p">)</span>
            <span class="n">raise_unable_error</span><span class="p">(</span><span class="n">fieldname</span><span class="p">)</span>

        <span class="n">convert_funcs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">label_fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># keep all existing fields, except those used to recover missing</span>
            <span class="c1"># required fields:</span>
            <span class="n">added_fields</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_required_label_fields</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">label_fields</span> <span class="ow">and</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">added_fields</span><span class="p">:</span>
                    <span class="n">convert_funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">find_conversion_func</span><span class="p">(</span><span class="n">field</span><span class="p">))</span>
                    <span class="n">added_fields</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">label_fields</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">added_fields</span> <span class="ow">and</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">precursor_fields</span><span class="p">:</span>
                    <span class="n">convert_funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">find_conversion_func</span><span class="p">(</span><span class="n">field</span><span class="p">))</span>
                    <span class="n">added_fields</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">label_fields</span><span class="p">:</span>
                <span class="n">convert_funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">find_conversion_func</span><span class="p">(</span><span class="n">field</span><span class="p">))</span>

        <span class="n">Label</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span>
            <span class="s2">&quot;Label&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="n">converttuple</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Any</span><span class="p">)</span> <span class="k">for</span> <span class="n">converttuple</span> <span class="ow">in</span> <span class="n">convert_funcs</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">relabel_func</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">labeldata</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">converttuple</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">node</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">converttuple</span> <span class="ow">in</span> <span class="n">convert_funcs</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="n">Label</span><span class="p">(</span><span class="o">*</span><span class="n">labeldata</span><span class="p">)</span>

        <span class="n">newdag</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">relabel_func</span><span class="p">,</span> <span class="n">relax_type</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">newdag</span><span class="o">.</span><span class="n">dagroot</span><span class="p">,</span> <span class="n">dag</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.__init__">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dagroot</span><span class="p">:</span> <span class="n">HistoryDagNode</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="p">{}):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dagroot</span><span class="p">,</span> <span class="n">UANode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="n">attr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span> <span class="o">=</span> <span class="n">dagroot</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_fields</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">())</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">_fields</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_fields</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_required_label_fields</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_fields</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;An instance of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> must have node labels containing a &#39;</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">&#39; field.&quot;</span>
                <span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Eventually this can be done by comparing bytestrings, but we need</span>
        <span class="c1"># some sorting to be done first, to ensure two dags that represent</span>
        <span class="c1"># identical trees return True. TODO</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the history (tree-shaped sub-history DAG) in the current</span>
<span class="sd">        history dag corresponding to the given index.</span>

<span class="sd">        Alternatively, if ``key`` is a :class:`utils.HistoryDagFilter`</span>
<span class="sd">        object, the returned history DAG is the result of</span>
<span class="sd">        ``dag.trim_optimal_weight(**key)`` where ``dag`` is a copy of</span>
<span class="sd">        ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">utils</span><span class="o">.</span><span class="n">HistoryDagFilter</span><span class="p">):</span>
            <span class="n">dag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">dag</span><span class="o">.</span><span class="n">trim_optimal_weight</span><span class="p">(</span><span class="o">**</span><span class="n">key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dag</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="c1"># This call to count_histories is essential because we use</span>
            <span class="c1"># the cached node counts later. For faster indexing, call this</span>
            <span class="c1"># method once and call _get_subhistory_by_subid yourself.</span>
            <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">length</span> <span class="o">+</span> <span class="n">key</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">key</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span>
            <span class="n">builder</span> <span class="o">=</span> <span class="n">PreorderHistoryBuilder</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">_get_subhistory_by_subid</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">builder</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">builder</span><span class="o">.</span><span class="n">get_finished_tree</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;History DAG indices must be integers or utils.HistoryDagFilter&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; objects, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="HistoryDag.get_histories_by_index">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.get_histories_by_index">[docs]</a>
    <span class="k">def</span> <span class="nf">get_histories_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_iterator</span><span class="p">,</span> <span class="n">tree_builder_func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieving a history by index is slow, since each retrieval requires</span>
<span class="sd">        running the ``trim_optimal_weight`` method on the entire DAG to</span>
<span class="sd">        populate node counts. This method instead runs that method a single</span>
<span class="sd">        time and yields a history for each index yielded by ``key_iterator``.</span>

<span class="sd">        Args:</span>
<span class="sd">            key_iterator: An iterator on desired history indices. May be consumable, as</span>
<span class="sd">                it will only be used once.</span>
<span class="sd">            tree_builder_func: A function accepting an index and returning a</span>
<span class="sd">                :class:`PreorderTreeBuilder` instance to be used to build the history</span>
<span class="sd">                with that index. If None (default), then tree-shaped HistoryDag objects</span>
<span class="sd">                will be yielded using :class:`PreorderHistoryBuilder`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tree_builder_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">tree_builder_func</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">PreorderHistoryBuilder</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">key_iterator</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">length</span> <span class="o">+</span> <span class="n">key</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">key</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Invalid index </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> in DAG containing </span><span class="si">{</span><span class="n">length</span><span class="si">}</span><span class="s2"> histories&quot;</span>
                <span class="p">)</span>
            <span class="n">builder</span> <span class="o">=</span> <span class="n">tree_builder_func</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">_get_subhistory_by_subid</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">builder</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">builder</span><span class="o">.</span><span class="n">get_finished_tree</span><span class="p">()</span></div>


<div class="viewcode-block" id="HistoryDag.get_label_type">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.get_label_type">[docs]</a>
    <span class="k">def</span> <span class="nf">get_label_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the type for labels on this dag&#39;s nodes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">())</span><span class="o">.</span><span class="n">label</span><span class="p">)</span></div>


    <span class="nd">@get_default_args</span><span class="p">([</span><span class="s2">&quot;start_func&quot;</span><span class="p">,</span> <span class="s2">&quot;edge_weight_func&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">trim_within_range</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">min_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">start_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
            <span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="n">HistoryDagNode</span><span class="p">],</span> <span class="n">Weight</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">parsimony_utils</span><span class="o">.</span><span class="n">hamming_edge_weight</span><span class="p">,</span>
        <span class="n">min_possible_weight</span><span class="o">=-</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span>
        <span class="n">max_possible_weight</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">max_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trim_below_weight</span><span class="p">(</span>
                <span class="n">max_weight</span><span class="p">,</span>
                <span class="n">start_func</span><span class="o">=</span><span class="n">start_func</span><span class="p">,</span>
                <span class="n">edge_weight_func</span><span class="o">=</span><span class="n">edge_weight_func</span><span class="p">,</span>
                <span class="n">min_possible_weight</span><span class="o">=</span><span class="n">min_possible_weight</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">min_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trim_below_weight</span><span class="p">(</span>
                <span class="o">-</span><span class="n">min_weight</span><span class="p">,</span>
                <span class="n">start_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="o">-</span><span class="n">start_func</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>
                <span class="n">edge_weight_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">:</span> <span class="o">-</span><span class="n">edge_weight_func</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">),</span>
                <span class="n">min_possible_weight</span><span class="o">=-</span><span class="n">max_possible_weight</span><span class="p">,</span>
            <span class="p">)</span>

<div class="viewcode-block" id="HistoryDag.trim_below_weight">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.trim_below_weight">[docs]</a>
    <span class="nd">@get_default_args</span><span class="p">([</span><span class="s2">&quot;start_func&quot;</span><span class="p">,</span> <span class="s2">&quot;edge_weight_func&quot;</span><span class="p">],</span> <span class="n">positional_count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">trim_below_weight</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_weight</span><span class="p">,</span>
        <span class="n">start_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="n">HistoryDagNode</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_possible_weight</span><span class="o">=-</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Trim the dag to contain at least all the histories within the</span>
<span class="sd">        specified weight range.</span>

<span class="sd">        Supports totally ordered weights, accumulated by addition. A</span>
<span class="sd">        weight type must implement all ordering operators properly, as</span>
<span class="sd">        well as + and -, and addition and subtraction must respect the</span>
<span class="sd">        ordering. That is, if a &lt; b, then a + c &lt; b + c for any c</span>
<span class="sd">        (including negative c)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">trim_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>  <span class="c1"># base case - the node is a leaf</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node_min_weight</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_dp_data</span>  <span class="c1"># minimum weight of subtree under node</span>
                <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">weightlist</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
                        <span class="n">edgeweight</span> <span class="o">=</span> <span class="n">edge_weight_func</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
                        <span class="n">weightlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">_dp_data</span> <span class="o">+</span> <span class="n">edgeweight</span><span class="p">,</span> <span class="n">edgeweight</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
                        <span class="p">)</span>

                    <span class="c1"># By assuming a minimum weight edge is chosen for all other</span>
                    <span class="c1"># clades, we compute the maximum weight of a subtree below this</span>
                    <span class="c1"># clade</span>
                    <span class="n">min_weight_under_clade</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                        <span class="n">minweight</span> <span class="k">for</span> <span class="n">minweight</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">weightlist</span>
                    <span class="p">)</span>
                    <span class="c1"># The sum of minimum scores beneath all other clades is</span>
                    <span class="c1"># quantity in parentheses:</span>
                    <span class="n">max_weight_allowed_clade</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">maxweight</span> <span class="o">-</span> <span class="p">(</span>
                        <span class="n">node_min_weight</span> <span class="o">-</span> <span class="n">min_weight_under_clade</span>
                    <span class="p">)</span>

                    <span class="n">to_keep</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="p">(</span>
                        <span class="n">minweight</span><span class="p">,</span>
                        <span class="n">edgeweight</span><span class="p">,</span>
                        <span class="n">target</span><span class="p">,</span>
                    <span class="p">)</span> <span class="ow">in</span> <span class="p">(</span>
                        <span class="n">weightlist</span>
                    <span class="p">):</span>  <span class="c1"># this is looping through all the edges under clade</span>
                        <span class="k">if</span> <span class="n">minweight</span> <span class="o">&lt;=</span> <span class="n">max_weight_allowed_clade</span><span class="p">:</span>
                            <span class="n">targetmax</span> <span class="o">=</span> <span class="n">max_weight_allowed_clade</span> <span class="o">-</span> <span class="n">edgeweight</span>
                            <span class="n">target</span><span class="o">.</span><span class="n">maxweight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">maxweight</span><span class="p">,</span> <span class="n">targetmax</span><span class="p">)</span>
                            <span class="n">to_keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="n">eset</span><span class="o">.</span><span class="n">set_targets</span><span class="p">(</span><span class="n">to_keep</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">optimal_weight_annotate</span><span class="p">(</span>
            <span class="n">start_func</span><span class="o">=</span><span class="n">start_func</span><span class="p">,</span> <span class="n">edge_weight_func</span><span class="o">=</span><span class="n">edge_weight_func</span>
        <span class="p">)</span>

        <span class="n">nl</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())))</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nl</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">maxweight</span> <span class="o">=</span> <span class="n">min_possible_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">maxweight</span> <span class="o">=</span> <span class="n">max_weight</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nl</span><span class="p">:</span>
            <span class="n">trim_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
        <span class="n">newdag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">newdag</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newdag</span>

    <span class="k">def</span> <span class="fm">__ior__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">|</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__iand__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">HistoryDag</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unsupported operand types for &amp;: &#39;HistoryDag&#39; and &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history_intersect</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
        <span class="n">cdag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cdag</span> <span class="o">&amp;=</span> <span class="n">other</span>
        <span class="k">return</span> <span class="n">cdag</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">HistoryDag</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;in &lt;HistoryDag&gt;&#39; requires a HistoryDag as left operand, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">is_history</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;in &lt;HistoryDag&gt; requires a HistoryDag containing a single history as left operand.&quot;</span>
            <span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">edge_difference_funcs</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimal_weight_annotate</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">optimal_func</span><span class="o">=</span><span class="nb">min</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converts HistoryDag to a bytestring-serializable dictionary.</span>

<span class="sd">        Since a HistoryDag is a recursive data structure, and contains label</span>
<span class="sd">        types defined in function scope, modifications must be made for pickling.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary containing:</span>
<span class="sd">            * label_fields: The names of label fields.</span>
<span class="sd">            * label_list: labels used in nodes, without duplicates. Indices are</span>
<span class="sd">                mapped to nodes in node_list</span>
<span class="sd">            * node_list: node tuples containing</span>
<span class="sd">                (node label index in label_list, tuple of frozensets of leaf label indices, node.attr).</span>
<span class="sd">            * edge_list: a tuple for each edge:</span>
<span class="sd">                    (origin node index, target node index, edge weight, edge probability)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">label_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">_fields</span>
        <span class="n">label_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">node_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edge_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">label_indices</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Label</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">node_indices</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())}</span>

        <span class="k">def</span> <span class="nf">cladesets</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="nb">frozenset</span><span class="p">({</span><span class="n">label_indices</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">clade</span><span class="p">})</span>
                <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">label_indices</span><span class="p">:</span>
                <span class="n">label_indices</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">label_list</span><span class="p">)</span>
                <span class="n">label_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">label_list</span><span class="p">[</span><span class="n">label_indices</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">]]</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span>
                    <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="n">node_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">label_indices</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">],</span> <span class="n">cladesets</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">node</span><span class="o">.</span><span class="n">attr</span><span class="p">))</span>
            <span class="n">node_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">):</span>
                    <span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">node_idx</span><span class="p">,</span>
                            <span class="n">node_indices</span><span class="p">[</span><span class="n">target</span><span class="p">],</span>
                            <span class="n">eset</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                            <span class="n">eset</span><span class="o">.</span><span class="n">probs</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
        <span class="n">serial_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;label_fields&quot;</span><span class="p">:</span> <span class="n">label_fields</span><span class="p">,</span>
            <span class="s2">&quot;label_list&quot;</span><span class="p">:</span> <span class="n">label_list</span><span class="p">,</span>
            <span class="s2">&quot;node_list&quot;</span><span class="p">:</span> <span class="n">node_list</span><span class="p">,</span>
            <span class="s2">&quot;edge_list&quot;</span><span class="p">:</span> <span class="n">edge_list</span><span class="p">,</span>
            <span class="s2">&quot;attr&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">serial_dict</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">serial_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rebuilds a HistoryDagNode using a serial_dict output by</span>
<span class="sd">        __getstate__&quot;&quot;&quot;</span>
        <span class="n">label_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]</span> <span class="o">=</span> <span class="n">serial_dict</span><span class="p">[</span><span class="s2">&quot;label_list&quot;</span><span class="p">]</span>
        <span class="n">node_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]</span> <span class="o">=</span> <span class="n">serial_dict</span><span class="p">[</span><span class="s2">&quot;node_list&quot;</span><span class="p">]</span>
        <span class="n">edge_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="n">serial_dict</span><span class="p">[</span><span class="s2">&quot;edge_list&quot;</span><span class="p">]</span>
        <span class="n">label_fields</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">serial_dict</span><span class="p">[</span><span class="s2">&quot;label_fields&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_fields</span> <span class="o">=</span> <span class="n">label_fields</span>
        <span class="n">Label</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span><span class="s2">&quot;Label&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="n">label</span><span class="p">,</span> <span class="nb">any</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">label_fields</span><span class="p">])</span>  <span class="c1"># type: ignore</span>

        <span class="k">def</span> <span class="nf">unpack_labels</span><span class="p">(</span><span class="n">labelset</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">Label</span><span class="p">(</span><span class="o">*</span><span class="n">label_list</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">labelset</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="n">node_postorder</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">UANode</span><span class="p">(</span><span class="n">EdgeSet</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">label_list</span><span class="p">[</span><span class="n">labelidx</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">HistoryDagNode</span><span class="p">(</span>
                <span class="p">(</span><span class="n">Label</span><span class="p">(</span><span class="o">*</span><span class="n">label_list</span><span class="p">[</span><span class="n">labelidx</span><span class="p">])),</span>
                <span class="p">{</span><span class="n">unpack_labels</span><span class="p">(</span><span class="n">clade</span><span class="p">):</span> <span class="n">EdgeSet</span><span class="p">()</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">clades</span><span class="p">},</span>
                <span class="n">attr</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">labelidx</span><span class="p">,</span> <span class="n">clades</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">node_list</span>
        <span class="p">]</span>
        <span class="c1"># Last node in list is root</span>
        <span class="k">for</span> <span class="n">origin_idx</span><span class="p">,</span> <span class="n">target_idx</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="n">edge_list</span><span class="p">:</span>
            <span class="n">node_postorder</span><span class="p">[</span><span class="n">origin_idx</span><span class="p">]</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span>
                <span class="n">node_postorder</span><span class="p">[</span><span class="n">target_idx</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="n">prob</span><span class="p">,</span> <span class="n">prob_norm</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span> <span class="o">=</span> <span class="n">node_postorder</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="n">serial_dict</span><span class="p">[</span><span class="s2">&quot;attr&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_check_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check that this HistoryDag complies with all the conditions of the</span>
<span class="sd">        definition.&quot;&quot;&quot;</span>
        <span class="c1"># Traversal checks if a node has been visited by its id, which makes it</span>
        <span class="c1"># suitable for these checks.</span>
        <span class="n">po</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())</span>
        <span class="n">node_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">po</span><span class="p">)</span>

        <span class="c1"># ***Node instances are unique (And therefore leaves are uniquely labeled also):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">po</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_set</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Node instances are not unique&quot;</span><span class="p">)</span>

        <span class="c1"># ***All nodes are reachable from the UA node: this is proven by the</span>
        <span class="c1"># structure of the postorder traversal; if a node is visited, then it&#39;s</span>
        <span class="c1"># reachable by following directed edges downward. (parent sets aren&#39;t</span>
        <span class="c1"># used in the traversal)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">po</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
                <span class="c1"># *** Clades are pairwise disjoint:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">sum</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">clade</span><span class="p">)</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span>
                    <span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Found a node whose child clades are not pairwise disjoint&quot;</span>
                        <span class="p">)</span>
                <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
                        <span class="c1"># ***Parent clade equals child clade union for all edges:</span>
                        <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span> <span class="o">!=</span> <span class="n">clade</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s2">&quot;Parent clade does not equal child clade union: &quot;</span>
                            <span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">po</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># ***At least one edge descends from each node-clade pair:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found a clade with no child edges&quot;</span><span class="p">)</span>
                <span class="c1"># ...and there are no duplicate children:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Duplicate child edges found descending from the same clade&quot;</span>
                    <span class="p">)</span>
                <span class="c1"># ...and the eset._targetset set is correct</span>
                <span class="k">if</span> <span class="n">eset</span><span class="o">.</span><span class="n">_targetset</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;eset._targetset doesn&#39;t match eset.targets&quot;</span><span class="p">)</span>

        <span class="n">parents</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">po</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">po</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                <span class="n">parents</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">po</span><span class="p">:</span>
            <span class="c1"># ... and parent sets are correct:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="n">node</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found an incorrect parent set&quot;</span><span class="p">)</span>
            <span class="c1"># ... and there are no duplicate parents:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="n">node</span><span class="p">])):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found duplicate parents&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">())</span>

<div class="viewcode-block" id="HistoryDag.get_histories">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.get_histories">[docs]</a>
    <span class="k">def</span> <span class="nf">get_histories</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a generator containing all histories in the history DAG.</span>

<span class="sd">        Note that each history is a tree-shaped history DAG, containing a UA node,</span>
<span class="sd">        which exists as a subgraph of the history DAG.</span>

<span class="sd">        The order of these histories does not necessarily match the order of</span>
<span class="sd">        indexing. That is, ``dag.get_histories()`` and ``history for history in</span>
<span class="sd">        dag`` will result in different orderings. ``get_histories`` should</span>
<span class="sd">        be slightly faster, but possibly more memory intensive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">history</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">_get_subhistories</span><span class="p">():</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">history</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.get_trees">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.get_trees">[docs]</a>
    <span class="k">def</span> <span class="nf">get_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deprecated name for :meth:`get_histories`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_histories</span><span class="p">()</span></div>


<div class="viewcode-block" id="HistoryDag.get_leaves">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.get_leaves">[docs]</a>
    <span class="k">def</span> <span class="nf">get_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a generator containing all leaf nodes in the history DAG.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nodes</span><span class="p">(</span><span class="n">HistoryDagNode</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.get_edges">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.get_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">get_edges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a generator containing all edges in the history DAG, as</span>
<span class="sd">        parent, child node tuples.</span>

<span class="sd">        Edges&#39; parent nodes will be in preorder.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">skip_ua_node</span><span class="o">=</span><span class="n">skip_ua_node</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.get_annotated_edges">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.get_annotated_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">get_annotated_edges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a generator containing all edges in the history DAG, and</span>
<span class="sd">        their weights and downward conditional edge probabilities.</span>

<span class="sd">        Yields ((parent, child), weight, probability) for each edge.</span>

<span class="sd">        Edges&#39; parent nodes will be in preorder.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">skip_ua_node</span><span class="o">=</span><span class="n">skip_ua_node</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="n">eset</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="p">((</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">),</span> <span class="n">weight</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.num_edges">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.num_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">num_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of edges in the DAG, including edges descending</span>
<span class="sd">        from the UA node, unless skip_ua_node is True.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edges</span><span class="p">(</span><span class="n">skip_ua_node</span><span class="o">=</span><span class="n">skip_ua_node</span><span class="p">))</span></div>


<div class="viewcode-block" id="HistoryDag.num_nodes">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.num_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">num_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of nodes in the DAG, not counting the UA node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div>


<div class="viewcode-block" id="HistoryDag.num_leaves">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.num_leaves">[docs]</a>
    <span class="k">def</span> <span class="nf">num_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of leaf nodes in the DAG.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">())</span></div>


<div class="viewcode-block" id="HistoryDag.find_nodes">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.find_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">find_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">filter_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a generator on (non-UA) nodes for which ``filter_func``</span>
<span class="sd">        evaluates to True.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">filter_func</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">node</span></div>


<div class="viewcode-block" id="HistoryDag.find_node">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.find_node">[docs]</a>
    <span class="k">def</span> <span class="nf">find_node</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">filter_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDagNode</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the first (non-UA) node for which ``filter_func`` evaluates</span>
<span class="sd">        to True.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find_nodes</span><span class="p">(</span><span class="n">filter_func</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No matching node found.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.fast_sample">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.fast_sample">[docs]</a>
    <span class="k">def</span> <span class="nf">fast_sample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tree_builder</span><span class="p">:</span> <span class="n">PreorderTreeBuilder</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">log_probabilities</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This is a non-recursive alternative to :meth:`HistoryDag.sample`,</span>
<span class="sd">        which is likely to be slower on small DAGs, but may allow significant</span>
<span class="sd">        optimizations on large DAGs, or in the case that the data format being</span>
<span class="sd">        sampled is something other than a tree-shaped HistoryDag object.</span>

<span class="sd">        This method does not provide an edge_selector argument like :meth:`HistoryDag.sample`.</span>
<span class="sd">        Instead, any masking of edges should be done prior to sampling using the :meth:`HistoryDag.set_sample_mask`</span>
<span class="sd">        method, or by modifying the arguments to :meth:`HistoryDag.probability_annotate`.</span>

<span class="sd">        Args:</span>
<span class="sd">            tree_builder: a PreorderTreeBuilder instance to handle construction of the sampled tree.</span>
<span class="sd">            log_probabilities: Whether edge probabilities annotated on this DAG (using, for example,</span>
<span class="sd">                :meth:`HistoryDag.probability_annotate`) are on a log-scale.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tree_builder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tree_builder</span> <span class="o">=</span> <span class="n">PreorderHistoryBuilder</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">get_sampled_children</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">sampled_target</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">eset</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">log_probabilities</span><span class="o">=</span><span class="n">log_probabilities</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">sampled_target</span>

        <span class="n">node_queue</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="p">,</span> <span class="n">tree_builder</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="p">))]</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">parent</span><span class="p">,</span> <span class="n">parent_repr</span> <span class="o">=</span> <span class="n">node_queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">get_sampled_children</span><span class="p">(</span><span class="n">parent</span><span class="p">):</span>
                <span class="n">child_repr</span> <span class="o">=</span> <span class="n">tree_builder</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent_repr</span><span class="p">)</span>
                <span class="n">node_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="n">child_repr</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">tree_builder</span><span class="o">.</span><span class="n">get_finished_tree</span><span class="p">()</span></div>


<div class="viewcode-block" id="HistoryDag.sample">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.sample">[docs]</a>
    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">edge_selector</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="n">log_probabilities</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Samples a history from the history DAG. (A history is a sub-history</span>
<span class="sd">        DAG containing the root and all leaf nodes) For reproducibility, set</span>
<span class="sd">        ``random.seed`` before sampling.</span>

<span class="sd">        When there is an option, edges pointing to nodes on which `edge_selector` is True</span>
<span class="sd">        will always be chosen.</span>

<span class="sd">        Returns a new HistoryDag object.</span>

<span class="sd">        To use the more general sampling pattern which allows an arbitrary PreorderTreeBuilder</span>
<span class="sd">        object, use :meth:`HistoryDag.fast_sample` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">_sample</span><span class="p">(</span>
                <span class="n">edge_selector</span><span class="o">=</span><span class="n">edge_selector</span><span class="p">,</span> <span class="n">log_probabilities</span><span class="o">=</span><span class="n">log_probabilities</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.nodes_above_node">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.nodes_above_node">[docs]</a>
    <span class="k">def</span> <span class="nf">nodes_above_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a set of nodes from which the passed node is reachable along</span>
<span class="sd">        directed edges.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
        <span class="n">mask_true</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">nodequeue</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">}</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodequeue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">curr_node</span> <span class="o">=</span> <span class="n">nodequeue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">curr_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mask_true</span><span class="p">:</span>
                <span class="n">nodequeue</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">curr_node</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span>
                <span class="n">mask_true</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mask_true</span></div>


<div class="viewcode-block" id="HistoryDag.sample_with_node">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.sample_with_node">[docs]</a>
    <span class="k">def</span> <span class="nf">sample_with_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Samples a history which contains ``node`` from the history DAG.</span>

<span class="sd">        Sampling is likely unbiased from the distribution of trees in</span>
<span class="sd">        the DAG, conditioned on each sampled tree containing the passed</span>
<span class="sd">        node. However, if unbiased sampling from the conditional</span>
<span class="sd">        distribution is important, this should be tested.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mask_true</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_above_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">edge_selector</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">edge</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">mask_true</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">edge_selector</span><span class="o">=</span><span class="n">edge_selector</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.sample_with_edge">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.sample_with_edge">[docs]</a>
    <span class="k">def</span> <span class="nf">sample_with_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Samples a history which contains ``edge`` (a tuple of</span>
<span class="sd">        HistoryDagNodes) from the history DAG.</span>

<span class="sd">        Sampling is likely unbiased from the distribution of trees in</span>
<span class="sd">        the DAG, conditioned on each sampled tree containing the passed</span>
<span class="sd">        edge. However, if unbiased sampling from the conditional</span>
<span class="sd">        distribution is important, this should be tested.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask_true</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_above_node</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">edge_selector</span><span class="p">(</span><span class="n">inedge</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">inedge</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">mask_true</span> <span class="ow">or</span> <span class="n">inedge</span> <span class="o">==</span> <span class="n">edge</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">edge_selector</span><span class="o">=</span><span class="n">edge_selector</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.iter_covering_histories">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.iter_covering_histories">[docs]</a>
    <span class="k">def</span> <span class="nf">iter_covering_histories</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cover_edges</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Samples a sequence of histories which together contain all nodes in</span>
<span class="sd">        the history DAG.</span>

<span class="sd">        Histories are sampled using :meth:`sample_with_node`, starting</span>
<span class="sd">        with the nodes which are contained in the fewest of the DAG&#39;s</span>
<span class="sd">        histories. The sequence of trees is therefore non-deterministic</span>
<span class="sd">        unless ``random.seed`` is set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_nodes</span><span class="p">()</span>
        <span class="n">node_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">node_counts</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">node_counts</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cover_edges</span><span class="p">:</span>
            <span class="n">part_list</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">node_list</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">()</span>
            <span class="p">]</span>
            <span class="n">sample_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_with_edge</span>

            <span class="k">def</span> <span class="nf">update_visited</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="nb">set</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">preorder</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">part_list</span> <span class="o">=</span> <span class="n">node_list</span>
            <span class="n">sample_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_with_node</span>

            <span class="k">def</span> <span class="nf">update_visited</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">preorder</span><span class="p">()))</span>

        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">part_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">part</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">tree</span> <span class="o">=</span> <span class="n">sample_func</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
                <span class="n">olen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span>
                <span class="n">update_visited</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="c1"># At least part must have been added.</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">olen</span>
                <span class="k">yield</span> <span class="n">tree</span></div>


<div class="viewcode-block" id="HistoryDag.unlabel">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.unlabel">[docs]</a>
    <span class="k">def</span> <span class="nf">unlabel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets all internal node labels to be identical, and merges nodes so</span>
<span class="sd">        that all histories in the DAG have unique topologies.&quot;&quot;&quot;</span>

        <span class="n">newdag</span> <span class="o">=</span> <span class="n">HistoryDag</span><span class="o">.</span><span class="n">from_history_dag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">model_label</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">label</span>
        <span class="c1"># initialize empty/default value for each item in model_label</span>
        <span class="c1"># Use placeholder Ellipsis, since None could have interpretation</span>
        <span class="c1"># in context of label field type.</span>
        <span class="n">field_values</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">Ellipsis</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">model_label</span><span class="p">)</span>
        <span class="n">internal_label</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">model_label</span><span class="p">)(</span><span class="o">*</span><span class="n">field_values</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">newdag</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">internal_label</span>

        <span class="c1"># Use merging method to eliminate duplicate nodes, by starting with</span>
        <span class="c1"># a subdag with no duplicate nodes.</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">newdag</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">newdag</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="HistoryDag.relabel">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.relabel">[docs]</a>
    <span class="k">def</span> <span class="nf">relabel</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">relabel_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="n">Label</span><span class="p">],</span> <span class="n">relax_type</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new HistoryDag with labels modified according to a provided</span>
<span class="sd">        function.</span>

<span class="sd">        Args:</span>
<span class="sd">            relabel_func: A function which takes a node and returns the new label</span>
<span class="sd">                appropriate for that node. The relabel_func should return a consistent</span>
<span class="sd">                NamedTuple type with name Label. That is, all returned labels</span>
<span class="sd">                should have matching `_fields` attribute.</span>
<span class="sd">                Method is only guaranteed to work when no two leaf nodes are</span>
<span class="sd">                mapped to the same new label. If this is not the case, this method may</span>
<span class="sd">                raise a warning or error, or may fail silently, returning an invalid</span>
<span class="sd">                HistoryDag.</span>
<span class="sd">            relax_type: Whether to require the returned HistoryDag to be of the same subclass as self.</span>
<span class="sd">                If True, the returned HistoryDag will be of the abstract type `HistoryDag`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_node_to_node_d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">node_to_node_d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">old_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="n">new_children</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">old_node_to_node_d</span><span class="p">[</span><span class="n">old_child</span><span class="p">]</span> <span class="k">for</span> <span class="n">old_child</span> <span class="ow">in</span> <span class="n">old_node</span><span class="o">.</span><span class="n">children</span><span class="p">()</span>
            <span class="p">]</span>
            <span class="n">child_clades</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">child</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">new_children</span><span class="p">})</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">child_clades</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_node</span><span class="o">.</span><span class="n">clades</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;relabel_func </span><span class="si">{</span><span class="n">relabel_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> maps multiple&quot;</span>
                    <span class="s2">&quot; leaf nodes to the same label. This is not supported&quot;</span>
                    <span class="s2">&quot; and may fail with an error or silently. If you ignore&quot;</span>
                    <span class="s2">&quot; this warning, at least run _check_valid() on the result&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">old_node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
                <span class="n">new_node</span> <span class="o">=</span> <span class="n">UANode</span><span class="p">(</span><span class="n">EdgeSet</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_node</span> <span class="o">=</span> <span class="n">HistoryDagNode</span><span class="p">(</span>
                    <span class="n">relabel_func</span><span class="p">(</span><span class="n">old_node</span><span class="p">),</span>
                    <span class="p">{</span><span class="n">clade</span><span class="p">:</span> <span class="n">EdgeSet</span><span class="p">()</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">child_clades</span><span class="p">},</span>
                    <span class="n">old_node</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">node_to_node_d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">new_node</span><span class="p">)</span>
            <span class="n">node_to_node_d</span><span class="p">[</span><span class="n">new_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span>

            <span class="n">old_node_to_node_d</span><span class="p">[</span><span class="n">old_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span>

            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">new_children</span><span class="p">:</span>
                <span class="n">new_node</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">prob_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Last node in postorder should be UA node</span>
        <span class="k">assert</span> <span class="n">new_node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="n">HistoryDag</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">relax_type</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">from_history_dag</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.add_label_fields">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.add_label_fields">[docs]</a>
    <span class="k">def</span> <span class="nf">add_label_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_field_names</span><span class="o">=</span><span class="p">[],</span> <span class="n">new_field_values</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a copy of the DAG in which each node&#39;s label is extended to</span>
<span class="sd">        include the new fields listed in `new_field_names`.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_field_names: A list of strings consisting of the names of the new fields to add.</span>
<span class="sd">            new_field_values: A callable that takes a node and returns the ordered list</span>
<span class="sd">                of values for each new field name to assign to that node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_label_type</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">field_name</span> <span class="ow">in</span> <span class="n">old_label</span><span class="o">.</span><span class="n">_fields</span> <span class="k">for</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">new_field_names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One or more field names are already found in the DAG&quot;</span><span class="p">)</span>
        <span class="n">new_label</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;new_label&quot;</span><span class="p">,</span> <span class="n">old_label</span><span class="o">.</span><span class="n">_fields</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_field_names</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">add_fields</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">updated_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_field_values</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_label</span><span class="p">(</span><span class="o">*</span><span class="n">updated_fields</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">add_fields</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.remove_label_fields">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.remove_label_fields">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_label_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fields_to_remove</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a copy of the DAG with the list of `fields_to_remove`</span>
<span class="sd">        dropped from each node&#39;s label.</span>

<span class="sd">        Args:</span>
<span class="sd">            fields_to_remove: A list of strings consisting of the names of the new fields to remove.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_label_type</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">old_label</span><span class="o">.</span><span class="n">_fields</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">fields_to_remove</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unlabel</span><span class="p">()</span>

        <span class="n">field_indices_to_keep</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">old_label</span><span class="o">.</span><span class="n">_fields</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fields_to_remove</span>
        <span class="p">]</span>
        <span class="n">new_label</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span>
            <span class="s2">&quot;new_label&quot;</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">old_label</span><span class="o">.</span><span class="n">_fields</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">field_indices_to_keep</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">update_fields</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">updated_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">field_indices_to_keep</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">new_label</span><span class="p">(</span><span class="o">*</span><span class="n">updated_fields</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">update_fields</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.update_label_fields">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.update_label_fields">[docs]</a>
    <span class="k">def</span> <span class="nf">update_label_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_names</span><span class="p">,</span> <span class="n">new_field_values</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Changes label field values to values returned by the function</span>
<span class="sd">        new_field_values. This method is not in-place, but returns a new DAG.</span>

<span class="sd">        Args:</span>
<span class="sd">            field_names: A list of strings containing names of label fields whose contents are to be modified</span>
<span class="sd">            new_field_values: A function taking a node and returning a tuple of field values whose order matches field_names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">label_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_label_type</span><span class="p">()</span>
        <span class="n">field_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span><span class="p">:</span> <span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">field</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">label_type</span><span class="o">.</span><span class="n">_fields</span><span class="p">)}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">update_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">field_dict</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">field_names</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;One of the field names you provided does not appear on node labels.&quot;</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">update_fields</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">old_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_field_values</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">new_val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">update_indices</span><span class="p">,</span> <span class="n">new_data</span><span class="p">):</span>
                <span class="n">old_data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_val</span>
            <span class="k">return</span> <span class="n">label_type</span><span class="p">(</span><span class="o">*</span><span class="n">old_data</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">update_fields</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.is_history">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.is_history">[docs]</a>
    <span class="k">def</span> <span class="nf">is_history</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns whether history DAG is a history.</span>

<span class="sd">        That is, each node-clade pair has exactly one descendant edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="HistoryDag.is_clade_tree">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.is_clade_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">is_clade_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deprecated name for :meth:`is_history`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_history</span><span class="p">()</span></div>


<div class="viewcode-block" id="HistoryDag.copy">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.copy">[docs]</a>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Uses bytestring serialization, and is guaranteed to copy:</span>

<span class="sd">        * node labels</span>
<span class="sd">        * node attr attributes</span>
<span class="sd">        * edge weights</span>
<span class="sd">        * edge probabilities</span>

<span class="sd">        However, other object attributes will not be copied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>


<div class="viewcode-block" id="HistoryDag.history_intersect">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.history_intersect">[docs]</a>
    <span class="k">def</span> <span class="nf">history_intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_dag</span><span class="p">:</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Modify this HistoryDag to contain only the histories which are also</span>
<span class="sd">        contained in ``reference_dag``.</span>

<span class="sd">        Args:</span>
<span class="sd">            reference_dag: The history DAG with which this one will be intersected. ``reference_dag``</span>
<span class="sd">                will not be modified.</span>
<span class="sd">            key: A function accepting a node and returning a value which will be used to compare</span>
<span class="sd">                nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">count_funcs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">edge_difference_funcs</span><span class="p">(</span><span class="n">reference_dag</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

        <span class="n">min_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim_optimal_weight</span><span class="p">(</span>
            <span class="n">optimal_func</span><span class="o">=</span><span class="nb">min</span><span class="p">,</span>
            <span class="o">**</span><span class="n">count_funcs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">min_weight</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">IntersectionError</span><span class="p">(</span>
                <span class="s2">&quot;Provided history DAGs have no histories in common,&quot;</span>
                <span class="s2">&quot; and a history DAG must contain at least one history.&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.shared_history_count">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.shared_history_count">[docs]</a>
    <span class="k">def</span> <span class="nf">shared_history_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_dag</span><span class="p">:</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Count the histories which are also contained in ``reference_dag``.</span>

<span class="sd">        Args:</span>
<span class="sd">            reference_dag: The history DAG with which this one will be intersected. ``reference_dag``</span>
<span class="sd">                will not be modified.</span>
<span class="sd">            key: A function accepting a node and returning a value which will be used to compare</span>
<span class="sd">                nodes.</span>
<span class="sd">        Returns:</span>
<span class="sd">            The number of histories shared between this history DAG and the reference.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count_funcs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">edge_difference_funcs</span><span class="p">(</span><span class="n">reference_dag</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
        <span class="n">optimal_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_optimal_histories</span><span class="p">(</span><span class="o">**</span><span class="n">count_funcs</span><span class="p">,</span> <span class="n">optimal_func</span><span class="o">=</span><span class="nb">min</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">optimal_count</span><span class="o">.</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># There are no histories whose edges are all in reference_dag</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">optimal_count</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.merge">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.merge">[docs]</a>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trees</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="s2">&quot;HistoryDag&quot;</span><span class="p">]]):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Graph union this history DAG with all those in a list of history</span>
<span class="sd">        DAGs.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">HistoryDag</span><span class="p">):</span>
            <span class="n">trees</span> <span class="o">=</span> <span class="p">[</span><span class="n">trees</span><span class="p">]</span>

        <span class="n">selforder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()</span>
        <span class="n">nodedict</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">selforder</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_fields</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">label_fields</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The given HistoryDag must contain identical label fields.</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">label_fields</span><span class="si">}</span><span class="se">\n</span><span class="s2">vs</span><span class="se">\n</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">label_fields</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">otherorder</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">postorder</span><span class="p">()</span>
            <span class="c1"># hash and __eq__ are implemented for nodes, but we need to retrieve</span>
            <span class="c1"># the actual instance that&#39;s the same as a proposed node-to-add:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">otherorder</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodedict</span><span class="p">:</span>
                    <span class="n">pnode</span> <span class="o">=</span> <span class="n">nodedict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pnode</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">()</span>
                    <span class="n">nodedict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pnode</span>

                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">edgeset</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">edgeset</span><span class="p">:</span>
                        <span class="n">pnode</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">nodedict</span><span class="p">[</span><span class="n">child</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.add_all_allowed_edges">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.add_all_allowed_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">add_all_allowed_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provided as a deprecated synonym for :meth:`make_complete`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_complete</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.make_complete">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.make_complete">[docs]</a>
    <span class="k">def</span> <span class="nf">make_complete</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_from_root</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">adjacent_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">preserve_parent_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Add all allowed edges to the DAG in place.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_from_root: If False, no edges will be added that start at the DAG root.</span>
<span class="sd">                Useful when attempting to constrain root label.</span>
<span class="sd">            adjacent_labels: If False, no edges will be added between nodes with the same</span>
<span class="sd">                labels. Useful when attempting to maintain the history DAG in a &#39;collapsed&#39;</span>
<span class="sd">                state.</span>
<span class="sd">            preserve_parent_labels: If True, ensures that for any edge added between a</span>
<span class="sd">                parent and child node, the parent node label was already among the original</span>
<span class="sd">                parent labels of the child node. This ensures that parsimony score is preserved.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The number of edges added to the history DAG</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_added</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">preserve_parent_labels</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
            <span class="n">uplabels</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">node</span><span class="p">:</span> <span class="p">{</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">}</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()</span>
            <span class="p">}</span>

        <span class="n">clade_dict</span> <span class="o">=</span> <span class="n">_clade_union_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">clade_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">new_from_root</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">clade_dict</span><span class="p">[</span><span class="n">clade</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">adjacent_labels</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">elif</span> <span class="p">(</span>
                            <span class="n">preserve_parent_labels</span> <span class="ow">is</span> <span class="kc">True</span>
                            <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">uplabels</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
                        <span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">n_added</span> <span class="o">+=</span> <span class="n">node</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n_added</span></div>


<div class="viewcode-block" id="HistoryDag.to_newick">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.to_newick">[docs]</a>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">_history_method</span>
    <span class="k">def</span> <span class="nf">to_newick</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;unnamed&quot;</span><span class="p">,</span>
        <span class="n">features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">feature_funcs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converts a history to extended newick format. Supports arbitrary</span>
<span class="sd">        node names and a sequence feature. For use on a history DAG which is a</span>
<span class="sd">        history.</span>

<span class="sd">        For extracting newick representations of trees in a general history DAG, see</span>
<span class="sd">        :meth:`HistoryDag.to_newicks`.</span>

<span class="sd">        Args:</span>
<span class="sd">            name_func: A map from nodes to newick node names</span>
<span class="sd">            features: A list of label field names to be included in extended newick data.</span>
<span class="sd">                If `None`, all label fields will be included. To include none of them,</span>
<span class="sd">                pass an empty list.</span>
<span class="sd">            feature_funcs: A dictionary keyed by extended newick field names, containing</span>
<span class="sd">                functions specifying how to populate that field for each node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A newick string. If `features` is an empty list, and feature_funcs is empty,</span>
<span class="sd">                then this will be a standard newick string. Otherwise, it will have ete3&#39;s</span>
<span class="sd">                extended newick format.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">newick</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">_newick_label</span><span class="p">(</span>
                    <span class="n">name_func</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span> <span class="n">feature_funcs</span><span class="o">=</span><span class="n">feature_funcs</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">childnewicks</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">newick</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span> <span class="k">for</span> <span class="n">node2</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">()])</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="s2">&quot;(&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">childnewicks</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                    <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">_newick_label</span><span class="p">(</span>
                        <span class="n">name_func</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span> <span class="n">feature_funcs</span><span class="o">=</span><span class="n">feature_funcs</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">newick</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">()))</span> <span class="o">+</span> <span class="s2">&quot;;&quot;</span></div>


<div class="viewcode-block" id="HistoryDag.to_ascii">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.to_ascii">[docs]</a>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">_history_method</span>
    <span class="k">def</span> <span class="nf">to_ascii</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_func</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A convenience function that uses the :meth:`to_ete` method and</span>
<span class="sd">        ete3&#39;s ASCII drawing tools to render a history.</span>

<span class="sd">        See :meth:`HistoryDagNode.to_ascii` for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">())</span><span class="o">.</span><span class="n">to_ascii</span><span class="p">(</span>
            <span class="n">name_func</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.to_ete">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.to_ete">[docs]</a>
    <span class="nd">@utils</span><span class="o">.</span><span class="n">_history_method</span>
    <span class="k">def</span> <span class="nf">to_ete</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;unnamed&quot;</span><span class="p">,</span>
        <span class="n">features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">feature_funcs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a history DAG which is a history to an ete tree.</span>

<span class="sd">        Args:</span>
<span class="sd">            name_func: A map from nodes to newick node names</span>
<span class="sd">            features: A list of label field names to be included in extended newick data.</span>
<span class="sd">                If `None`, all label fields will be included. To include none of them,</span>
<span class="sd">                pass an empty list.</span>
<span class="sd">            feature_funcs: A dictionary keyed by extended newick field names, containing</span>
<span class="sd">                functions specifying how to populate that field for each node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An ete3 Tree with the same topology as self, and node names and attributes</span>
<span class="sd">            as specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First build a dictionary of ete3 nodes keyed by HDagNodes.</span>
        <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">tree_builder</span> <span class="o">=</span> <span class="n">EteTreeBuilder</span><span class="p">(</span>
            <span class="n">name_func</span><span class="o">=</span><span class="n">name_func</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span> <span class="n">feature_funcs</span><span class="o">=</span><span class="n">feature_funcs</span>
        <span class="p">)</span>
        <span class="n">nodes_to_process</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="p">,</span> <span class="n">tree_builder</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="p">))]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes_to_process</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">node_repr</span> <span class="o">=</span> <span class="n">nodes_to_process</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                <span class="n">nodes_to_process</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">tree_builder</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">node_repr</span><span class="p">))</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">tree_builder</span><span class="o">.</span><span class="n">get_finished_tree</span><span class="p">()</span></div>


<div class="viewcode-block" id="HistoryDag.to_graphviz">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.to_graphviz">[docs]</a>
    <span class="k">def</span> <span class="nf">to_graphviz</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labelfunc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">namedict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Label</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">show_child_clades</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_partitions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">level_leaves</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">graph_attr</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">node_attr</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">edge_attr</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">edge_attr_inheritance</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
        <span class="n">show_edge_probs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">show_edge_weights</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gv</span><span class="o">.</span><span class="n">Digraph</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converts history DAG to graphviz (dot format) Digraph object.</span>

<span class="sd">        Args:</span>
<span class="sd">            labelfunc: A function to label nodes. If None, nodes will be labeled by</span>
<span class="sd">                their DAG node labels, or their label hash if label data is too large.</span>
<span class="sd">            namedict: A dictionary from node labels to label strings. Labelfunc will be</span>
<span class="sd">                used instead, if both are provided.</span>
<span class="sd">            show_child_clades: Whether to include child clades in output.</span>
<span class="sd">            show_partitions: Deprecated alias for show_child_clades.</span>
<span class="sd">            level_leaves: Whether to draw leaves on the same level, or wherever they fall naturally.</span>
<span class="sd">            graph_attr: Additional graphviz graph attributes (see graphviz docs)</span>
<span class="sd">            node_attr: Additional graphviz node attributes (see graphviz docs)</span>
<span class="sd">            edge_attr: Additional graphviz edge attributes (see graphviz docs)</span>
<span class="sd">            edge_attr_inheritance: &quot;parent&quot; to inherit from parent node, &quot;child&quot; to inherit from child, or &quot;none&quot;.</span>
<span class="sd">            show_edge_probs: whether to show edge probabilities</span>
<span class="sd">            show_edge_weights: whether to show edge weights</span>

<span class="sd">        Notes:</span>
<span class="sd">            Graphviz dot format attributes are documented at https://graphviz.org/doc/info/attrs.html</span>
<span class="sd">            The graphviz attributes passed to this method are for the entire graph. Attributes for</span>
<span class="sd">            individual nodes can be included in individual node attr dictionaries under the key ``gv_attrs``.</span>
<span class="sd">            For example, ``node.attr[&#39;gv_attrs&#39;] = {&#39;color&#39;: &#39;red&#39;}`` will color a node red in the graphviz</span>
<span class="sd">            output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">show_partitions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">show_child_clades</span> <span class="o">=</span> <span class="n">show_partitions</span>

        <span class="k">def</span> <span class="nf">labeller</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">namedict</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">namedict</span><span class="p">[</span><span class="n">label</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">UALabel</span><span class="p">):</span>
                <span class="k">return</span> <span class="s2">&quot;UA_node&quot;</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">label</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mi">11</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">labelfunc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">labelfunc</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">labeller</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">taxa</span><span class="p">(</span><span class="n">clade</span><span class="p">):</span>
            <span class="n">ls</span> <span class="o">=</span> <span class="p">[</span><span class="n">labeller</span><span class="p">(</span><span class="n">taxon</span><span class="p">)</span> <span class="k">for</span> <span class="n">taxon</span> <span class="ow">in</span> <span class="n">clade</span><span class="p">]</span>
            <span class="n">ls</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">return</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">gv_attrs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;gv_attrs&quot;</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attr</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s2">&quot;gv_attrs&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">gv_edge_attrs</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">edge_attr_inheritance</span> <span class="o">==</span> <span class="s2">&quot;parent&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">gv_attrs</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">edge_attr_inheritance</span> <span class="o">==</span> <span class="s2">&quot;child&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">gv_attrs</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">_node_attr</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="s2">&quot;record&quot;</span><span class="p">}</span>
        <span class="n">_node_attr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">node_attr</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">Digraph</span><span class="p">(</span>
            <span class="s2">&quot;labeled partition DAG&quot;</span><span class="p">,</span>
            <span class="n">graph_attr</span><span class="o">=</span><span class="n">graph_attr</span><span class="p">,</span>
            <span class="n">edge_attr</span><span class="o">=</span><span class="n">edge_attr</span><span class="p">,</span>
            <span class="n">node_attr</span><span class="o">=</span><span class="n">_node_attr</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">leaves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()</span>
        <span class="n">internal_nodes</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">())</span>
        <span class="k">with</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">()</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">level_leaves</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">rank</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)),</span> <span class="sa">f</span><span class="s2">&quot;&lt;label&gt; </span><span class="si">{</span><span class="n">labelfunc</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">gv_attrs</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">internal_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()</span> <span class="ow">or</span> <span class="n">show_child_clades</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)),</span> <span class="sa">f</span><span class="s2">&quot;&lt;label&gt; </span><span class="si">{</span><span class="n">labelfunc</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">gv_attrs</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">splits</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="n">taxa</span><span class="p">(</span><span class="n">clade</span><span class="p">)</span><span class="si">}</span><span class="s2">&gt; </span><span class="si">{</span><span class="n">taxa</span><span class="p">(</span><span class="n">clade</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)),</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">{{</span><span class="s2"> &lt;label&gt; </span><span class="si">{</span><span class="n">labelfunc</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2"> |</span><span class="se">{{</span><span class="si">{</span><span class="n">splits</span><span class="si">}</span><span class="se">}}</span><span class="s2"> </span><span class="se">}}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">gv_attrs</span><span class="p">(</span><span class="n">node</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="k">if</span> <span class="n">show_edge_probs</span><span class="p">:</span>
                        <span class="n">label</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;p:</span><span class="si">{</span><span class="n">prob</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="n">show_edge_weights</span><span class="p">:</span>
                        <span class="n">label</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;w:</span><span class="si">{</span><span class="n">weight</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">taxa</span><span class="p">(</span><span class="n">clade</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">show_child_clades</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;label&#39;</span><span class="si">}</span><span class="s2">:s&quot;</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s2">:n&quot;</span><span class="p">,</span>
                        <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">gv_edge_attrs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">target</span><span class="p">),</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="HistoryDag.internal_avg_parents">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.internal_avg_parents">[docs]</a>
    <span class="k">def</span> <span class="nf">internal_avg_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the average number of parents among internal nodes.</span>

<span class="sd">        A simple measure of similarity between the trees that the DAG</span>
<span class="sd">        expresses. However, keep in mind that two trees with the same</span>
<span class="sd">        topology but different labels would be considered entirely</span>
<span class="sd">        unalike by this measure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nonleaf_parents</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">())</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cumsum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="nb">sum</span> <span class="ow">in</span> <span class="n">nonleaf_parents</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">cumsum</span> <span class="o">+=</span> <span class="nb">sum</span>
        <span class="c1"># Exclude root:</span>
        <span class="k">return</span> <span class="n">cumsum</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.explode_nodes">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.explode_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">explode_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">expand_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
            <span class="p">[</span><span class="n">Label</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Label</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">parsimony_utils</span><span class="o">.</span><span class="n">default_nt_transitions</span><span class="o">.</span><span class="n">ambiguity_map</span><span class="o">.</span><span class="n">get_sequence_resolution_func</span><span class="p">(</span>
            <span class="s2">&quot;sequence&quot;</span>
        <span class="p">),</span>
        <span class="n">expand_node_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Label</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">expandable_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Explode nodes according to a provided function. Adds copies of each</span>
<span class="sd">        node to the DAG with exploded labels, but with the same parents and</span>
<span class="sd">        children as the original node.</span>

<span class="sd">        Args:</span>
<span class="sd">            expand_func: (Deprecated) A function that takes a node label, and returns an iterable</span>
<span class="sd">                containing &#39;exploded&#39; or &#39;disambiguated&#39; labels corresponding to the original.</span>
<span class="sd">                The wrapper :meth:`utils.explode_label` is provided to make such a function</span>
<span class="sd">                easy to write.</span>
<span class="sd">            expand_node_func: A function that takes a node and returns an iterable</span>
<span class="sd">                containing &#39;exploded&#39; or &#39;disambiguated&#39; labels corresponding to the</span>
<span class="sd">                node. If provided, expand_func will be ignored.</span>
<span class="sd">            expandable_func: A function that takes a node label, and returns whether the</span>
<span class="sd">                iterable returned by calling expand_func on that label would contain more</span>
<span class="sd">                than one item.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The number of new nodes added to the history DAG.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">expand_node_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">expand_node_func</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">expand_func</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">expandable_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">is_ambiguous</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="c1"># Check if expand_func(label) has at least two items, without</span>
                <span class="c1"># exhausting the (arbitrarily expensive) generator</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">expand_node_func</span><span class="p">(</span><span class="n">node</span><span class="p">))))</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">is_ambiguous</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">expandable_func</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
        <span class="n">nodedict</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()}</span>
        <span class="n">nodeorder</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())</span>
        <span class="n">new_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodeorder</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span> <span class="ow">and</span> <span class="n">is_ambiguous</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">resolution</span> <span class="ow">in</span> <span class="n">expand_node_func</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                    <span class="n">newnodetemp</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">()</span>
                    <span class="n">newnodetemp</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">resolution</span>
                    <span class="k">if</span> <span class="n">newnodetemp</span> <span class="ow">in</span> <span class="n">nodedict</span><span class="p">:</span>
                        <span class="n">newnode</span> <span class="o">=</span> <span class="n">nodedict</span><span class="p">[</span><span class="n">newnodetemp</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">newnode</span> <span class="o">=</span> <span class="n">newnodetemp</span>
                        <span class="n">nodedict</span><span class="p">[</span><span class="n">newnode</span><span class="p">]</span> <span class="o">=</span> <span class="n">newnode</span>
                        <span class="n">new_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
                    <span class="c1"># Add all edges into and out of node to newnode</span>
                    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                        <span class="n">newnode</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">):</span>
                        <span class="n">parent</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
                <span class="c1"># Delete old node</span>
                <span class="n">node</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">nodedict</span><span class="o">=</span><span class="n">nodedict</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.leaf_path_uncertainty_dag">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.leaf_path_uncertainty_dag">[docs]</a>
    <span class="k">def</span> <span class="nf">leaf_path_uncertainty_dag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terminal_node</span><span class="p">,</span> <span class="n">node_data_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a DAG of possible paths leading to `terminal_node`</span>

<span class="sd">        Args:</span>
<span class="sd">            terminal_node: The returned path DAG will contain all paths from the</span>
<span class="sd">                UA node ending at this node.</span>
<span class="sd">            node_data_func: A function accepting a HistoryDagNode and returning</span>
<span class="sd">                data for the corresponding node in the path dag. Return type must</span>
<span class="sd">                be a valid dictionary key.</span>
<span class="sd">        Returns:</span>
<span class="sd">            child_dictionary: A dictionary keyed by return values of</span>
<span class="sd">            `node_data_func`, with each value a dictionary keyed by child nodes,</span>
<span class="sd">            with edge supports as values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
        <span class="n">edge_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_edges</span><span class="p">()</span>
        <span class="n">child_dictionary</span> <span class="o">=</span> <span class="p">{</span><span class="n">node_data_func</span><span class="p">(</span><span class="n">terminal_node</span><span class="p">):</span> <span class="nb">dict</span><span class="p">()}</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_above</span><span class="p">(</span><span class="n">terminal_node</span><span class="p">,</span> <span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="c1"># Traversal has not visited node, or any of its children yet!</span>
            <span class="n">node_key</span> <span class="o">=</span> <span class="n">node_data_func</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">child_dictionary</span><span class="p">[</span><span class="n">node_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">parent</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
                    <span class="n">parent_key</span> <span class="o">=</span> <span class="n">node_data_func</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                    <span class="n">parent_entry</span> <span class="o">=</span> <span class="n">child_dictionary</span><span class="p">[</span><span class="n">parent_key</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">node_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parent_entry</span><span class="p">:</span>
                        <span class="n">parent_entry</span><span class="p">[</span><span class="n">node_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_counts</span><span class="p">[(</span><span class="n">parent</span><span class="p">,</span> <span class="n">node</span><span class="p">)]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">parent_entry</span><span class="p">[</span><span class="n">node_key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">edge_counts</span><span class="p">[(</span><span class="n">parent</span><span class="p">,</span> <span class="n">node</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">child_dictionary</span></div>


<div class="viewcode-block" id="HistoryDag.leaf_path_uncertainty_graphviz">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.leaf_path_uncertainty_graphviz">[docs]</a>
    <span class="k">def</span> <span class="nf">leaf_path_uncertainty_graphviz</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">terminal_node</span><span class="p">,</span>
        <span class="n">node_data_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="p">,</span>
        <span class="n">node_label_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">),</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a graphviz DAG of possible paths leading to `terminal_node`</span>

<span class="sd">        Args:</span>
<span class="sd">            terminal_node: The returned path DAG will contain all paths from the</span>
<span class="sd">                UA node ending at this node.</span>
<span class="sd">            node_data_func: A function accepting a HistoryDagNode and returning</span>
<span class="sd">                data for the corresponding node in the path dag. Return type must</span>
<span class="sd">                be a valid dictionary key.</span>
<span class="sd">            node_label_func: A function accepting an object of the type returned</span>
<span class="sd">                by `node_data_func`, and returning a label to be displayed on the</span>
<span class="sd">                corresponding node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total_trees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">Digraph</span><span class="p">(</span><span class="s2">&quot;Path DAG to leaf&quot;</span><span class="p">,</span> <span class="n">node_attr</span><span class="o">=</span><span class="p">{})</span>
        <span class="n">child_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_path_uncertainty_dag</span><span class="p">(</span>
            <span class="n">terminal_node</span><span class="p">,</span> <span class="n">node_data_func</span><span class="o">=</span><span class="n">node_data_func</span>
        <span class="p">)</span>

        <span class="n">label_ids</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">idnum</span><span class="p">)</span> <span class="k">for</span> <span class="n">idnum</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">child_d</span><span class="p">)}</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="p">{</span><span class="n">node_data_func</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">()}</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">child_d</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">source_nodes</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">(</span>
                    <span class="n">label_ids</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">node_label_func</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="s2">&quot;invtriangle&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">child_d</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">label_ids</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">node_label_func</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="s2">&quot;octagon&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">label_ids</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">node_label_func</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child_edge_d</span> <span class="ow">in</span> <span class="n">child_d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">support</span> <span class="ow">in</span> <span class="n">child_edge_d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">parent</span> <span class="o">==</span> <span class="n">child</span><span class="p">:</span>  <span class="c1"># skip self-edges</span>
                    <span class="k">continue</span>
                <span class="c1"># Shifts color pallete to less extreme lower bouund</span>
                <span class="n">color</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;0.0000 </span><span class="si">{</span><span class="n">support</span><span class="o">/</span><span class="n">total_trees</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.9</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.1</span><span class="si">}</span><span class="s2"> 1.000&quot;</span>
                <span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span>
                    <span class="n">label_ids</span><span class="p">[</span><span class="n">parent</span><span class="p">],</span>
                    <span class="n">label_ids</span><span class="p">[</span><span class="n">child</span><span class="p">],</span>
                    <span class="n">penwidth</span><span class="o">=</span><span class="s2">&quot;5&quot;</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">support</span><span class="o">/</span><span class="n">total_trees</span><span class="si">:</span><span class="s2">.2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">weight</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">support</span><span class="o">/</span><span class="n">total_trees</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="HistoryDag.summary">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.summary">[docs]</a>
    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print summary info about the history DAG.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Label fields:</span><span class="se">\t</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_label_type</span><span class="p">()</span><span class="o">.</span><span class="n">_fields</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nodes:</span><span class="se">\t</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Edges:</span><span class="se">\t</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Histories:</span><span class="se">\t</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unique leaves in DAG:</span><span class="se">\t</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Average number of parents of internal nodes:</span><span class="se">\t</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">internal_avg_parents</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">In histories in the DAG:&quot;</span><span class="p">)</span>
        <span class="n">min_leaves</span><span class="p">,</span> <span class="n">max_leaves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_range_annotate</span><span class="p">(</span>
            <span class="n">edge_weight_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">:</span> <span class="n">n2</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Leaf node count range: </span><span class="si">{</span><span class="n">min_leaves</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">max_leaves</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">min_nodes</span><span class="p">,</span> <span class="n">max_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_range_annotate</span><span class="p">(</span><span class="o">**</span><span class="n">utils</span><span class="o">.</span><span class="n">node_countfuncs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total node count range: </span><span class="si">{</span><span class="n">min_nodes</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">max_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Average pairwise RF distance:</span><span class="se">\t</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">average_pairwise_rf_distance</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.label_uncertainty_summary">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.label_uncertainty_summary">[docs]</a>
    <span class="k">def</span> <span class="nf">label_uncertainty_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print information about internal nodes which have the same child</span>
<span class="sd">        clades but different labels.&quot;&quot;&quot;</span>
        <span class="n">duplicates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">Counter</span><span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">child_clades</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span>
            <span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Mean unique labels per unique child clade set:&quot;</span><span class="p">,</span>
            <span class="nb">sum</span><span class="p">(</span><span class="n">duplicates</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">duplicates</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximum duplication:&quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">duplicates</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Counts of duplication numbers by unique child clade set:&quot;</span><span class="p">,</span>
            <span class="n">Counter</span><span class="p">(</span><span class="n">duplicates</span><span class="p">),</span>
        <span class="p">)</span></div>


    <span class="c1"># ######## Abstract dp method and derivatives: ########</span>

<div class="viewcode-block" id="HistoryDag.postorder_history_accum">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.postorder_history_accum">[docs]</a>
    <span class="k">def</span> <span class="nf">postorder_history_accum</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">leaf_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">],</span>
        <span class="n">edge_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">],</span>
        <span class="n">accum_within_clade</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">],</span>
        <span class="n">accum_between_clade</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">],</span>
        <span class="n">accum_above_edge</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Weight</span><span class="p">,</span> <span class="n">Weight</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">compute_edge_probabilities</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">normalize_edgeweights</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Weight</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A template method for leaf-to-root dynamic programming.</span>

<span class="sd">        Intermediate computations are stored in a `_dp_data` attribute on each node.</span>
<span class="sd">        Note that a `Weight` can be whatever you like, such as integers, Counters,</span>
<span class="sd">        strings, or dictionaries.</span>

<span class="sd">        Args:</span>
<span class="sd">            leaf_func: A function to assign weights to leaf nodes</span>
<span class="sd">            edge_func: A function to assign weights to edges. The parent node will</span>
<span class="sd">                always be the first argument.</span>
<span class="sd">            accum_within_clade: A function which accumulates a list of weights of subtrees</span>
<span class="sd">                below a single clade. That is, the weights are for alternative trees.</span>
<span class="sd">            accum_between_clade: A function which accumulates a list of weights of subtrees</span>
<span class="sd">                below different clades. That is, the weights are for different parts of the</span>
<span class="sd">                same tree.</span>
<span class="sd">            accum_above_edge: A function which adds the weight for a subtree to the weight</span>
<span class="sd">                of the edge above it. If `None`, this function will be inferred from</span>
<span class="sd">                `accum_between_clade`. The edge weight is the second argument.</span>
<span class="sd">            compute_edge_probabilities: If True, compute downward-conditional edge probabilities,</span>
<span class="sd">                proportional to aggregated subtree weights below and including each edge</span>
<span class="sd">                descending from a node-clade pair.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The resulting weight computed for the History DAG UA (root) node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">accum_above_edge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">default_accum_above_edge</span><span class="p">(</span><span class="n">subtree_weight</span><span class="p">,</span> <span class="n">edge_weight</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">accum_between_clade</span><span class="p">([</span><span class="n">subtree_weight</span><span class="p">,</span> <span class="n">edge_weight</span><span class="p">])</span>

            <span class="n">accum_above_edge</span> <span class="o">=</span> <span class="n">default_accum_above_edge</span>

        <span class="k">if</span> <span class="n">compute_edge_probabilities</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">normalize_edgeweights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                <span class="k">def</span> <span class="nf">accum_from_clade</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">clade</span><span class="p">):</span>
                    <span class="n">edge_weights</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">accum_above_edge</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">_dp_data</span><span class="p">,</span> <span class="n">edge_func</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">clade</span><span class="o">=</span><span class="n">clade</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="n">accumulated</span> <span class="o">=</span> <span class="n">accum_within_clade</span><span class="p">(</span><span class="n">edge_weights</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span><span class="o">.</span><span class="n">set_edge_stats</span><span class="p">(</span>
                        <span class="n">probs</span><span class="o">=</span><span class="p">[</span><span class="n">wt</span> <span class="o">/</span> <span class="n">accumulated</span> <span class="k">for</span> <span class="n">wt</span> <span class="ow">in</span> <span class="n">edge_weights</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">return</span> <span class="n">accumulated</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">def</span> <span class="nf">accum_from_clade</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">clade</span><span class="p">):</span>
                    <span class="n">edge_weights</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">accum_above_edge</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">_dp_data</span><span class="p">,</span> <span class="n">edge_func</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">clade</span><span class="o">=</span><span class="n">clade</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="n">accumulated</span> <span class="o">=</span> <span class="n">accum_within_clade</span><span class="p">(</span><span class="n">edge_weights</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span><span class="o">.</span><span class="n">set_edge_stats</span><span class="p">(</span>
                        <span class="n">probs</span><span class="o">=</span><span class="n">normalize_edgeweights</span><span class="p">(</span><span class="n">edge_weights</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">return</span> <span class="n">accumulated</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">accum_from_clade</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">clade</span><span class="p">):</span>
                <span class="n">edge_weights</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">accum_above_edge</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">_dp_data</span><span class="p">,</span> <span class="n">edge_func</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">clade</span><span class="o">=</span><span class="n">clade</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="k">return</span> <span class="n">accum_within_clade</span><span class="p">(</span><span class="n">edge_weights</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">node</span><span class="o">.</span><span class="n">_dp_data</span> <span class="o">=</span> <span class="n">leaf_func</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">_dp_data</span> <span class="o">=</span> <span class="n">accum_between_clade</span><span class="p">(</span>
                    <span class="c1"># sum over clades below node</span>
                    <span class="p">[</span><span class="n">accum_from_clade</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">clade</span><span class="p">)</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">_dp_data</span></div>


<div class="viewcode-block" id="HistoryDag.postorder_cladetree_accum">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.postorder_cladetree_accum">[docs]</a>
    <span class="k">def</span> <span class="nf">postorder_cladetree_accum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Weight</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deprecated name for :meth:`HistoryDag.postorder_history_accum`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_history_accum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.optimal_weight_annotate">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.optimal_weight_annotate">[docs]</a>
    <span class="nd">@get_default_args</span><span class="p">([</span><span class="s2">&quot;start_func&quot;</span><span class="p">,</span> <span class="s2">&quot;edge_weight_func&quot;</span><span class="p">,</span> <span class="s2">&quot;accum_func&quot;</span><span class="p">,</span> <span class="s2">&quot;optimal_func&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">optimal_weight_annotate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">accum_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">optimal_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Weight</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A template method for finding the optimal tree weight in the DAG.</span>
<span class="sd">        Dynamically annotates each node in the DAG with the optimal weight of a</span>
<span class="sd">        clade sub-tree beneath it, so that the DAG root node is annotated with</span>
<span class="sd">        the optimal weight of a history in the DAG.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_func: A function which assigns starting weights to leaves.</span>
<span class="sd">            edge_weight_func: A function which assigns weights to DAG edges based on the</span>
<span class="sd">                parent node and the child node, in that order.</span>
<span class="sd">            accum_func: A function which takes a list of weights of different parts of a</span>
<span class="sd">                tree, and returns a weight, like sum.</span>
<span class="sd">            optimal_func: A function which takes a list of weights and returns the optimal</span>
<span class="sd">                one, like min.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The optimal weight of a tree under the DAG UA node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_history_accum</span><span class="p">(</span>
            <span class="n">start_func</span><span class="p">,</span>
            <span class="n">edge_weight_func</span><span class="p">,</span>
            <span class="n">optimal_func</span><span class="p">,</span>
            <span class="n">accum_func</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.count_optimal_histories">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.count_optimal_histories">[docs]</a>
    <span class="nd">@get_default_args</span><span class="p">([</span><span class="s2">&quot;start_func&quot;</span><span class="p">,</span> <span class="s2">&quot;edge_weight_func&quot;</span><span class="p">,</span> <span class="s2">&quot;accum_func&quot;</span><span class="p">,</span> <span class="s2">&quot;optimal_func&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">count_optimal_histories</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">accum_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">optimal_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">eq_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Weight</span><span class="p">,</span> <span class="n">Weight</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">:</span> <span class="n">w1</span> <span class="o">==</span> <span class="n">w2</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Count the number of histories which would be left if the DAG were</span>
<span class="sd">        trimmed.</span>

<span class="sd">        That is, how many histories would be left if :meth:`HistoryDag.trim_optimal_weight`</span>
<span class="sd">        were called with the same arguments?</span>

<span class="sd">        Args:</span>
<span class="sd">            All arguments are the same as :meth:`HistoryDag.trim_optimal_weight`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A :class:`utils.IntState` object containing the number of optimal histories</span>
<span class="sd">            in the DAG, with ``state`` attribute containing their (optimal) weight.</span>

<span class="sd">            As a side-effect, each node&#39;s ``_dp_data`` attribute is populated with</span>
<span class="sd">            IntState objects containing the number of optimal sub-histories rooted at that</span>
<span class="sd">            node, and the weight of those sub-histories.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_start_func</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">IntState</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">start_func</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">_edge_weight_func</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">IntState</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">edge_weight_func</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">_between_clade_accum</span><span class="p">(</span><span class="n">clade_weight_list</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">IntState</span><span class="p">(</span>
                <span class="n">prod</span><span class="p">(</span><span class="n">clade_weight_list</span><span class="p">),</span>
                <span class="n">state</span><span class="o">=</span><span class="n">accum_func</span><span class="p">([</span><span class="n">el</span><span class="o">.</span><span class="n">state</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">clade_weight_list</span><span class="p">]),</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">_within_clade_accum</span><span class="p">(</span><span class="n">subtree_weight_list</span><span class="p">):</span>
            <span class="n">optimal_weight</span> <span class="o">=</span> <span class="n">optimal_func</span><span class="p">([</span><span class="n">el</span><span class="o">.</span><span class="n">state</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">subtree_weight_list</span><span class="p">])</span>
            <span class="n">count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">subtree_weight_list</span> <span class="k">if</span> <span class="n">eq_func</span><span class="p">(</span><span class="n">optimal_weight</span><span class="p">,</span> <span class="n">el</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">IntState</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">optimal_weight</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_history_accum</span><span class="p">(</span>
            <span class="n">_start_func</span><span class="p">,</span>
            <span class="n">_edge_weight_func</span><span class="p">,</span>
            <span class="n">_within_clade_accum</span><span class="p">,</span>
            <span class="n">_between_clade_accum</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.sum_weights">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.sum_weights">[docs]</a>
    <span class="nd">@get_default_args</span><span class="p">([</span><span class="s2">&quot;edge_weight_func&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">sum_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;For weights which are a sum over edges, compute the sum of all tree</span>
<span class="sd">        weights in the DAG.&quot;&quot;&quot;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_edges</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="n">count</span> <span class="o">*</span> <span class="n">edge_weight_func</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">),</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">)</span></div>


    <span class="nd">@get_default_args</span><span class="p">([</span><span class="s2">&quot;edge_weight_func&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">mean_history_weight</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_weights</span><span class="p">(</span><span class="n">edge_weight_func</span><span class="o">=</span><span class="n">edge_weight_func</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>

<div class="viewcode-block" id="HistoryDag.weight_count">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.weight_count">[docs]</a>
    <span class="nd">@get_default_args</span><span class="p">([</span><span class="s2">&quot;start_func&quot;</span><span class="p">,</span> <span class="s2">&quot;edge_weight_func&quot;</span><span class="p">,</span> <span class="s2">&quot;accum_func&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">weight_count</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">accum_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A template method for counting weights of trees expressed in the</span>
<span class="sd">        history DAG.</span>

<span class="sd">        Weights must be hashable, but may otherwise be of arbitrary type.</span>

<span class="sd">        Default arguments are contained in this HistoryDag subclass&#39;s _default_args</span>
<span class="sd">        variable, and are documented in the subclass docstring.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_func: A function which assigns a weight to each leaf node</span>
<span class="sd">            edge_weight_func: A function which assigns a weight to pairs of labels, with the</span>
<span class="sd">                parent node label the first argument</span>
<span class="sd">            accum_func: A way to &#39;add&#39; a list of weights together</span>

<span class="sd">        Returns:</span>
<span class="sd">            A Counter keyed by weights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_history_accum</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">Counter</span><span class="p">([</span><span class="n">start_func</span><span class="p">(</span><span class="n">n</span><span class="p">)]),</span>
            <span class="k">lambda</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">:</span> <span class="n">Counter</span><span class="p">([</span><span class="n">edge_weight_func</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)]),</span>
            <span class="n">counter_sum</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">counter_prod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">accum_func</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.weight_range_annotate">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.weight_range_annotate">[docs]</a>
    <span class="nd">@get_default_args</span><span class="p">([</span><span class="s2">&quot;start_func&quot;</span><span class="p">,</span> <span class="s2">&quot;edge_weight_func&quot;</span><span class="p">,</span> <span class="s2">&quot;accum_func&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">weight_range_annotate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">accum_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">,</span>
        <span class="n">max_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the minimum and maximum weight of any history in the</span>
<span class="sd">        history DAG.</span>

<span class="sd">        As a side-effect, this method also stores in each node&#39;s ``_dp_data`` attribute</span>
<span class="sd">        a tuple containing the minimum and maximum weights of any sub-history beneath that node.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_func: A function which assigns a weight to each leaf node</span>
<span class="sd">            edge__weight_func: A function which assigns a weight to pairs of labels, with the</span>
<span class="sd">                parent node label the first argument</span>
<span class="sd">            accum_func: A way to &#39;add&#39; a list of weights together</span>
<span class="sd">            min_func: A function which takes a list of weights and returns their &quot;minimum&quot;</span>
<span class="sd">            max_func: A function which takes a list of weights and returns their &quot;maximum&quot;</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple containing the minimum and maximum weight of any history in the history DAG.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">single_kwarg</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">AddFuncDict</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;start_func&quot;</span><span class="p">:</span> <span class="n">start_func</span><span class="p">,</span>
                <span class="s2">&quot;edge_weight_func&quot;</span><span class="p">:</span> <span class="n">edge_weight_func</span><span class="p">,</span>
                <span class="s2">&quot;accum_func&quot;</span><span class="p">:</span> <span class="n">accum_func</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Weight&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">pair_kwarg</span> <span class="o">=</span> <span class="n">single_kwarg</span> <span class="o">+</span> <span class="n">single_kwarg</span>

        <span class="k">def</span> <span class="nf">accum_within_clade</span><span class="p">(</span><span class="n">weight_list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">min_func</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">weight_list</span><span class="p">]),</span>
                <span class="n">max_func</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">weight_list</span><span class="p">]),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimal_weight_annotate</span><span class="p">(</span>
            <span class="n">optimal_func</span><span class="o">=</span><span class="n">accum_within_clade</span><span class="p">,</span> <span class="o">**</span><span class="n">pair_kwarg</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.hamming_parsimony_count">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.hamming_parsimony_count">[docs]</a>
    <span class="k">def</span> <span class="nf">hamming_parsimony_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deprecated in favor of</span>
<span class="sd">        :meth:`sequence_dag.SequenceHistoryDag.hamming_parsimony_count`.&quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;`HistoryDag.hamming_parsimony_count` is deprecated in favor of&quot;</span>
            <span class="s2">&quot; `sequence_dag.SequenceHistoryDag.hamming_parsimony_count`.&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_count</span><span class="p">()</span></div>


<div class="viewcode-block" id="HistoryDag.to_newicks">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.to_newicks">[docs]</a>
    <span class="k">def</span> <span class="nf">to_newicks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of extended newick strings formed with label fields.</span>

<span class="sd">        Arguments are passed to :meth:`utils.make_newickcountfuncs`.</span>
<span class="sd">        Arguments are the same as for</span>
<span class="sd">        :meth:`historydag.HistoryDag.to_newick`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newicks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_count</span><span class="p">(</span><span class="o">**</span><span class="n">utils</span><span class="o">.</span><span class="n">make_newickcountfuncs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span><span class="o">.</span><span class="n">elements</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">newick</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;;&quot;</span> <span class="k">for</span> <span class="n">newick</span> <span class="ow">in</span> <span class="n">newicks</span><span class="p">]</span></div>


<div class="viewcode-block" id="HistoryDag.count_topologies">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.count_topologies">[docs]</a>
    <span class="k">def</span> <span class="nf">count_topologies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collapse_leaves</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Counts the number of unique topologies in the history DAG. This is</span>
<span class="sd">        achieved by counting the number of unique newick strings with only</span>
<span class="sd">        leaves labeled.</span>

<span class="sd">        :meth:`count_histories` gives the total number of unique trees in the DAG, taking</span>
<span class="sd">        into account internal node labels.</span>

<span class="sd">        For large DAGs, this method is prohibitively slow. Use :meth:`count_topologies_fast` instead.</span>

<span class="sd">        Args:</span>
<span class="sd">            collapse_leaves: By default, topologies are counted as-is in the DAG. However,</span>
<span class="sd">                even if the DAG is collapsed by label, edges above leaf nodes will not be collapsed.</span>
<span class="sd">                if `collapse_leaves` is True, then the number of unique topologies with all</span>
<span class="sd">                leaf-adjacent edges collapsed will be counted. Assumes that the DAG is collapsed</span>
<span class="sd">                with :meth:`HistoryDag.convert_to_collapsed`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The number of topologies in the history DAG</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">make_newickcountfuncs</span><span class="p">(</span>
            <span class="n">internal_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">collapse_leaves</span><span class="o">=</span><span class="n">collapse_leaves</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_count</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>


<div class="viewcode-block" id="HistoryDag.count_topologies_fast">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.count_topologies_fast">[docs]</a>
    <span class="k">def</span> <span class="nf">count_topologies_fast</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Counts the number of unique topologies in the history DAG.</span>

<span class="sd">        This is achieved by creating a new history DAG in which all</span>
<span class="sd">        internal nodes have matching labels.</span>

<span class="sd">        This is only guaranteed to match the output of ``count_topologies``</span>
<span class="sd">        if the DAG has all allowed edges added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unlabel</span><span class="p">()</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span></div>


<div class="viewcode-block" id="HistoryDag.count_trees">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.count_trees">[docs]</a>
    <span class="k">def</span> <span class="nf">count_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deprecated name for :meth:`count_histories`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.count_histories">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.count_histories">[docs]</a>
    <span class="k">def</span> <span class="nf">count_histories</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">expand_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Label</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">expand_count_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">bifurcating</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Annotates each node in the DAG with the number of clade sub-trees</span>
<span class="sd">        underneath.</span>

<span class="sd">        Args:</span>
<span class="sd">            expand_func: A function which takes a label and returns a list of labels, for</span>
<span class="sd">                example disambiguations of an ambiguous sequence. If provided, this method</span>
<span class="sd">                will count at least the number of histories that would be in the DAG,</span>
<span class="sd">                if :meth:`explode_nodes` were called with the same `expand_func`.</span>
<span class="sd">            expand_count_func: A function which takes a label and returns an integer value</span>
<span class="sd">                corresponding to the number of &#39;disambiguations&#39; of that label. If provided,</span>
<span class="sd">                `expand_func` will be used to find this value.</span>
<span class="sd">            bifurcating: If True, the number of bifurcating topologies possible below each</span>
<span class="sd">                node will be computed. This is only an underestimate of the true number, since</span>
<span class="sd">                nodes that would be created by adding all resolutions of multifurcating nodes</span>
<span class="sd">                may already be present, resulting in additional subtree swaps.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The total number of unique complete trees below the root node. If `expand_func`</span>
<span class="sd">            or `expand_count_func` is provided, the complete trees being counted are not</span>
<span class="sd">            guaranteed to be unique. If bifurcating is True, then the values stored in nodes&#39;</span>
<span class="sd">            ``_dp_data`` attributes will include all resolutions of multifurcations below a node,</span>
<span class="sd">            but not of a node&#39;s own multifurcation. To get the number of bifurcating subtrees below</span>
<span class="sd">            a node, one can use ``node._dp_data * utils.count_labeled_binary_topologies(len(node.clades)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">expand_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">expand_count_func</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">expand_func</span><span class="p">(</span><span class="n">label</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">bifurcating</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">bifurcation_correction</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">count_labeled_binary_topologies</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">1</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">bifurcation_correction</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_history_accum</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">:</span> <span class="n">expand_count_func</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">bifurcation_correction</span><span class="p">(</span><span class="n">child</span><span class="p">),</span>
            <span class="nb">sum</span><span class="p">,</span>
            <span class="n">prod</span><span class="p">,</span>
            <span class="n">compute_edge_probabilities</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.preorder_history_accum">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.preorder_history_accum">[docs]</a>
    <span class="k">def</span> <span class="nf">preorder_history_accum</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">leaf_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">],</span>
        <span class="n">edge_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">,</span> <span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">],</span>
        <span class="n">accum_within_clade</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">],</span>
        <span class="n">accum_between_clade</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">],</span>
        <span class="n">ua_start_val</span><span class="p">:</span> <span class="n">Weight</span><span class="p">,</span>
        <span class="n">accum_above_edge</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Weight</span><span class="p">,</span> <span class="n">Weight</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="n">Weight</span><span class="p">],</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="n">Weight</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A template method for leaf-to-root and root-to-leaf dynamic</span>
<span class="sd">        programming.</span>

<span class="sd">        Args:</span>
<span class="sd">            leaf_func: A function to assign weights to leaf nodes</span>
<span class="sd">            edge_func: A function to assign weights to edges. The parent node will</span>
<span class="sd">                always be the first argument.</span>
<span class="sd">            accum_within_clade: A function which accumulates a list of weights of subtrees</span>
<span class="sd">                below a single clade. That is, the weights are for alternative trees.</span>
<span class="sd">            accum_between_clade: A function which accumulates a list of weights of subtrees</span>
<span class="sd">                below different clades. That is, the weights are for different parts of the</span>
<span class="sd">                same tree.</span>
<span class="sd">            accum_above_edge: A function which adds the weight for a subtree to the weight</span>
<span class="sd">                of the edge above it. If `None`, this function will be inferred from</span>
<span class="sd">                `accum_between_clade`. The edge weight is the second argument.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Two dictionaries: One describing downward weights below each node,</span>
<span class="sd">            and another describing upward weights above each node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">accum_above_edge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">default_accum_above_edge</span><span class="p">(</span><span class="n">subtree_weight</span><span class="p">,</span> <span class="n">edge_weight</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">accum_between_clade</span><span class="p">([</span><span class="n">subtree_weight</span><span class="p">,</span> <span class="n">edge_weight</span><span class="p">])</span>

            <span class="n">accum_above_edge</span> <span class="o">=</span> <span class="n">default_accum_above_edge</span>

        <span class="n">downward_weights</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">upward_weights</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">postorder_history_accum</span><span class="p">(</span>
            <span class="n">leaf_func</span><span class="o">=</span><span class="n">leaf_func</span><span class="p">,</span>
            <span class="n">edge_func</span><span class="o">=</span><span class="n">edge_func</span><span class="p">,</span>
            <span class="n">accum_within_clade</span><span class="o">=</span><span class="n">accum_within_clade</span><span class="p">,</span>
            <span class="n">accum_between_clade</span><span class="o">=</span><span class="n">accum_between_clade</span><span class="p">,</span>
            <span class="n">accum_above_edge</span><span class="o">=</span><span class="n">accum_above_edge</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()):</span>
            <span class="n">downward_weights</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_dp_data</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
                <span class="n">above</span> <span class="o">=</span> <span class="n">ua_start_val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_clade</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
                <span class="n">above</span> <span class="o">=</span> <span class="n">accum_between_clade</span><span class="p">(</span>
                    <span class="c1"># for each parent, add the edge weight to that parent to</span>
                    <span class="c1"># the above tree weight</span>
                    <span class="n">accum_above_edge</span><span class="p">(</span>
                        <span class="c1"># accumulate between parents of this node</span>
                        <span class="n">accum_between_clade</span><span class="p">(</span>
                            <span class="c1"># accumulate weights of clades other than the one that</span>
                            <span class="c1"># matches this node&#39;s clade union</span>
                            <span class="n">accum_within_clade</span><span class="p">(</span>
                                <span class="c1"># aggregate over alternative children below each</span>
                                <span class="c1"># clade</span>
                                <span class="n">accum_above_edge</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">_dp_data</span><span class="p">,</span> <span class="n">edge_func</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">child</span><span class="p">))</span>
                                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">clade</span><span class="o">=</span><span class="n">clade</span><span class="p">)</span>
                            <span class="p">)</span>
                            <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">clades</span>
                            <span class="k">if</span> <span class="n">clade</span> <span class="o">!=</span> <span class="n">curr_clade</span>
                        <span class="p">),</span>
                        <span class="n">edge_func</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">node</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span>
                <span class="p">)</span>
            <span class="n">upward_weights</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">above</span>

        <span class="k">return</span> <span class="n">downward_weights</span><span class="p">,</span> <span class="n">upward_weights</span></div>


<div class="viewcode-block" id="HistoryDag.count_nodes">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.count_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">count_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collapse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rooted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Counts the number of trees each node takes part in.</span>

<span class="sd">        For node supports with respect to a uniform distribution on trees, use</span>
<span class="sd">        :meth:`HistoryDag.uniform_distribution_annotate` and :meth:`HistoryDag.node_probabilities`.</span>

<span class="sd">        Args:</span>
<span class="sd">            collapse: A flag that when set to true, treats nodes as clade unions and</span>
<span class="sd">                ignores label information. Then, the returned dictionary is keyed by</span>
<span class="sd">                clade union sets.</span>
<span class="sd">            rooted: A flag which is ignored unless ``collapse`` is ``True``. When ``rooted`` is also ``False``,</span>
<span class="sd">                the returned dictionary is keyed by splits -- that is, sets containing each clade</span>
<span class="sd">                union and its complement, with values the number of (rooted) trees in the DAG containing</span>
<span class="sd">                each split. Splits are not double-counted when a tree has a bifurcating root.</span>
<span class="sd">                If False, dag is expected to have trees all on the same set of leaf labels.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary mapping each node in the DAG to the number of trees</span>
<span class="sd">            that it takes part in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node2count</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">node2stats</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
        <span class="n">reverse_postorder</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()))</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">reverse_postorder</span><span class="p">:</span>
            <span class="n">below</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_dp_data</span>
            <span class="n">curr_clade</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
                <span class="n">above</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">above</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="n">above_parent</span> <span class="o">=</span> <span class="n">node2stats</span><span class="p">[</span><span class="n">parent</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">below_parent</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                        <span class="c1"># Skip clade covered by node of interest</span>
                        <span class="k">if</span> <span class="n">clade</span> <span class="o">==</span> <span class="n">curr_clade</span> <span class="ow">or</span> <span class="n">parent</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
                            <span class="k">continue</span>
                        <span class="n">below_clade</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">sib</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">clade</span><span class="o">=</span><span class="n">clade</span><span class="p">):</span>
                            <span class="n">below_clade</span> <span class="o">+=</span> <span class="n">sib</span><span class="o">.</span><span class="n">_dp_data</span>
                        <span class="n">below_parent</span> <span class="o">*=</span> <span class="n">below_clade</span>

                    <span class="n">above</span> <span class="o">+=</span> <span class="n">above_parent</span> <span class="o">*</span> <span class="n">below_parent</span>

            <span class="n">node2count</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">above</span> <span class="o">*</span> <span class="n">below</span>
            <span class="n">node2stats</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">above</span><span class="p">,</span> <span class="n">below</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">collapse</span><span class="p">:</span>
            <span class="n">collapsed_n2c</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node2count</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">clade</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">clade</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">collapsed_n2c</span><span class="p">:</span>
                    <span class="n">collapsed_n2c</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">collapsed_n2c</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span> <span class="o">+=</span> <span class="n">node2count</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">rooted</span><span class="p">:</span>
                <span class="c1"># Remove the UA node clade union from N</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">collapsed_n2c</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">())</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">return</span> <span class="n">collapsed_n2c</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Create dictionary counting in how many trees each split</span>
                <span class="c1"># occurs as child of bifurcating root</span>
                <span class="n">split2adjustment</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">all_taxa</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">())</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">all_taxa</span> <span class="o">!=</span> <span class="n">n</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">()):</span>
                    <span class="k">raise</span> <span class="n">TaxaError</span><span class="p">(</span>
                        <span class="s2">&quot;Unrooted splits cannot be counted properly because&quot;</span>
                        <span class="s2">&quot; trees in this dag are on different sets of taxa.&quot;</span>
                    <span class="p">)</span>
                <span class="k">for</span> <span class="n">treeroot</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">treeroot</span><span class="o">.</span><span class="n">clades</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">split</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">treeroot</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                        <span class="n">before</span> <span class="o">=</span> <span class="n">split2adjustment</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">split</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">split2adjustment</span><span class="p">[</span><span class="n">split</span><span class="p">]</span> <span class="o">=</span> <span class="n">before</span> <span class="o">+</span> <span class="n">node2count</span><span class="p">[</span><span class="n">treeroot</span><span class="p">]</span>
                <span class="n">split2count</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">collapsed_n2c</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">split</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">clade</span><span class="p">,</span> <span class="n">all_taxa</span> <span class="o">-</span> <span class="n">clade</span><span class="p">})</span>
                    <span class="n">before</span> <span class="o">=</span> <span class="n">split2count</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">split</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">split2count</span><span class="p">[</span><span class="n">split</span><span class="p">]</span> <span class="o">=</span> <span class="n">before</span> <span class="o">+</span> <span class="n">count</span>
                <span class="k">for</span> <span class="n">split</span><span class="p">,</span> <span class="n">adjustment</span> <span class="ow">in</span> <span class="n">split2adjustment</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">split2count</span><span class="p">[</span><span class="n">split</span><span class="p">]</span> <span class="o">-=</span> <span class="n">adjustment</span>
                <span class="n">split2count</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">({</span><span class="n">all_taxa</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">()}),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">split2count</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node2count</span></div>


<div class="viewcode-block" id="HistoryDag.count_edges">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.count_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">count_edges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">collapsed</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Counts the number of trees each edge takes part in.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary mapping each edge in the DAG to the number of trees</span>
<span class="sd">            that it takes part in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edge2count</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">node2stats</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
        <span class="n">reverse_postorder</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">()))</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">reverse_postorder</span><span class="p">:</span>
            <span class="n">below</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_dp_data</span>
            <span class="n">curr_clade</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
                <span class="n">above</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">above</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="n">above_parent</span> <span class="o">=</span> <span class="n">node2stats</span><span class="p">[</span><span class="n">parent</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">below_parent</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                        <span class="c1"># Skip clade covered by node of interest</span>
                        <span class="k">if</span> <span class="n">clade</span> <span class="o">==</span> <span class="n">curr_clade</span> <span class="ow">or</span> <span class="n">parent</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
                            <span class="k">continue</span>
                        <span class="n">below_clade</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">sib</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">clade</span><span class="o">=</span><span class="n">clade</span><span class="p">):</span>
                            <span class="n">below_clade</span> <span class="o">+=</span> <span class="n">sib</span><span class="o">.</span><span class="n">_dp_data</span>
                        <span class="n">below_parent</span> <span class="o">*=</span> <span class="n">below_clade</span>

                    <span class="n">above</span> <span class="o">+=</span> <span class="n">above_parent</span> <span class="o">*</span> <span class="n">below_parent</span>

                    <span class="n">edge2count</span><span class="p">[(</span><span class="n">parent</span><span class="p">,</span> <span class="n">node</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">above_parent</span> <span class="o">*</span> <span class="n">below_parent</span><span class="p">)</span> <span class="o">*</span> <span class="n">below</span>
            <span class="n">node2stats</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">above</span><span class="p">,</span> <span class="n">below</span><span class="p">]</span>

        <span class="n">e2c</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">collapsed</span><span class="p">:</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">),</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">edge2count</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">parent_cu</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
                <span class="n">child_cu</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">parent_cu</span><span class="p">,</span> <span class="n">child_cu</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">e2c</span><span class="p">:</span>
                    <span class="n">e2c</span><span class="p">[(</span><span class="n">parent_cu</span><span class="p">,</span> <span class="n">child_cu</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">e2c</span><span class="p">[(</span><span class="n">parent_cu</span><span class="p">,</span> <span class="n">child_cu</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">count</span>
            <span class="k">return</span> <span class="n">e2c</span>

        <span class="k">return</span> <span class="n">edge2count</span></div>


<div class="viewcode-block" id="HistoryDag.most_supported_trees">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.most_supported_trees">[docs]</a>
    <span class="k">def</span> <span class="nf">most_supported_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Trims the DAG to only express the trees that have the highest</span>
<span class="sd">        support.&quot;&quot;&quot;</span>
        <span class="n">node2count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_nodes</span><span class="p">()</span>
        <span class="n">total_trees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>
        <span class="n">clade2support</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">node2count</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">clade2support</span><span class="p">:</span>
                <span class="n">clade2support</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">clade2support</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()]</span> <span class="o">+=</span> <span class="n">count</span> <span class="o">/</span> <span class="n">total_trees</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trim_optimal_weight</span><span class="p">(</span>
            <span class="n">start_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">edge_weight_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">:</span> <span class="n">log</span><span class="p">(</span><span class="n">clade2support</span><span class="p">[</span><span class="n">n2</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()]),</span>
            <span class="n">accum_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">weights</span><span class="p">:</span> <span class="nb">sum</span><span class="p">([</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">]),</span>
            <span class="n">optimal_func</span><span class="o">=</span><span class="nb">max</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">_dp_data</span></div>


<div class="viewcode-block" id="HistoryDag.count_paths_to_leaf">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.count_paths_to_leaf">[docs]</a>
    <span class="k">def</span> <span class="nf">count_paths_to_leaf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">leaf_label</span><span class="p">,</span>
        <span class="n">expand_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Label</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">expand_count_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ls</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Annotates each node in the DAG with the number of paths to</span>
<span class="sd">        ``leaf_label`` underneath.</span>

<span class="sd">        Args:</span>
<span class="sd">            leaf_label: The label of the leaf node of interest</span>
<span class="sd">            expand_func: A function which takes a label and returns a list of labels, for</span>
<span class="sd">                example disambiguations of an ambiguous sequence. If provided, this method</span>
<span class="sd">                will count at least the number of histories that would be in the DAG,</span>
<span class="sd">                if :meth:`explode_nodes` were called with the same `expand_func`.</span>
<span class="sd">            expand_count_func: A function which takes a label and returns an integer value</span>
<span class="sd">                corresponding to the number of &#39;disambiguations&#39; of that label. If provided,</span>
<span class="sd">                `expand_func` will be used to find this value.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The total number of unique paths to the leaf node of interest. If `expand_func`</span>
<span class="sd">            or `expand_count_func` is provided, the paths being counted are not guaranteed</span>
<span class="sd">            to be unique.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">expand_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">expand_count_func</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">expand_func</span><span class="p">(</span><span class="n">label</span><span class="p">)))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_history_accum</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">leaf_label</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="nb">sum</span><span class="p">,</span>
            <span class="nb">sum</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.weight_counts_with_ambiguities">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.weight_counts_with_ambiguities">[docs]</a>
    <span class="nd">@get_default_args</span><span class="p">([</span><span class="s2">&quot;start_func&quot;</span><span class="p">,</span> <span class="s2">&quot;edge_func&quot;</span><span class="p">,</span> <span class="s2">&quot;accum_func&quot;</span><span class="p">,</span> <span class="s2">&quot;expand_func&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">weight_counts_with_ambiguities</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">,</span> <span class="n">Label</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">accum_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">expand_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Label</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Label</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Template method for counting tree weights in the DAG, with exploded</span>
<span class="sd">        labels. Like :meth:`HistoryDag.weight_count`, but creates dictionaries</span>
<span class="sd">        of Counter objects at each node, keyed by possible sequences at that</span>
<span class="sd">        node. Analogous to :meth:`HistoryDag.count_histories` with</span>
<span class="sd">        `expand_func` provided.</span>

<span class="sd">        Weights must be hashable.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_func: A function which assigns a weight to each leaf node</span>
<span class="sd">            edge_func: A function which assigns a weight to pairs of labels, with the</span>
<span class="sd">                parent node label the first argument. Must correctly handle the UA</span>
<span class="sd">                node label which is a UALabel instead of a namedtuple.</span>
<span class="sd">            accum_func: A way to &#39;add&#39; a list of weights together</span>
<span class="sd">            expand_func: A function which takes a label and returns a list of labels, such</span>
<span class="sd">                as disambiguations of an ambiguous sequence.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A Counter keyed by weights.</span>
<span class="sd">            The total number of trees will be greater than count_histories(), as these are</span>
<span class="sd">            possible disambiguations of trees. These disambiguations may not be unique,</span>
<span class="sd">            but if two are the same, they come from different subtrees of the DAG.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">wrapped_expand_func</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">is_ua_node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_ua_node</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">label</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">expand_func</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="c1"># The old direct implementation not using postorder_history_accum was</span>
        <span class="c1"># more straightforward, and may be significantly faster.</span>
        <span class="k">def</span> <span class="nf">leaf_func</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="n">label</span><span class="p">:</span> <span class="n">Counter</span><span class="p">({</span><span class="n">start_func</span><span class="p">(</span><span class="n">node</span><span class="p">):</span> <span class="mi">1</span><span class="p">})</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">expand_func</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
            <span class="p">}</span>

        <span class="k">def</span> <span class="nf">edge_weight_func</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
            <span class="c1"># This will handle &#39;adding&#39; child node counts to the edge, so we</span>
            <span class="c1"># have accum_above_edge just return this result.</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="n">label</span><span class="p">:</span> <span class="n">counter_sum</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">counter_prod</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">target_wc</span><span class="p">,</span> <span class="n">Counter</span><span class="p">({</span><span class="n">edge_func</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">childlabel</span><span class="p">):</span> <span class="mi">1</span><span class="p">})],</span>
                            <span class="n">accum_func</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">childlabel</span><span class="p">,</span> <span class="n">target_wc</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">_dp_data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">childlabel</span><span class="p">,</span> <span class="n">target_wc</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">_dp_data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">wrapped_expand_func</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">())</span>
            <span class="p">}</span>

        <span class="k">def</span> <span class="nf">accum_within_clade</span><span class="p">(</span><span class="n">dictlist</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">dictlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">counter_sum</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dictlist</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">accum_between_clade</span><span class="p">(</span><span class="n">dictlist</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">dictlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="n">counter_prod</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dictlist</span><span class="p">],</span> <span class="n">accum_func</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span>
            <span class="p">}</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">postorder_history_accum</span><span class="p">(</span>
                <span class="n">leaf_func</span><span class="p">,</span>
                <span class="n">edge_weight_func</span><span class="p">,</span>
                <span class="n">accum_within_clade</span><span class="p">,</span>
                <span class="n">accum_between_clade</span><span class="p">,</span>
                <span class="n">accum_above_edge</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="HistoryDag.underestimate_rf_diameter">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.underestimate_rf_diameter">[docs]</a>
    <span class="k">def</span> <span class="nf">underestimate_rf_diameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an underestimate of the RF diameter of the DAG. This</span>
<span class="sd">        estimate is calculated by calculating the maximal sum RF distance</span>
<span class="sd">        between the DAG and a random tree from a topological outlier.</span>

<span class="sd">        On a set of DAGs with 2000 or less histories, this underestimate</span>
<span class="sd">        is quite accurate compared to the actual computed RF diameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dag_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dag_copy</span><span class="o">.</span><span class="n">trim_optimal_sum_rf_distance</span><span class="p">(</span><span class="n">dag_copy</span><span class="p">,</span> <span class="n">optimal_func</span><span class="o">=</span><span class="nb">max</span><span class="p">)</span>
        <span class="n">ref_history</span> <span class="o">=</span> <span class="n">dag_copy</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimal_rf_distance</span><span class="p">(</span><span class="n">ref_history</span><span class="p">,</span> <span class="n">optimal_func</span><span class="o">=</span><span class="nb">max</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.overestimate_rf_diameter">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.overestimate_rf_diameter">[docs]</a>
    <span class="k">def</span> <span class="nf">overestimate_rf_diameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an overestimate of the RF diameter of the DAG. This estimate</span>
<span class="sd">        is calculated by calculating twice of the maximal sum RF distance</span>
<span class="sd">        between the DAG and a random tree from the median tree.</span>

<span class="sd">        On a set of DAGs with 2000 or less histories, this underestimate</span>
<span class="sd">        was not close compared to the actual RF diameter. However, the</span>
<span class="sd">        overestimate was never more than twice of the actual RF</span>
<span class="sd">        diameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dag_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dag_copy</span><span class="o">.</span><span class="n">trim_optimal_sum_rf_distance</span><span class="p">(</span><span class="n">dag_copy</span><span class="p">,</span> <span class="n">optimal_func</span><span class="o">=</span><span class="nb">min</span><span class="p">)</span>
        <span class="n">ref_history</span> <span class="o">=</span> <span class="n">dag_copy</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimal_rf_distance</span><span class="p">(</span><span class="n">ref_history</span><span class="p">,</span> <span class="n">optimal_func</span><span class="o">=</span><span class="nb">max</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.optimal_sum_rf_distance">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.optimal_sum_rf_distance">[docs]</a>
    <span class="k">def</span> <span class="nf">optimal_sum_rf_distance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">reference_dag</span><span class="p">:</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span>
        <span class="n">rooted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">one_sided</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">one_sided_coefficients</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">optimal_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the optimal (min or max) summed rooted RF distance to all</span>
<span class="sd">        histories in the reference DAG.</span>

<span class="sd">        The given history must be on the same taxa as all trees in the DAG.</span>
<span class="sd">        Since computing reference splits is expensive, it is better to use</span>
<span class="sd">        :meth:``optimal_weight_annotate`` and :meth:``utils.make_rfdistance_countfuncs``</span>
<span class="sd">        instead of making multiple calls to this method with the same reference</span>
<span class="sd">        history DAG.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sum_rfdistance_funcs</span><span class="p">(</span>
            <span class="n">reference_dag</span><span class="p">,</span>
            <span class="n">rooted</span><span class="o">=</span><span class="n">rooted</span><span class="p">,</span>
            <span class="n">one_sided</span><span class="o">=</span><span class="n">one_sided</span><span class="p">,</span>
            <span class="n">one_sided_coefficients</span><span class="o">=</span><span class="n">one_sided_coefficients</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimal_weight_annotate</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">optimal_func</span><span class="o">=</span><span class="n">optimal_func</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.trim_optimal_sum_rf_distance">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.trim_optimal_sum_rf_distance">[docs]</a>
    <span class="k">def</span> <span class="nf">trim_optimal_sum_rf_distance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">reference_dag</span><span class="p">:</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span>
        <span class="n">rooted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">one_sided</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">one_sided_coefficients</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">optimal_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Trims the DAG to contain only histories with the optimal (min or</span>
<span class="sd">        max) sum rooted RF distance to the given reference DAG.</span>

<span class="sd">        See :meth:`utils.sum_rfdistance_funcs` for detailed documentation of</span>
<span class="sd">        arguments.</span>

<span class="sd">        Trimming to the minimum sum RF distance is equivalent to finding &#39;median&#39; topologies,</span>
<span class="sd">        and trimming to maximum sum rf distance is equivalent to finding topological outliers.</span>

<span class="sd">        The given history must be on the same taxa as all trees in the DAG.</span>
<span class="sd">        Since computing reference splits is expensive, it is better to use</span>
<span class="sd">        :meth:``trim_optimal_weight`` and :meth:``utils.sum_rfdistance_funcs``</span>
<span class="sd">        instead of making multiple calls to this method with the same reference</span>
<span class="sd">        history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sum_rfdistance_funcs</span><span class="p">(</span>
            <span class="n">reference_dag</span><span class="p">,</span>
            <span class="n">rooted</span><span class="o">=</span><span class="n">rooted</span><span class="p">,</span>
            <span class="n">one_sided</span><span class="o">=</span><span class="n">one_sided</span><span class="p">,</span>
            <span class="n">one_sided_coefficients</span><span class="o">=</span><span class="n">one_sided_coefficients</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim_optimal_weight</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">optimal_func</span><span class="o">=</span><span class="n">optimal_func</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.trim_optimal_rf_distance">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.trim_optimal_rf_distance">[docs]</a>
    <span class="k">def</span> <span class="nf">trim_optimal_rf_distance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">history</span><span class="p">:</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span>
        <span class="n">rooted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">one_sided</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">one_sided_coefficients</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">optimal_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Trims this history DAG to the optimal (min or max) RF distance to a</span>
<span class="sd">        given history.</span>

<span class="sd">        See :meth:`utils.make_rfdistance_countfuncs` for detailed documentation of</span>
<span class="sd">        arguments.</span>

<span class="sd">        Also returns that optimal RF distance</span>

<span class="sd">        The given history must be on the same taxa as all trees in the DAG.</span>
<span class="sd">        Since computing reference splits is expensive, it is better to use</span>
<span class="sd">        :meth:`optimal_weight_annotate` and :meth:`utils.make_rfdistance_countfuncs`</span>
<span class="sd">        instead of making multiple calls to this method with the same reference</span>
<span class="sd">        history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">make_rfdistance_countfuncs</span><span class="p">(</span>
            <span class="n">history</span><span class="p">,</span>
            <span class="n">rooted</span><span class="o">=</span><span class="n">rooted</span><span class="p">,</span>
            <span class="n">one_sided</span><span class="o">=</span><span class="n">one_sided</span><span class="p">,</span>
            <span class="n">one_sided_coefficients</span><span class="o">=</span><span class="n">one_sided_coefficients</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim_optimal_weight</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">optimal_func</span><span class="o">=</span><span class="n">optimal_func</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.optimal_rf_distance">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.optimal_rf_distance">[docs]</a>
    <span class="k">def</span> <span class="nf">optimal_rf_distance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">history</span><span class="p">:</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span>
        <span class="n">rooted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">one_sided</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">one_sided_coefficients</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">optimal_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the optimal (min or max) RF distance to a given history.</span>

<span class="sd">        See :meth:`utils.make_rfdistance_countfuncs` for detailed documentation of</span>
<span class="sd">        arguments.</span>

<span class="sd">        The given history must be on the same taxa as all trees in the DAG.</span>
<span class="sd">        Since computing reference splits is expensive, it is better to use</span>
<span class="sd">        :meth:`optimal_weight_annotate` and :meth:`utils.make_rfdistance_countfuncs`</span>
<span class="sd">        instead of making multiple calls to this method with the same reference</span>
<span class="sd">        history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">make_rfdistance_countfuncs</span><span class="p">(</span>
            <span class="n">history</span><span class="p">,</span>
            <span class="n">rooted</span><span class="o">=</span><span class="n">rooted</span><span class="p">,</span>
            <span class="n">one_sided</span><span class="o">=</span><span class="n">one_sided</span><span class="p">,</span>
            <span class="n">one_sided_coefficients</span><span class="o">=</span><span class="n">one_sided_coefficients</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimal_weight_annotate</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">optimal_func</span><span class="o">=</span><span class="n">optimal_func</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.count_rf_distances">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.count_rf_distances">[docs]</a>
    <span class="k">def</span> <span class="nf">count_rf_distances</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">history</span><span class="p">:</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span>
        <span class="n">rooted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">one_sided</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">one_sided_coefficients</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a Counter containing all RF distances to a given history.</span>

<span class="sd">        The given history must be on the same taxa as all trees in the DAG.</span>

<span class="sd">        See :meth:`utils.make_rfdistance_countfuncs` for detailed documentation of</span>
<span class="sd">        arguments.</span>

<span class="sd">        Since computing reference splits is expensive, it is better to use</span>
<span class="sd">        :meth:`weight_count` and :meth:`utils.make_rfdistance_countfuncs`</span>
<span class="sd">        instead of making multiple calls to this method with the same reference</span>
<span class="sd">        history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">make_rfdistance_countfuncs</span><span class="p">(</span>
            <span class="n">history</span><span class="p">,</span>
            <span class="n">rooted</span><span class="o">=</span><span class="n">rooted</span><span class="p">,</span>
            <span class="n">one_sided</span><span class="o">=</span><span class="n">one_sided</span><span class="p">,</span>
            <span class="n">one_sided_coefficients</span><span class="o">=</span><span class="n">one_sided_coefficients</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_count</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.count_sum_rf_distances">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.count_sum_rf_distances">[docs]</a>
    <span class="k">def</span> <span class="nf">count_sum_rf_distances</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">reference_dag</span><span class="p">:</span> <span class="s2">&quot;HistoryDag&quot;</span><span class="p">,</span>
        <span class="n">rooted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">one_sided</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">one_sided_coefficients</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a Counter containing all sum RF distances to a given</span>
<span class="sd">        reference DAG.</span>

<span class="sd">        See :meth:`utils.sum_rfdistance_funcs` for detailed documentation of</span>
<span class="sd">        arguments.</span>

<span class="sd">        The given history DAG must be on the same taxa as all trees in the DAG.</span>

<span class="sd">        Since computing reference splits is expensive, it is better to use</span>
<span class="sd">        :meth:`weight_count` and :meth:`utils.sum_rfdistance_funcs`</span>
<span class="sd">        instead of making multiple calls to this method with the same reference</span>
<span class="sd">        history DAG.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sum_rfdistance_funcs</span><span class="p">(</span>
            <span class="n">reference_dag</span><span class="p">,</span>
            <span class="n">rooted</span><span class="o">=</span><span class="n">rooted</span><span class="p">,</span>
            <span class="n">one_sided</span><span class="o">=</span><span class="n">one_sided</span><span class="p">,</span>
            <span class="n">one_sided_coefficients</span><span class="o">=</span><span class="n">one_sided_coefficients</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_count</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.sum_rf_distances">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.sum_rf_distances">[docs]</a>
    <span class="k">def</span> <span class="nf">sum_rf_distances</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">reference_dag</span><span class="p">:</span> <span class="s2">&quot;HistoryDag&quot;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">rooted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">one_sided</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">one_sided_coefficients</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes the sum of Robinson-Foulds distances over all pairs of</span>
<span class="sd">        histories in this DAG and the provided reference DAG.</span>

<span class="sd">        Args:</span>
<span class="sd">            reference_dag: If None, the sum of pairwise distances between histories in this DAG</span>
<span class="sd">                is computed. If provided, the sum is over pairs containing one history in this DAG and</span>
<span class="sd">                one from ``reference_dag``.</span>
<span class="sd">            rooted: If False, use edges&#39; splits for RF distance computation. Otherwise, use</span>
<span class="sd">                the clade below each edge.</span>
<span class="sd">            one_sided: May be &#39;left&#39;, &#39;right&#39;, or None. &#39;left&#39; means that we count</span>
<span class="sd">                splits (or clades, in the rooted case) which are in the reference trees but not</span>
<span class="sd">                in the DAG tree, especially useful if trees in the DAG might be resolutions of</span>
<span class="sd">                multifurcating trees in the reference DAG. &#39;right&#39; means that we count splits or clades in</span>
<span class="sd">                the DAG tree which are not in the reference trees, useful if the reference trees</span>
<span class="sd">                are possibly resolutions of multifurcating trees in the DAG. If not None,</span>
<span class="sd">                one_sided_coefficients are ignored.</span>
<span class="sd">            one_sided_coefficients: coefficients for non-standard symmetric difference calculations.</span>
<span class="sd">                See :meth:`utils.make_rfdistance_countfuncs` for more details.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An integer sum of RF distances.</span>

<span class="sd">        If T is the set of histories in the reference DAG, and T&#39; is the set of histories in</span>
<span class="sd">        this DAG, then the returned sum is:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \sum_{t\in T} \sum_{t&#39;\in T&#39;} d(t, t&#39;)</span>

<span class="sd">        That is, since RF distance is symmetric, when T = T&#39; (such as when ``reference_dag=None``),</span>
<span class="sd">        or when the intersection of T and T&#39; is nonempty, some distances are counted twice.</span>

<span class="sd">        Note that when computing one-sided distances, or when the one_sided_coefficients values are not</span>
<span class="sd">        equal, this &#39;distance&#39; is no longer symmetric.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">_process_rf_one_sided_coefficients</span><span class="p">(</span>
            <span class="n">one_sided</span><span class="p">,</span> <span class="n">one_sided_coefficients</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="n">dag</span><span class="p">):</span>
            <span class="n">n_histories</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">count_nodes</span><span class="p">(</span><span class="n">collapse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rooted</span><span class="o">=</span><span class="n">rooted</span><span class="p">)</span>

            <span class="n">clade_count_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">n_histories</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">clade_count_sum</span><span class="p">)</span>

        <span class="n">n_histories_prime</span><span class="p">,</span> <span class="n">N_prime</span><span class="p">,</span> <span class="n">clade_count_sum_prime</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reference_dag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_histories</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">clade_count_sum</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">n_histories_prime</span><span class="p">,</span>
                <span class="n">N_prime</span><span class="p">,</span>
                <span class="n">clade_count_sum_prime</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_histories</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">clade_count_sum</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="n">reference_dag</span><span class="p">)</span>

        <span class="n">intersection_term</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="n">count_prime</span> <span class="o">*</span> <span class="n">N</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">count_prime</span> <span class="ow">in</span> <span class="n">N_prime</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">N</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">t</span> <span class="o">*</span> <span class="n">n_histories</span> <span class="o">*</span> <span class="n">clade_count_sum_prime</span>
            <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">n_histories_prime</span> <span class="o">*</span> <span class="n">clade_count_sum</span>
            <span class="o">-</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">intersection_term</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.average_pairwise_rf_distance">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.average_pairwise_rf_distance">[docs]</a>
    <span class="k">def</span> <span class="nf">average_pairwise_rf_distance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">reference_dag</span><span class="p">:</span> <span class="s2">&quot;HistoryDag&quot;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">non_identical</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the average Robinson-Foulds distance between pairs of</span>
<span class="sd">        histories.</span>

<span class="sd">        Args:</span>
<span class="sd">            reference_dag: A history DAG from which to take the second history in</span>
<span class="sd">                each pair. If None, ``self`` will be used as the reference.</span>
<span class="sd">            non_identical: If True, mean divisor will be the number of non-identical pairs.</span>
<span class="sd">            kwargs: See :meth:`historydag.sum_rf_distances` for additional keyword arguments</span>

<span class="sd">        Returns:</span>
<span class="sd">            The average rf-distance between pairs of histories, where the first history</span>
<span class="sd">            comes from this DAG, and the second comes from ``reference_dag``. The normalization</span>
<span class="sd">            constant is the product of the number of histories in the two DAGs, unless</span>
<span class="sd">            ``non_identical`` is True, in which case the number of histories which appear</span>
<span class="sd">            in both DAGs is subtracted from this constant.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sum_pairwise_distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_rf_distances</span><span class="p">(</span>
            <span class="n">reference_dag</span><span class="o">=</span><span class="n">reference_dag</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">reference_dag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># ignore the diagonal in the distance matrix, since it contains</span>
            <span class="c1"># zeros:</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">n1</span>

            <span class="k">def</span> <span class="nf">compute_intersection_size</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">n1</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">reference_dag</span><span class="o">.</span><span class="n">count_histories</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">compute_intersection_size</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared_history_count</span><span class="p">(</span><span class="n">reference_dag</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">non_identical</span><span class="p">:</span>
            <span class="n">normalize_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">n1</span> <span class="o">*</span> <span class="n">n2</span><span class="p">)</span> <span class="o">-</span> <span class="n">compute_intersection_size</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">normalize_num</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">n2</span>
        <span class="k">return</span> <span class="n">sum_pairwise_distance</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">normalize_num</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.trim_optimal_weight">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.trim_optimal_weight">[docs]</a>
    <span class="nd">@get_default_args</span><span class="p">([</span><span class="s2">&quot;start_func&quot;</span><span class="p">,</span> <span class="s2">&quot;edge_weight_func&quot;</span><span class="p">,</span> <span class="s2">&quot;accum_func&quot;</span><span class="p">,</span> <span class="s2">&quot;optimal_func&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">trim_optimal_weight</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;HistoryDagNode&quot;</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="n">HistoryDagNode</span><span class="p">],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">accum_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">optimal_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">Weight</span><span class="p">]],</span> <span class="n">Weight</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="c1"># max_weight: Weight = None,</span>
        <span class="n">eq_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Weight</span><span class="p">,</span> <span class="n">Weight</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">:</span> <span class="n">w1</span> <span class="o">==</span> <span class="n">w2</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Weight</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Trims the DAG to only express trees with optimal weight. This is</span>
<span class="sd">        guaranteed to be possible when edge_weight_func depends only on the</span>
<span class="sd">        labels of an edge&#39;s parent and child node.</span>

<span class="sd">        Requires that weights are of a type that supports reliable equality</span>
<span class="sd">        testing. In particular, floats are not recommended. Instead, consider</span>
<span class="sd">        defining weights to be a precursor type, and define `optimal_func` to</span>
<span class="sd">        choose the one whose corresponding float is maximized/minimized.</span>

<span class="sd">        If floats must be used, a Numpy type may help.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_func: A function which assigns starting weights to leaves.</span>
<span class="sd">            edge_weight_func: A function which assigns weights to DAG edges based on the</span>
<span class="sd">                parent node and the child node, in that order.</span>
<span class="sd">            accum_func: A function which takes a list of weights of different parts of a tree,</span>
<span class="sd">                and returns a weight, like sum.</span>
<span class="sd">            optimal_func: A function which takes a list of weights and returns the optimal</span>
<span class="sd">                one, like min.</span>
<span class="sd">            eq_func: A function which tests equality, taking a pair of weights and returning a bool.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">opt_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimal_weight_annotate</span><span class="p">(</span>
            <span class="n">start_func</span><span class="o">=</span><span class="n">start_func</span><span class="p">,</span>
            <span class="n">edge_weight_func</span><span class="o">=</span><span class="n">edge_weight_func</span><span class="p">,</span>
            <span class="n">accum_func</span><span class="o">=</span><span class="n">accum_func</span><span class="p">,</span>
            <span class="n">optimal_func</span><span class="o">=</span><span class="n">optimal_func</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">weightlist</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="n">accum_func</span><span class="p">([</span><span class="n">target</span><span class="o">.</span><span class="n">_dp_data</span><span class="p">,</span> <span class="n">edge_weight_func</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">target</span><span class="p">)]),</span>
                        <span class="n">target</span><span class="p">,</span>
                        <span class="n">index</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="n">optimalweight</span> <span class="o">=</span> <span class="n">optimal_func</span><span class="p">([</span><span class="n">weight</span> <span class="k">for</span> <span class="n">weight</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">weightlist</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">weight</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">weightlist</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">eq_func</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">optimalweight</span><span class="p">):</span>
                        <span class="n">eset</span><span class="o">.</span><span class="n">remove_from_edgeset_byid</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Value returned by ``optimal_func`` </span><span class="si">{</span><span class="n">optimal_func</span><span class="si">}</span><span class="s2"> is not in the &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;list of weights passed to that function, according to eq_func </span><span class="si">{</span><span class="n">eq_func</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="n">eset</span><span class="o">.</span><span class="n">set_edge_stats</span><span class="p">(</span><span class="n">probs</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">opt_weight</span></div>


<div class="viewcode-block" id="HistoryDag.get_topologies">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.get_topologies">[docs]</a>
    <span class="k">def</span> <span class="nf">get_topologies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collapse_leaves</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of pseudo-newick representations of topologies in the</span>
<span class="sd">        history DAG.</span>

<span class="sd">        The newicks returned are not well-formed, and are for use with</span>
<span class="sd">        :meth:`HistoryDag.trim_topology`. Otherwise, this method would be equivalent to</span>
<span class="sd">        :meth:`HistoryDag.to_newicks` with keyword arguments ``internal_labels=False`` and</span>
<span class="sd">        ``collapsed_leaves`` as desired.</span>

<span class="sd">        Args:</span>
<span class="sd">            collapse_leaves: Whether to collapse leaf-adjacent edges between nodes with</span>
<span class="sd">                matching labels</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of strings, each representing a topology present in the history DAG.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">make_newickcountfuncs</span><span class="p">(</span>
            <span class="n">internal_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">collapse_leaves</span><span class="o">=</span><span class="n">collapse_leaves</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_count</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<div class="viewcode-block" id="HistoryDag.trim_topology">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.trim_topology">[docs]</a>
    <span class="k">def</span> <span class="nf">trim_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topology</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">collapse_leaves</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Trims the history DAG to express only trees matching the provided</span>
<span class="sd">        topology.</span>

<span class="sd">        Args:</span>
<span class="sd">            topology: A string like one output by :meth:`HistoryDag.get_topologies`</span>
<span class="sd">            collapse_leaves: must match the same argument provided to :meth:`HistoryDag.get_topologies`</span>
<span class="sd">                when creating the string passed as ``topology``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">min_func</span><span class="p">(</span><span class="n">newicks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="c1"># Each newick in presented to min_func will be well-formed, since</span>
            <span class="c1"># it will consist of a subtree newick added to a parent edge&#39;s</span>
            <span class="c1"># newick.</span>
            <span class="k">for</span> <span class="n">newick</span> <span class="ow">in</span> <span class="n">newicks</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">newick</span> <span class="ow">in</span> <span class="n">topology</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">newick</span>
            <span class="k">if</span> <span class="n">newicks</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;(;)&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;min_func() arg is an empty sequence&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trim_optimal_weight</span><span class="p">(</span>
            <span class="o">**</span><span class="n">utils</span><span class="o">.</span><span class="n">make_newickcountfuncs</span><span class="p">(</span>
                <span class="n">internal_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">collapse_leaves</span><span class="o">=</span><span class="n">collapse_leaves</span>
            <span class="p">),</span>
            <span class="n">optimal_func</span><span class="o">=</span><span class="n">min_func</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="c1"># ######## End Abstract DP method derivatives ########</span>

    <span class="c1"># ######## Methods for computing probabilities: ########</span>

<div class="viewcode-block" id="HistoryDag.export_edge_probabilities">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.export_edge_probabilities">[docs]</a>
    <span class="k">def</span> <span class="nf">export_edge_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a dictionary keyed by (parent, child) :class:`HistoryDagNode`</span>
<span class="sd">        pairs, with downward conditional edge probabilities as values.&quot;&quot;&quot;</span>
        <span class="n">edge_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">probability</span> <span class="ow">in</span> <span class="n">eset</span><span class="p">:</span>
                    <span class="n">edge_dict</span><span class="p">[(</span><span class="n">node</span><span class="p">,</span> <span class="n">child</span><span class="p">)]</span> <span class="o">=</span> <span class="n">probability</span>
        <span class="k">return</span> <span class="n">edge_dict</span></div>


<div class="viewcode-block" id="HistoryDag.get_probability_countfuncs">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.get_probability_countfuncs">[docs]</a>
    <span class="k">def</span> <span class="nf">get_probability_countfuncs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">log_probabilities</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">edge_probabilities</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Produce a :meth:`historydag.utils.AddFuncDict` containing functions</span>
<span class="sd">        to compute history probabilities using e.g.</span>
<span class="sd">        :meth:`HistoryDag.optimal_weight_annotate`.</span>

<span class="sd">        If no edge probabilities are provided, a method like :meth:`HistoryDag.probability_annotate`</span>
<span class="sd">        should be called to set edge annotations correctly.</span>

<span class="sd">        Args:</span>
<span class="sd">            log_probabilities: If True, interpret all edge probabilities as log-probabilities</span>
<span class="sd">            edge_probabilities: A dictionary containing conditional edge probabilities for each</span>
<span class="sd">                edge in the DAG. If not provided, edge probabilities are recovered from edge</span>
<span class="sd">                annotations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :meth:`historydag.utils.AddFuncDict` containing functions to compute</span>
<span class="sd">            history probabilities using e.g. :meth:`HistoryDag.optimal_weight_annotate`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">edge_probabilities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">export_edge_probabilities</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edge_dict</span> <span class="o">=</span> <span class="n">edge_probabilities</span>

        <span class="k">def</span> <span class="nf">edge_weight_func</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">edge_dict</span><span class="p">[(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">log_probabilities</span><span class="p">:</span>
            <span class="n">accum_func</span> <span class="o">=</span> <span class="nb">sum</span>

            <span class="k">def</span> <span class="nf">start_func</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">accum_func</span> <span class="o">=</span> <span class="n">prod</span>

            <span class="k">def</span> <span class="nf">start_func</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">AddFuncDict</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;edge_weight_func&quot;</span><span class="p">:</span> <span class="n">edge_weight_func</span><span class="p">,</span>
                <span class="s2">&quot;accum_func&quot;</span><span class="p">:</span> <span class="n">accum_func</span><span class="p">,</span>
                <span class="s2">&quot;start_func&quot;</span><span class="p">:</span> <span class="n">start_func</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;DagConditionalProbability&quot;</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.sum_probability">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.sum_probability">[docs]</a>
    <span class="k">def</span> <span class="nf">sum_probability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log_probabilities</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the total probability of all histories in the DAG, using</span>
<span class="sd">        downward conditional edge probabilities.</span>

<span class="sd">        Immediately after computing downward conditional probabilities, this should always return 1.</span>

<span class="sd">        However, after trimming, this method returns the probability that a history in the trimmed</span>
<span class="sd">        DAG would be sampled from the original DAG.</span>

<span class="sd">        Args:</span>
<span class="sd">            log_probabilities: If True, interpret conditional edge probabilities as log-probabilities.</span>
<span class="sd">                In this case, the return value is a log-probability as well.</span>
<span class="sd">            kwargs: The :class:`utils.AddFuncDict` containing keyword arguments for counting probabilities</span>
<span class="sd">                returned from :meth:`HistoryDag.get_probability_countfuncs`. If not provided, conditional</span>
<span class="sd">                edge probabilities annotated on the DAG will be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_probability_countfuncs</span><span class="p">(</span>
                <span class="n">log_probabilities</span><span class="o">=</span><span class="n">log_probabilities</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">log_probabilities</span><span class="p">:</span>
            <span class="n">aggregate_func</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">logsumexp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aggregate_func</span> <span class="o">=</span> <span class="nb">sum</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimal_weight_annotate</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">optimal_func</span><span class="o">=</span><span class="n">aggregate_func</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.node_probabilities">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.node_probabilities">[docs]</a>
    <span class="k">def</span> <span class="nf">node_probabilities</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">log_probabilities</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">normalize_edgeweights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">accum_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aggregate_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">start_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ua_node_val</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collapse_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">adjust_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="n">HistoryDagNode</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the probability of each node in the DAG.</span>

<span class="sd">        Args:</span>
<span class="sd">            log_probabilities: If True, all probabilities, and the values from ``edge_weight_func``, will</span>
<span class="sd">                be treated as log values.</span>
<span class="sd">            edge_weight_func: A function accepting a parent node and a child node and returning the</span>
<span class="sd">                weight associated to that edge. If not provided, it is assumed that correct edge probability</span>
<span class="sd">                annotations are already populated by a method such as :meth:`HistoryDag.probability_annotate`.</span>
<span class="sd">            normalize_edgeweights: A function taking a list of weights and returning a normalized list of</span>
<span class="sd">                downward-conditional edge probabilities. The default is determined by ``log_probabilities``.</span>
<span class="sd">            accum_func: A function taking a list of probabilities for parts of a sub-history, and returning</span>
<span class="sd">                a probability for that sub-history. The default is determined by ``log_probabilities``.</span>
<span class="sd">            aggregate_func: A function taking a list of probabilities for alternative sub-histories, and</span>
<span class="sd">                returning the aggregated probability of all sub-histories. The default is determined by ``log_probabilities``.</span>
<span class="sd">            start_func: A function taking a leaf node and returning its starting weight. The default is</span>
<span class="sd">                determined by ``log_probabilities``.</span>
<span class="sd">            ua_node_val: The probability value for the UA node. If not provided, the default value is</span>
<span class="sd">                determined by ``log_probabilities``.</span>
<span class="sd">            collapse_key: A function accepting a :class:`HistoryDagNode` and returning a key with respect</span>
<span class="sd">                to which node probabilities should be collapsed. The return type is the key type for the</span>
<span class="sd">                dictionary returned by this method. For example, to compute probabilities of each clade observed</span>
<span class="sd">                in the DAG, use ``collapse_key=HistoryDagNode.clade_union``.</span>
<span class="sd">            adjust_func: A function accepting an edge, and returning a factor by which to adjust confidence in the</span>
<span class="sd">                edge&#39;s child node contributed by trees containing that edge.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary keyed by :class:`HistoryDagNode` objects (or the return values of ``collapse_key`` if provided)</span>
<span class="sd">            whose values are probabilities according to the distribution induced by downward-conditional edge</span>
<span class="sd">            probabilities in the DAG.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">edge_weight_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">probability_annotate</span><span class="p">(</span>
                <span class="n">edge_weight_func</span><span class="p">,</span>
                <span class="n">log_probabilities</span><span class="o">=</span><span class="n">log_probabilities</span><span class="p">,</span>
                <span class="n">normalize_edgeweights</span><span class="o">=</span><span class="n">normalize_edgeweights</span><span class="p">,</span>
                <span class="n">accum_func</span><span class="o">=</span><span class="n">accum_func</span><span class="p">,</span>
                <span class="n">aggregate_func</span><span class="o">=</span><span class="n">aggregate_func</span><span class="p">,</span>
                <span class="n">start_func</span><span class="o">=</span><span class="n">start_func</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">adjust_func</span> <span class="o">=</span> <span class="n">_none_override_ternary</span><span class="p">(</span>
            <span class="n">adjust_func</span><span class="p">,</span> <span class="n">log_probabilities</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">ua_node_val</span> <span class="o">=</span> <span class="n">_none_override_ternary</span><span class="p">(</span><span class="n">ua_node_val</span><span class="p">,</span> <span class="n">log_probabilities</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">accum_func</span> <span class="o">=</span> <span class="n">_none_override_ternary</span><span class="p">(</span><span class="n">accum_func</span><span class="p">,</span> <span class="n">log_probabilities</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">prod</span><span class="p">)</span>
        <span class="n">aggregate_func</span> <span class="o">=</span> <span class="n">_none_override_ternary</span><span class="p">(</span>
            <span class="n">aggregate_func</span><span class="p">,</span> <span class="n">log_probabilities</span><span class="p">,</span> <span class="n">utils</span><span class="o">.</span><span class="n">logsumexp</span><span class="p">,</span> <span class="nb">sum</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
        <span class="c1"># first value is true probability, and second value is adjusted</span>
        <span class="n">node_probs</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="p">:</span> <span class="p">(</span><span class="n">ua_node_val</span><span class="p">,</span> <span class="n">ua_node_val</span><span class="p">)}</span>
        <span class="c1"># first value is vector of true probabilities, and second value is adjusted</span>
        <span class="n">node_above_probs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())):</span>
            <span class="c1"># All parents have been visited, so this_node_prob can be computed</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">():</span>
                <span class="n">this_node_prob</span> <span class="o">=</span> <span class="n">aggregate_func</span><span class="p">(</span><span class="n">node_above_probs</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">adjusted_this_node_prob</span> <span class="o">=</span> <span class="n">aggregate_func</span><span class="p">(</span><span class="n">node_above_probs</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">node_probs</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">this_node_prob</span><span class="p">,</span> <span class="n">adjusted_this_node_prob</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">this_node_prob</span> <span class="o">=</span> <span class="n">ua_node_val</span>
            <span class="c1"># Now add this node&#39;s probability to node_above_probs for all</span>
            <span class="c1"># children.</span>
            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="n">eset</span><span class="p">:</span>
                    <span class="p">(</span>
                        <span class="n">child_above_probs</span><span class="p">,</span>
                        <span class="n">child_above_adjusted_probs</span><span class="p">,</span>
                    <span class="p">)</span> <span class="o">=</span> <span class="n">node_above_probs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="p">([],</span> <span class="p">[]))</span>
                    <span class="n">child_above_probs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">accum_func</span><span class="p">([</span><span class="n">this_node_prob</span><span class="p">,</span> <span class="n">prob</span><span class="p">]))</span>
                    <span class="n">child_above_adjusted_probs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">accum_func</span><span class="p">([</span><span class="n">this_node_prob</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="n">adjust_func</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">child</span><span class="p">)])</span>
                    <span class="p">)</span>

        <span class="c1"># This must be done separately because otherwise we have no reverse</span>
        <span class="c1"># postorder guarantee on keys in node_probs.</span>
        <span class="k">if</span> <span class="n">collapse_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">collapsed_probs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span> <span class="ow">in</span> <span class="n">node_probs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">collapse_key</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">collapsed_probs</span><span class="p">:</span>
                    <span class="n">collapsed_probs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">prob</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">collapsed_probs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="n">collapsed_probs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">aggregate_func</span><span class="p">([</span><span class="n">val</span><span class="p">,</span> <span class="n">prob</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">collapsed_probs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">prob</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span> <span class="ow">in</span> <span class="n">node_probs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>


    <span class="k">def</span> <span class="nf">edge_probabilities</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">log_probabilities</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">normalize_edgeweights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">accum_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aggregate_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">start_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ua_node_val</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collapse_key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">edge</span><span class="p">:</span> <span class="n">edge</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">node_probabilities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_probabilities</span><span class="p">(</span>
            <span class="n">log_probabilities</span><span class="o">=</span><span class="n">log_probabilities</span><span class="p">,</span>
            <span class="n">edge_weight_func</span><span class="o">=</span><span class="n">edge_weight_func</span><span class="p">,</span>
            <span class="n">normalize_edgeweights</span><span class="o">=</span><span class="n">normalize_edgeweights</span><span class="p">,</span>
            <span class="n">accum_func</span><span class="o">=</span><span class="n">accum_func</span><span class="p">,</span>
            <span class="n">aggregate_func</span><span class="o">=</span><span class="n">aggregate_func</span><span class="p">,</span>
            <span class="n">start_func</span><span class="o">=</span><span class="n">start_func</span><span class="p">,</span>
            <span class="n">ua_node_val</span><span class="o">=</span><span class="n">ua_node_val</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">aggregate_func</span> <span class="o">=</span> <span class="n">_none_override_ternary</span><span class="p">(</span>
            <span class="n">aggregate_func</span><span class="p">,</span> <span class="n">log_probabilities</span><span class="p">,</span> <span class="n">utils</span><span class="o">.</span><span class="n">logsumexp</span><span class="p">,</span> <span class="nb">sum</span>
        <span class="p">)</span>
        <span class="n">accum_func</span> <span class="o">=</span> <span class="n">_none_override_ternary</span><span class="p">(</span><span class="n">accum_func</span><span class="p">,</span> <span class="n">log_probabilities</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">prod</span><span class="p">)</span>

        <span class="n">edge_probabilities</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_annotated_edges</span><span class="p">():</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">collapse_key</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
            <span class="n">prob_list</span> <span class="o">=</span> <span class="n">edge_probabilities</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">prob_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">accum_func</span><span class="p">([</span><span class="n">node_probabilities</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">prob</span><span class="p">]))</span>

        <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">aggregate_func</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">edge_probabilities</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

<div class="viewcode-block" id="HistoryDag.set_sample_mask">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.set_sample_mask">[docs]</a>
    <span class="k">def</span> <span class="nf">set_sample_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_selector</span><span class="p">,</span> <span class="n">log_probabilities</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Zero out edge weights for masked edges before calling</span>
<span class="sd">        :meth:`HistoryDag.fast_sample`. This should be equivalent to passing</span>
<span class="sd">        the same edge_selector function to :meth:`HistoryDag.sample`.</span>

<span class="sd">        Args:</span>
<span class="sd">            edge_selector: A function accepting an edge (a tuple of HistoryDagNode objects) and</span>
<span class="sd">                returning True of False. An edge marked False will be ineligible for sampling, unless</span>
<span class="sd">                all other edges in the same edge set are also marked False.</span>
<span class="sd">            log_probabilities: Since the mask is applied by modifying edge probabilities, one must specify</span>
<span class="sd">                whether those probabilities are on a log scale.</span>

<span class="sd">        Take care to verify that you shouldn&#39;t instead use :meth:`HistoryDag.probability_annotate` with</span>
<span class="sd">        a choice of ``edge_weight_func`` that takes into account the masking preferences.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">log_probabilities</span><span class="p">:</span>
            <span class="n">mask_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask_value</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">eset</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">edge_selector</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span> <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">eset</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
                <span class="c1"># If all mask values are false, then skip modifying probs.</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">val</span><span class="p">:</span>
                            <span class="n">eset</span><span class="o">.</span><span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask_value</span></div>


<div class="viewcode-block" id="HistoryDag.probability_annotate">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.probability_annotate">[docs]</a>
    <span class="k">def</span> <span class="nf">probability_annotate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">,</span>
        <span class="n">log_probabilities</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">normalize_edgeweights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">accum_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aggregate_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">start_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Uses the supplied edge weight function to compute conditional</span>
<span class="sd">        probabilities on edges.</span>

<span class="sd">        Conditional probabilities are annotated on the DAG&#39;s edges, so that future calls to e.g.</span>
<span class="sd">        :meth:`HistoryDag.sample` use the probability distribution determined by them.</span>

<span class="sd">        Args:</span>
<span class="sd">            edge_weight_func: A function accepting a parent node and a child node and returning the</span>
<span class="sd">                weight associated to that edge.</span>
<span class="sd">            log_probabilities: If True, all probabilities, and the values from ``edge_weight_func``, will</span>
<span class="sd">                be treated as log values.</span>
<span class="sd">            normalize_edgeweights: A function taking a list of weights and returning a normalized list of</span>
<span class="sd">                downward-conditional edge probabilities. The default is determined by ``log_probabilities``.</span>
<span class="sd">            accum_func: A function taking a list of probabilities for parts of a sub-history, and returning</span>
<span class="sd">                a probability for that sub-history. The default is determined by ``log_probabilities``.</span>
<span class="sd">            aggregate_func: A function taking a list of probabilities for alternative sub-histories, and</span>
<span class="sd">                returning the aggregated probability of all sub-histories. The default is determined by ``log_probabilities``.</span>
<span class="sd">            start_func: A function taking a leaf node and returning its starting weight. The default is</span>
<span class="sd">                determined by ``log_probabilities``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The sum of un-normalized probabilities, according to the provided edge_weight_func. This value can be used</span>
<span class="sd">            to normalize history probabilities computed with the same ``edge_weight_func`` provided to this method</span>
<span class="sd">            (for example, weights returned by :meth:`HistoryDag.weight_count`).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">normalize_log_edgeweights</span><span class="p">(</span><span class="n">weightlist</span><span class="p">):</span>
            <span class="n">normalization</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">logsumexp</span><span class="p">(</span><span class="n">weightlist</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">weight</span> <span class="o">-</span> <span class="n">normalization</span> <span class="k">for</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">weightlist</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="n">normalize_edgeweights</span> <span class="o">=</span> <span class="n">_none_override_ternary</span><span class="p">(</span>
            <span class="n">normalize_edgeweights</span><span class="p">,</span> <span class="n">log_probabilities</span><span class="p">,</span> <span class="n">normalize_log_edgeweights</span><span class="p">,</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="n">accum_func</span> <span class="o">=</span> <span class="n">_none_override_ternary</span><span class="p">(</span><span class="n">accum_func</span><span class="p">,</span> <span class="n">log_probabilities</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">prod</span><span class="p">)</span>
        <span class="n">aggregate_func</span> <span class="o">=</span> <span class="n">_none_override_ternary</span><span class="p">(</span>
            <span class="n">aggregate_func</span><span class="p">,</span> <span class="n">log_probabilities</span><span class="p">,</span> <span class="n">utils</span><span class="o">.</span><span class="n">logsumexp</span><span class="p">,</span> <span class="nb">sum</span>
        <span class="p">)</span>
        <span class="n">start_func</span> <span class="o">=</span> <span class="n">_none_override_ternary</span><span class="p">(</span>
            <span class="n">start_func</span><span class="p">,</span> <span class="n">log_probabilities</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_history_accum</span><span class="p">(</span>
            <span class="n">start_func</span><span class="p">,</span>
            <span class="n">edge_weight_func</span><span class="p">,</span>
            <span class="n">aggregate_func</span><span class="p">,</span>
            <span class="n">accum_func</span><span class="p">,</span>
            <span class="n">compute_edge_probabilities</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">normalize_edgeweights</span><span class="o">=</span><span class="n">normalize_edgeweights</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.natural_distribution_annotate">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.natural_distribution_annotate">[docs]</a>
    <span class="k">def</span> <span class="nf">natural_distribution_annotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log_probabilities</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set edge probabilities to 1/n, where n is the count of edges</span>
<span class="sd">        descending from the corresponding node-clade pair.</span>

<span class="sd">        This induces the &#39;natural&#39; distribution on histories, determined</span>
<span class="sd">        by the topology of the dag.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">log_probabilities</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">edgeweights</span><span class="p">(</span><span class="n">weightlist</span><span class="p">):</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weightlist</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="o">-</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">edgeweights</span><span class="p">(</span><span class="n">weightlist</span><span class="p">):</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weightlist</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">n</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">probability_annotate</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">normalize_edgeweights</span><span class="o">=</span><span class="n">edgeweights</span><span class="p">,</span>
            <span class="n">log_probabilities</span><span class="o">=</span><span class="n">log_probabilities</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.uniform_distribution_annotate">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.uniform_distribution_annotate">[docs]</a>
    <span class="k">def</span> <span class="nf">uniform_distribution_annotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log_probabilities</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjust edge probabilities so that the DAG expresses a uniform</span>
<span class="sd">        distribution on expressed trees.</span>

<span class="sd">        The probability assigned to each edge below a clade is</span>
<span class="sd">        proportional to the number of subtrees possible below that edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="n">log_probabilities</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">probability_annotate</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">:</span> <span class="n">val</span><span class="p">,</span> <span class="n">log_probabilities</span><span class="o">=</span><span class="n">log_probabilities</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.make_uniform">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.make_uniform">[docs]</a>
    <span class="k">def</span> <span class="nf">make_uniform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deprecated name for</span>
<span class="sd">        :meth:`HistoryDag.uniform_distribution_annotate`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniform_distribution_annotate</span><span class="p">()</span></div>


    <span class="c1"># #### End probability methods ####</span>

<div class="viewcode-block" id="HistoryDag.recompute_parents">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.recompute_parents">[docs]</a>
    <span class="k">def</span> <span class="nf">recompute_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Repopulate ``HistoryDagNode.parent`` attributes.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="n">node</span><span class="o">.</span><span class="n">parents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.convert_to_collapsed">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.convert_to_collapsed">[docs]</a>
    <span class="k">def</span> <span class="nf">convert_to_collapsed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Rebuilds the DAG so that no edge connects two nodes with the same</span>
<span class="sd">        label, unless one is a leaf node.</span>

<span class="sd">        The resulting DAG should express at least the collapsed</span>
<span class="sd">        histories present in the original.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())</span>
        <span class="n">nodedict</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span>
        <span class="n">edgequeue</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">parent</span><span class="p">,</span> <span class="n">target</span><span class="p">]</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">nodes</span> <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="k">while</span> <span class="n">edgequeue</span><span class="p">:</span>
            <span class="n">parent</span><span class="p">,</span> <span class="n">child</span> <span class="o">=</span> <span class="n">edgequeue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">clade</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">parent</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">child</span><span class="o">.</span><span class="n">label</span>
                <span class="ow">and</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">nodedict</span>
                <span class="ow">and</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">nodedict</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">child</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="n">parent_clade_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">clade</span><span class="p">]</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
                <span class="n">new_parent_clades</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="nb">frozenset</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="p">{</span><span class="n">clade</span><span class="p">}</span>
                <span class="p">)</span> <span class="o">|</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">newparenttemp</span> <span class="o">=</span> <span class="n">empty_node</span><span class="p">(</span>
                    <span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">new_parent_clades</span><span class="p">,</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">newparenttemp</span> <span class="ow">in</span> <span class="n">nodedict</span><span class="p">:</span>
                    <span class="n">newparent</span> <span class="o">=</span> <span class="n">nodedict</span><span class="p">[</span><span class="n">newparenttemp</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newparent</span> <span class="o">=</span> <span class="n">newparenttemp</span>
                    <span class="n">nodedict</span><span class="p">[</span><span class="n">newparent</span><span class="p">]</span> <span class="o">=</span> <span class="n">newparent</span>
                <span class="c1"># Add parents of parent to newparent</span>
                <span class="k">for</span> <span class="n">grandparent</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="n">grandparent</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">newparent</span><span class="p">)</span>  <span class="c1"># check parents logic</span>
                    <span class="n">edgequeue</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">grandparent</span><span class="p">,</span> <span class="n">newparent</span><span class="p">])</span>
                <span class="c1"># Add children of other clades to newparent</span>
                <span class="k">for</span> <span class="n">otherclade</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">otherclade</span> <span class="o">!=</span> <span class="n">clade</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">othertarget</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">otherclade</span><span class="p">]</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
                            <span class="n">newparent</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">othertarget</span><span class="p">)</span>
                            <span class="n">edgequeue</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">newparent</span><span class="p">,</span> <span class="n">othertarget</span><span class="p">])</span>
                <span class="c1"># Add children of old child to newparent</span>
                <span class="k">for</span> <span class="n">grandchild</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                    <span class="n">newparent</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">grandchild</span><span class="p">)</span>
                    <span class="n">edgequeue</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">newparent</span><span class="p">,</span> <span class="n">grandchild</span><span class="p">])</span>
                <span class="c1"># Remove the edge we were fixing from old parent</span>
                <span class="n">parent</span><span class="o">.</span><span class="n">remove_edge_by_clade_and_id</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">clade</span><span class="p">)</span>
                <span class="c1"># Clean up the DAG:</span>
                <span class="c1"># Delete old parent if it is no longer a valid node</span>
                <span class="k">if</span> <span class="n">parent_clade_edges</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Remove old parent as child of all of its parents</span>
                    <span class="c1"># no need for recursion here, all of its parents had</span>
                    <span class="c1"># edges added to new parent from the same clade.</span>
                    <span class="n">upclade</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">grandparent</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">parents</span><span class="p">):</span>
                        <span class="n">grandparent</span><span class="o">.</span><span class="n">remove_edge_by_clade_and_id</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">upclade</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">child2</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                        <span class="n">child2</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">child2</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                            <span class="n">child2</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">nodedict</span><span class="o">=</span><span class="n">nodedict</span><span class="p">)</span>
                    <span class="n">nodedict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

                <span class="c1"># Remove child, if child no longer has parents</span>
                <span class="k">if</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">child</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="c1"># This recursively removes children of child too, if necessary</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">nodedict</span><span class="o">=</span><span class="n">nodedict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span></div>


<div class="viewcode-block" id="HistoryDag.add_node_at_all_possible_places">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.add_node_at_all_possible_places">[docs]</a>
    <span class="k">def</span> <span class="nf">add_node_at_all_possible_places</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_leaf_id</span><span class="p">,</span> <span class="n">id_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sequence&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inserts a sequence into the dag such that every tree in the dag now</span>
<span class="sd">        contains that new node.</span>

<span class="sd">        This method adds the new node as a leaf node by connecting it as</span>
<span class="sd">        a child of every non-leaf node in the original dag. The</span>
<span class="sd">        resulting dag has one new node corresponding to the added</span>
<span class="sd">        sequence as well as copies of all internal nodes corresponding</span>
<span class="sd">        to parents (and more ancestral nodes) to the added sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">postorder</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">new_leaf_id</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">id_name</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">postorder</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="p">):</span>
            <span class="c1"># make sure all connections are correctly built before manipulating dag</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>

            <span class="c1"># create a new node corresponding to new_sequence</span>
            <span class="n">new_leaf</span> <span class="o">=</span> <span class="n">empty_node</span><span class="p">(</span>
                <span class="n">postorder</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">id_name</span><span class="p">:</span> <span class="n">new_leaf_id</span><span class="p">}),</span> <span class="p">{},</span> <span class="kc">None</span>
            <span class="p">)</span>

            <span class="n">dagnodes</span> <span class="o">=</span> <span class="p">{</span><span class="n">new_leaf</span><span class="p">:</span> <span class="n">new_leaf</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">postorder</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()):</span>
                    <span class="c1"># create a copy of the node that has new_leaf as a direct child</span>
                    <span class="n">clades</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">frozenset</span><span class="p">([</span><span class="n">new_leaf</span><span class="o">.</span><span class="n">label</span><span class="p">])]</span>
                    <span class="n">node_copy_as_parent</span> <span class="o">=</span> <span class="n">empty_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">clades</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="n">dagnodes</span><span class="p">[</span><span class="n">node_copy_as_parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_copy_as_parent</span>

                    <span class="c1"># for each child clade, create a copy of the node as an ancestor</span>
                    <span class="c1"># of new_leaf through that clade</span>
                    <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clade</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">clades</span> <span class="o">=</span> <span class="p">[</span>
                                <span class="n">c</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">clade</span> <span class="k">else</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">clade</span> <span class="o">|</span> <span class="p">{</span><span class="n">new_leaf</span><span class="o">.</span><span class="n">label</span><span class="p">})</span>
                                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span>
                            <span class="p">]</span>
                            <span class="n">node_copy_as_ancestor</span> <span class="o">=</span> <span class="n">empty_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">clades</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                            <span class="n">dagnodes</span><span class="p">[</span><span class="n">node_copy_as_ancestor</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_copy_as_ancestor</span>

                    <span class="c1"># if the current node is internal to any trees in the dag, then keep</span>
                    <span class="c1"># a copy of the node that does not have new_node as a descendant</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">]):</span>
                        <span class="n">nodecopy</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">()</span>
                        <span class="n">dagnodes</span><span class="p">[</span><span class="n">nodecopy</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodecopy</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nodecopy</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">()</span>
                    <span class="n">dagnodes</span><span class="p">[</span><span class="n">nodecopy</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodecopy</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">history_dag_from_nodes</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">dagnodes</span><span class="p">))</span><span class="o">.</span><span class="n">dagroot</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.insert_node">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.insert_node">[docs]</a>
    <span class="nd">@get_default_args</span><span class="p">([</span><span class="s2">&quot;edge_weight_func&quot;</span><span class="p">],</span> <span class="n">positional_count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">insert_node</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_leaf_id</span><span class="p">,</span>
        <span class="n">id_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sequence&quot;</span><span class="p">,</span>
        <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
            <span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="n">HistoryDagNode</span><span class="p">],</span> <span class="n">Weight</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">parsimony_utils</span><span class="o">.</span><span class="n">hamming_edge_weight</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inserts a sequence into the DAG.</span>

<span class="sd">        Sequence will be inserted as a child of the dagnode(s)</span>
<span class="sd">        realizing the minimum overall distance between sequences, and also added</span>
<span class="sd">        to the dag as a child of other nodes in such a way as to guarantee</span>
<span class="sd">        that every tree in the DAG now contains the new sequence.</span>

<span class="sd">        The choice of other nodes is computed by looking at the set of</span>
<span class="sd">        nodes that are `incompatible` with the first minimizing node.</span>
<span class="sd">        For a full description of this, see the docstring for the method-local</span>
<span class="sd">        function ``incompatible``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># all nodes in the dag except for the UA</span>
        <span class="n">postorder</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">())[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">new_leaf_id</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">id_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">postorder</span><span class="p">]):</span>

            <span class="k">def</span> <span class="nf">insert_node_as_sibling</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">sib</span><span class="p">):</span>
                <span class="n">altered_nodes</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="k">def</span> <span class="nf">follow_up</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">old_node_cu</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">old_node_cu</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                            <span class="n">old_p</span> <span class="o">=</span> <span class="n">p</span>
                            <span class="n">p_clade_union</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
                            <span class="n">edgeset</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">old_node_cu</span><span class="p">)</span>
                            <span class="n">p</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()]</span> <span class="o">=</span> <span class="n">edgeset</span>
                            <span class="n">altered_nodes</span><span class="p">[</span><span class="n">old_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
                            <span class="n">follow_up</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p_clade_union</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">sib</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">clade_union</span><span class="p">():</span>
                        <span class="n">old_parent</span> <span class="o">=</span> <span class="n">parent</span>
                        <span class="n">parent_clade_union</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
                        <span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">])]</span> <span class="o">=</span> <span class="n">EdgeSet</span><span class="p">([</span><span class="n">node</span><span class="p">])</span>
                        <span class="n">altered_nodes</span><span class="p">[</span><span class="n">old_parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span>
                        <span class="n">follow_up</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">parent_clade_union</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">altered_nodes</span>

            <span class="k">def</span> <span class="nf">insert_node_as_child</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
                <span class="n">altered_nodes</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="k">def</span> <span class="nf">follow_up</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">old_node_cu</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">old_node_cu</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">clades</span><span class="p">:</span>
                            <span class="n">old_p</span> <span class="o">=</span> <span class="n">p</span>
                            <span class="n">p_clade_union</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
                            <span class="n">edgeset</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">old_node_cu</span><span class="p">)</span>
                            <span class="n">p</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()]</span> <span class="o">=</span> <span class="n">edgeset</span>
                            <span class="n">altered_nodes</span><span class="p">[</span><span class="n">old_p</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
                            <span class="n">follow_up</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p_clade_union</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">clade_union</span><span class="p">():</span>
                    <span class="n">old_parent</span> <span class="o">=</span> <span class="n">parent</span>
                    <span class="n">parent_clade_union</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span>
                    <span class="n">parent</span><span class="o">.</span><span class="n">clades</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">])]</span> <span class="o">=</span> <span class="n">EdgeSet</span><span class="p">([</span><span class="n">node</span><span class="p">])</span>
                    <span class="n">altered_nodes</span><span class="p">[</span><span class="n">old_parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span>
                    <span class="n">follow_up</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">parent_clade_union</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">altered_nodes</span>

            <span class="k">def</span> <span class="nf">find_min_dist_nodes</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">node_set</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Finds the set of nodes in arg `node_set` that realize the</span>
<span class="sd">                minimum distance to `new_node` (sort so that leaf nodes are at</span>
<span class="sd">                the end of the list)&quot;&quot;&quot;</span>
                <span class="n">return_set</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">min_dist</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_set</span><span class="p">:</span>
                    <span class="n">this_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">new_node</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">this_dist</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">:</span>
                        <span class="n">return_set</span> <span class="o">=</span> <span class="p">[(</span><span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">(),</span> <span class="n">node</span><span class="p">)]</span>
                        <span class="n">min_dist</span> <span class="o">=</span> <span class="n">this_dist</span>
                    <span class="k">elif</span> <span class="n">this_dist</span> <span class="o">&lt;=</span> <span class="n">min_dist</span><span class="p">:</span>
                        <span class="n">return_set</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">(),</span> <span class="n">node</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="n">return_set</span><span class="p">)))[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">def</span> <span class="nf">incompatible</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Checks if nodes n1 and n2 are `incompatible` in the sense</span>
<span class="sd">                that, based on their clade sets, they cannot both come from the</span>
<span class="sd">                same tree in the DAG.</span>

<span class="sd">                Note that, just because 2 nodes might be compatible does</span>
<span class="sd">                not mean that they actually are in the same tree. Merely</span>
<span class="sd">                that they could be.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="n">n1</span><span class="o">.</span><span class="n">is_root</span><span class="p">()</span> <span class="ow">or</span> <span class="n">n2</span><span class="o">.</span><span class="n">is_root</span><span class="p">():</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">n1</span> <span class="o">==</span> <span class="n">n2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">n1</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">B</span> <span class="k">for</span> <span class="n">B</span> <span class="ow">in</span> <span class="n">n2</span><span class="o">.</span><span class="n">child_clades</span><span class="p">()]):</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">n2</span><span class="o">.</span><span class="n">clade_union</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">B</span> <span class="k">for</span> <span class="n">B</span> <span class="ow">in</span> <span class="n">n1</span><span class="o">.</span><span class="n">child_clades</span><span class="p">()]):</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="n">leaf_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">:</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()}</span>

            <span class="k">def</span> <span class="nf">incompatible_set</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">nodeset</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Returns the set of all nodes incompatible to `node` that</span>
<span class="sd">                satisfy the conditions:</span>

<span class="sd">                1. incompatible nodes lie in the path between the leaf</span>
<span class="sd">                nodes reachable by arg `node` and the UA,</span>
<span class="sd">                2. only the subset of incompatible nodes that are also in</span>
<span class="sd">                the set of nodes arg `nodeset`</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">leaf_label</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clade_union</span><span class="p">():</span>
                    <span class="k">yield from</span> <span class="p">(</span>
                        <span class="n">n</span>
                        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_above</span><span class="p">(</span>
                            <span class="n">leaf_dict</span><span class="p">[</span><span class="n">leaf_label</span><span class="p">],</span> <span class="n">recompute_parents</span><span class="o">=</span><span class="kc">False</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="ow">in</span> <span class="n">nodeset</span> <span class="ow">and</span> <span class="n">incompatible</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
                    <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">empty_node</span><span class="p">(</span>
                <span class="n">postorder</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">id_name</span><span class="p">:</span> <span class="n">new_leaf_id</span><span class="p">}),</span> <span class="p">{},</span> <span class="kc">None</span>
            <span class="p">)</span>
            <span class="n">changed_nodes</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">incompatible_nodes_so_far</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">postorder</span><span class="p">)</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">incompatible_nodes_so_far</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">min_dist_nodes</span> <span class="o">=</span> <span class="n">find_min_dist_nodes</span><span class="p">(</span>
                    <span class="n">new_node</span><span class="p">,</span> <span class="n">incompatible_nodes_so_far</span><span class="p">,</span> <span class="n">edge_weight_func</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">other_node</span> <span class="ow">in</span> <span class="n">min_dist_nodes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">other_node</span> <span class="ow">in</span> <span class="n">incompatible_nodes_so_far</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">other_node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">changed_nodes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">changed_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                                    <span class="n">insert_node_as_sibling</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">other_node</span><span class="p">)</span>
                                <span class="p">)</span>
                                <span class="n">incompatible_nodes_so_far</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">incompatible_nodes_so_far</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">other_node</span><span class="p">)</span>
                            <span class="n">incompatible_nodes_so_far</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                                <span class="n">incompatible_set</span><span class="p">(</span><span class="n">other_node</span><span class="p">,</span> <span class="n">incompatible_nodes_so_far</span><span class="p">)</span>
                            <span class="p">)</span>
                            <span class="n">changed_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                                <span class="n">insert_node_as_child</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">other_node</span><span class="p">)</span>
                            <span class="p">)</span>
                            <span class="n">incompatible_nodes_so_far</span> <span class="o">=</span> <span class="p">[</span>
                                <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">changed_nodes</span> <span class="k">else</span> <span class="n">changed_nodes</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">incompatible_nodes_so_far</span>
                            <span class="p">]</span>

            <span class="k">for</span> <span class="n">clade</span><span class="p">,</span> <span class="n">edgeset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="o">.</span><span class="n">clades</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">edgeset</span><span class="o">.</span><span class="n">set_targets</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">n</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">changed_nodes</span> <span class="k">else</span> <span class="n">changed_nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">edgeset</span><span class="o">.</span><span class="n">targets</span>
                    <span class="p">]</span>
                <span class="p">)</span></div>


    <span class="c1"># ######## DAG Traversal Methods ########</span>

<div class="viewcode-block" id="HistoryDag.postorder_above">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.postorder_above">[docs]</a>
    <span class="k">def</span> <span class="nf">postorder_above</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">terminal_node</span><span class="p">,</span> <span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">recompute_parents</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recursive postorder traversal of all ancestors of a (possibly</span>
<span class="sd">        internal) node. This traversal is postorder with respect to reversed</span>
<span class="sd">        edge directions. With respect to standard edge directions (pointing</span>
<span class="sd">        towards leaves), the traversal order guarantees that all of a node&#39;s</span>
<span class="sd">        parents will be visited before the node itself.</span>

<span class="sd">        Args:</span>
<span class="sd">            terminal_node: The node whose ancestors should be included in the</span>
<span class="sd">                traversal. This must actually be a node in `self`, not simply</span>
<span class="sd">                compare equal to a node in `self`.</span>
<span class="sd">            skip_ua_node: If True, the UA node will not be included in the traversal</span>
<span class="sd">            recompute_parents: If False, node parent sets will not be recomputed.</span>
<span class="sd">                This makes many repeated calls to postorder_above much faster.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Generator on nodes that lie on any path between node_as_leaf and UA node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">recompute_parents</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recompute_parents</span><span class="p">()</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">HistoryDagNode</span><span class="p">):</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">id</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">skip_ua_node</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">parent</span><span class="o">.</span><span class="n">is_ua_node</span><span class="p">()):</span>
                        <span class="k">yield from</span> <span class="n">traverse</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">node</span>

        <span class="k">yield from</span> <span class="n">traverse</span><span class="p">(</span><span class="n">terminal_node</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.postorder">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.postorder">[docs]</a>
    <span class="k">def</span> <span class="nf">postorder</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">include_root</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recursive postorder traversal of the history DAG.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Generator on nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">HistoryDagNode</span><span class="p">):</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">id</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="k">yield from</span> <span class="n">traverse</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">node</span>

        <span class="k">yield from</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="p">)</span></div>


<div class="viewcode-block" id="HistoryDag.preorder">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.HistoryDag.preorder">[docs]</a>
    <span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">skip_ua_node</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_root</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recursive postorder traversal of the history DAG.</span>

<span class="sd">        Careful! This is not guaranteed to visit a parent node before any of its children.</span>
<span class="sd">        for that, need reverse postorder traversal.</span>

<span class="sd">        If skip_ua_node is passed, the universal ancestor node will be skipped.</span>
<span class="sd">        skip_root is provided as a backwards-compatible synonym of skip_ua_node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Generator on nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">skip_root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skip_ua_node</span> <span class="o">=</span> <span class="n">skip_root</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">HistoryDagNode</span><span class="p">):</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="k">yield</span> <span class="n">node</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">id</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="k">yield from</span> <span class="n">traverse</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

        <span class="n">gen</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagroot</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">skip_ua_node</span><span class="p">:</span>
            <span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="k">yield from</span> <span class="n">gen</span></div>
</div>



<span class="c1"># DAG creation functions</span>


<div class="viewcode-block" id="from_tree">
<a class="viewcode-back" href="../../stubs/historydag.from_tree.html#historydag.from_tree">[docs]</a>
<span class="k">def</span> <span class="nf">from_tree</span><span class="p">(</span>
    <span class="n">treeroot</span><span class="p">:</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">,</span>
    <span class="n">label_features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">label_functions</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">attr_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">child_node_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
        <span class="p">[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">,</span>
    <span class="n">leaf_node_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
        <span class="p">[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">,</span>
    <span class="n">edge_weight_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build a tree-shaped :meth:`historydag.HistoryDag` (a &#39;history&#39;) object</span>
<span class="sd">    from the provided tree data.</span>

<span class="sd">    Default arguments are suitable for loading a :class:`ete3.Tree`, but by providing</span>
<span class="sd">    appropriate `child_node_func` and `leaf_node_func`, any data structure implementing</span>
<span class="sd">    a tree can be used.</span>

<span class="sd">    Args:</span>
<span class="sd">        treeroot: The root node of a tree to be converted to HistoryDag history</span>
<span class="sd">        label_features: tree node attribute names to be used as HistoryDagNode label fields.</span>
<span class="sd">            Each attribute name must be accessible by ``getattr(treenode, name)``.</span>
<span class="sd">            Field names provided in `label_functions` will take precedence.</span>
<span class="sd">        label_functions: dictionary keyed by additional label field names, containing</span>
<span class="sd">            functions mapping tree nodes to intended label field values.</span>
<span class="sd">        attr_func: function to populate HistoryDag node `attr` attribute,</span>
<span class="sd">            which is not used to distinguish nodes, and may be overwritten</span>
<span class="sd">            by `attr` of another node with the same label and child clades.</span>
<span class="sd">        child_node_func: function taking a tree node and returning an iterable</span>
<span class="sd">            containing the node&#39;s children. By default, accesses node&#39;s</span>
<span class="sd">            `children` attribute.</span>
<span class="sd">        leaf_node_func: function accepting a tree node and returning an iterable</span>
<span class="sd">            containing the leaf nodes accessible from that node.</span>
<span class="sd">        edge_weight_func: function accepting a tree node and returning the weight</span>
<span class="sd">            of that node&#39;s parent edge.</span>

<span class="sd">    Returns:</span>
<span class="sd">        HistoryDag object, which has the same topology as the input tree, with the required</span>
<span class="sd">        UA node added as a new root.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># see https://stackoverflow.com/questions/50298582/why-does-python-asyncio-loop-call-soon-overwrite-data</span>
    <span class="c1"># or https://stackoverflow.com/questions/25670516/strange-overwriting-occurring-when-using-lambda-functions-as-dict-values</span>
    <span class="c1"># for why we can&#39;t just use lambda funcs defined in dict comprehension.</span>
    <span class="k">def</span> <span class="nf">getnamefunc</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">getter</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">getter</span>

    <span class="n">feature_maps</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">getnamefunc</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">label_features</span><span class="p">}</span>
    <span class="n">feature_maps</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">label_functions</span><span class="p">)</span>
    <span class="n">Label</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span><span class="s2">&quot;Label&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="n">label</span><span class="p">,</span> <span class="n">Any</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">feature_maps</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>  <span class="c1"># type: ignore</span>

    <span class="k">def</span> <span class="nf">node_label</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">):</span>
        <span class="c1"># This should not fail silently! Only DAG UA node is allowed to have</span>
        <span class="c1"># default (None) label values.</span>
        <span class="k">return</span> <span class="n">Label</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">feature_maps</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>

    <span class="k">def</span> <span class="nf">leaf_names</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">node_label</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">leaf_node_func</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_unrooted_from_tree</span><span class="p">(</span><span class="n">treeroot</span><span class="p">):</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="n">HistoryDagNode</span><span class="p">(</span>
            <span class="n">node_label</span><span class="p">(</span><span class="n">treeroot</span><span class="p">),</span>
            <span class="p">{</span>
                <span class="n">leaf_names</span><span class="p">(</span><span class="n">child</span><span class="p">):</span> <span class="n">EdgeSet</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">_unrooted_from_tree</span><span class="p">(</span><span class="n">child</span><span class="p">)],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="n">edge_weight_func</span><span class="p">(</span><span class="n">child</span><span class="p">)]</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">child_node_func</span><span class="p">(</span><span class="n">treeroot</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="n">attr_func</span><span class="p">(</span><span class="n">treeroot</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">dag</span>

    <span class="c1"># Check for unique leaf labels:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">leaf_node_func</span><span class="p">(</span><span class="n">treeroot</span><span class="p">)))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaf_names</span><span class="p">(</span><span class="n">treeroot</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;This tree&#39;s leaves are not labeled uniquely. Check your tree, &quot;</span>
            <span class="s2">&quot;or modify the label fields so that leaves are unique.</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Checking for unifurcation is handled in HistoryDagNode.__init__.</span>

    <span class="n">dag</span> <span class="o">=</span> <span class="n">_unrooted_from_tree</span><span class="p">(</span><span class="n">treeroot</span><span class="p">)</span>
    <span class="n">dagroot</span> <span class="o">=</span> <span class="n">UANode</span><span class="p">(</span><span class="n">EdgeSet</span><span class="p">([</span><span class="n">dag</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="n">edge_weight_func</span><span class="p">(</span><span class="n">treeroot</span><span class="p">)]))</span>
    <span class="k">return</span> <span class="n">HistoryDag</span><span class="p">(</span><span class="n">dagroot</span><span class="p">)</span></div>


    <span class="c1"># name_func,</span>
    <span class="c1"># show_internal=False,</span>
    <span class="c1"># compact=False,</span>
    <span class="c1"># sort_method=None,</span>


<div class="viewcode-block" id="ascii_compare_histories">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.ascii_compare_histories">[docs]</a>
<span class="k">def</span> <span class="nf">ascii_compare_histories</span><span class="p">(</span>
    <span class="n">history1</span><span class="p">,</span>
    <span class="n">history2</span><span class="p">,</span>
    <span class="n">name_func</span><span class="p">,</span>
    <span class="n">name_func2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A convenience function to print two histories as ascii art trees side-</span>
<span class="sd">    by-side.</span>

<span class="sd">    Provided histories can be HistoryDag or HistoryDagNode objects, so all or part</span>
<span class="sd">    of two histories may be compared.</span>

<span class="sd">    Args:</span>
<span class="sd">        history1: The first history to compare. Will appear on the left</span>
<span class="sd">        history2: The second history to compare. Will appear on the right</span>
<span class="sd">        name_func: A function mapping each HistoryDagNode to a node name string.</span>
<span class="sd">        name_func2: A different name_func to be used for history2. If not provided,</span>
<span class="sd">            ``name_func`` will be used.</span>
<span class="sd">        kwargs: This function also accepts all keyword arguments allowed by</span>
<span class="sd">            :meth:`HistoryDag.to_ascii`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name_func2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name_func2</span> <span class="o">=</span> <span class="n">name_func</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">history1</span><span class="o">.</span><span class="n">to_ascii</span><span class="p">(</span><span class="n">name_func</span><span class="o">=</span><span class="n">name_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">history2</span><span class="o">.</span><span class="n">to_ascii</span><span class="p">(</span><span class="n">name_func</span><span class="o">=</span><span class="n">name_func2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># There are no tabs in the ascii lines, only constant-width characters.</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">a1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="c1"># expand all lines in a1 so they have len offset</span>
    <span class="n">a1padded</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">a1</span><span class="p">:</span>
        <span class="n">add</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">a1padded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="n">add</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a1padded</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">l1</span> <span class="o">+</span> <span class="n">l2</span><span class="p">)</span></div>



<div class="viewcode-block" id="history_dag_from_trees">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.history_dag_from_trees">[docs]</a>
<span class="k">def</span> <span class="nf">history_dag_from_trees</span><span class="p">(</span>
    <span class="n">treelist</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span>
    <span class="n">label_features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a :class:`historydag.HistoryDag` from a list of trees.</span>

<span class="sd">    Default arguments are suitable for loading lists of :class:`ete3.Tree`s, but</span>
<span class="sd">    any tree data structure can be used by providing appropriate functions to</span>
<span class="sd">    `child_node_func` and `leaf_node_func` keyword arguments.</span>

<span class="sd">    Args:</span>
<span class="sd">        treelist: List of root nodes of input trees.</span>
<span class="sd">        label_features: tree node attribute names to be used as HistoryDagNode label fields.</span>
<span class="sd">            Each attribute name must be accessible by ``getattr(treenode, name)``.</span>
<span class="sd">            Field names provided in `label_functions` keyword argument will take precedence.</span>
<span class="sd">        kwargs: Passed to :meth:`historydag.from_tree`. See docstring</span>
<span class="sd">            for that method for argument details</span>

<span class="sd">    Returns:</span>
<span class="sd">        :class:`historydag.HistoryDag` constructed from input trees.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">history_dag_from_histories</span><span class="p">(</span>
        <span class="p">[</span><span class="n">from_tree</span><span class="p">(</span><span class="n">treeroot</span><span class="p">,</span> <span class="n">label_features</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">treeroot</span> <span class="ow">in</span> <span class="n">treelist</span><span class="p">]</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="history_dag_from_etes">
<a class="viewcode-back" href="../../stubs/historydag.history_dag_from_etes.html#historydag.history_dag_from_etes">[docs]</a>
<span class="k">def</span> <span class="nf">history_dag_from_etes</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Deprecated name for :meth:`historydag.history_dag_from_trees`&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">history_dag_from_trees</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="from_newick">
<a class="viewcode-back" href="../../stubs/historydag.from_newick.html#historydag.from_newick">[docs]</a>
<span class="k">def</span> <span class="nf">from_newick</span><span class="p">(</span>
    <span class="n">tree</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">label_features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">label_functions</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">newick_format</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="n">attr_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a history DAG using a newick string. Internally, utilizes newick</span>
<span class="sd">    parsing features provided by ete3, then calls :meth:`from_tree` on the</span>
<span class="sd">    resulting ete3.Tree object.</span>

<span class="sd">    Args:</span>
<span class="sd">        tree: newick string representation of a tree. May contain extended node data</span>
<span class="sd">            in &#39;extended newick format&#39; used by ete3.</span>
<span class="sd">        label_features: (passed to :meth:`from_tree`) list of features to be used as label</span>
<span class="sd">            fields in resulting history DAG.  &#39;name&#39; refers to the node name string in the</span>
<span class="sd">            standard newick format. See ete3 docs for more details.</span>
<span class="sd">        newick_format: ete3 format number of passed newick string. See ete3 docs for details.</span>
<span class="sd">        label_functions: (passed to :meth:`from_tree`)</span>
<span class="sd">        attr_func: (passed to :meth:`from_tree`)</span>

<span class="sd">    Returns:</span>
<span class="sd">        HistoryDag object, which has the same topology as the input newick tree, with the</span>
<span class="sd">        required UA node added as a new root.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">etetree</span> <span class="o">=</span> <span class="n">ete3</span><span class="o">.</span><span class="n">Tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">newick_format</span><span class="p">)</span>
    <span class="c1"># from_tree checks that leaves are labeled uniquely. If this function is</span>
    <span class="c1"># ever rewritten to avoid ete newick parsing, we&#39;d need to do that here.</span>
    <span class="k">return</span> <span class="n">from_tree</span><span class="p">(</span>
        <span class="n">etetree</span><span class="p">,</span> <span class="n">label_features</span><span class="p">,</span> <span class="n">label_functions</span><span class="o">=</span><span class="n">label_functions</span><span class="p">,</span> <span class="n">attr_func</span><span class="o">=</span><span class="n">attr_func</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="history_dag_from_newicks">
<a class="viewcode-back" href="../../stubs/historydag.history_dag_from_newicks.html#historydag.history_dag_from_newicks">[docs]</a>
<span class="k">def</span> <span class="nf">history_dag_from_newicks</span><span class="p">(</span>
    <span class="n">newicklist</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">label_features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">label_functions</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">attr_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ete3</span><span class="o">.</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">newick_format</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build a history DAG from a list of newick strings.</span>

<span class="sd">    See :meth:`from_newick` for argument details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">history_dag_from_histories</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">from_newick</span><span class="p">(</span>
                <span class="n">tree</span><span class="p">,</span>
                <span class="n">label_features</span><span class="p">,</span>
                <span class="n">label_functions</span><span class="o">=</span><span class="n">label_functions</span><span class="p">,</span>
                <span class="n">attr_func</span><span class="o">=</span><span class="n">attr_func</span><span class="p">,</span>
                <span class="n">newick_format</span><span class="o">=</span><span class="n">newick_format</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">newicklist</span>
        <span class="p">]</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="history_dag_from_histories">
<a class="viewcode-back" href="../../stubs/historydag.history_dag_from_histories.html#historydag.history_dag_from_histories">[docs]</a>
<span class="k">def</span> <span class="nf">history_dag_from_histories</span><span class="p">(</span><span class="n">treelist</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">HistoryDag</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build a history DAG from a list of history DAGs which are histories.&quot;&quot;&quot;</span>
    <span class="n">dag</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">treelist</span><span class="p">))</span>
    <span class="n">dag</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">treelist</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dag</span></div>



<div class="viewcode-block" id="history_dag_from_clade_trees">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.history_dag_from_clade_trees">[docs]</a>
<span class="k">def</span> <span class="nf">history_dag_from_clade_trees</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Deprecated name for :meth:`history_dag_from_histories`&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">history_dag_from_histories</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="history_dag_from_nodes">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.history_dag_from_nodes">[docs]</a>
<span class="k">def</span> <span class="nf">history_dag_from_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">HistoryDagNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">HistoryDag</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Take an iterable containing HistoryDagNodes, and build a HistoryDag from</span>
<span class="sd">    those nodes.&quot;&quot;&quot;</span>
    <span class="c1"># use dictionary to preserve order</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">():</span> <span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span>
    <span class="c1"># check for UA node in passed set, and recover if present:</span>
    <span class="n">ua_node</span> <span class="o">=</span> <span class="n">UANode</span><span class="p">(</span><span class="n">EdgeSet</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">ua_node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">ua_node</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">ua_node</span><span class="p">]</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">()</span>
        <span class="n">nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ua_node</span><span class="p">)</span>
    <span class="n">clade_dict</span> <span class="o">=</span> <span class="n">_clade_union_dict</span><span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">edge_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">node</span><span class="p">:</span> <span class="p">[</span><span class="n">child</span> <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">clades</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">clade_dict</span><span class="p">[</span><span class="n">clade</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span>
    <span class="p">}</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="s2">&quot;&quot;</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">children</span> <span class="ow">in</span> <span class="n">edge_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">children</span><span class="p">}</span>
    <span class="n">source_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">children</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">edge_dict</span><span class="p">[</span><span class="n">ua_node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">children</span> <span class="ow">in</span> <span class="n">edge_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">HistoryDag</span><span class="p">(</span><span class="n">ua_node</span><span class="p">)</span></div>



<div class="viewcode-block" id="make_binary_complete_dag">
<a class="viewcode-back" href="../../stubs/historydag.dag.html#historydag.make_binary_complete_dag">[docs]</a>
<span class="k">def</span> <span class="nf">make_binary_complete_dag</span><span class="p">(</span><span class="n">leaf_labels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Produce a history DAG containing all binary topologies on the provided</span>
<span class="sd">    iterable of leaf labels.&quot;&quot;&quot;</span>
    <span class="n">leaf_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">leaf_labels</span><span class="p">)</span>
    <span class="n">model_label</span> <span class="o">=</span> <span class="n">leaf_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_label</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Provided labels must be a historydag Label type (a typing.NamedTuple instance)&quot;</span>
        <span class="p">)</span>
    <span class="n">field_values</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">Ellipsis</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">model_label</span><span class="p">)</span>
    <span class="n">internal_label</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">model_label</span><span class="p">)(</span><span class="o">*</span><span class="n">field_values</span><span class="p">)</span>

    <span class="n">node_set</span> <span class="o">=</span> <span class="p">{</span><span class="n">UANode</span><span class="p">(</span><span class="n">EdgeSet</span><span class="p">())}</span>
    <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">utils</span><span class="o">.</span><span class="n">powerset</span><span class="p">(</span><span class="n">leaf_labels</span><span class="p">,</span> <span class="n">start_size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Now need to get all splits of this clade into two child clades</span>
        <span class="n">cladesize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clade</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child_mask</span> <span class="ow">in</span> <span class="n">utils</span><span class="o">.</span><span class="n">powerset</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="n">cladesize</span><span class="p">),</span> <span class="n">start_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">end_size</span><span class="o">=</span><span class="n">cladesize</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">):</span>
            <span class="n">splitter_mask</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">cladesize</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">child_mask</span><span class="p">:</span>
                <span class="n">splitter_mask</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">clade1</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span>
                <span class="n">clade</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">flag</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">splitter_mask</span><span class="p">)</span> <span class="k">if</span> <span class="n">flag</span>
            <span class="p">)</span>
            <span class="n">clade2</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span>
                <span class="n">clade</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">flag</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">splitter_mask</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span>
            <span class="p">)</span>
            <span class="n">node_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                <span class="n">HistoryDagNode</span><span class="p">(</span>
                    <span class="n">internal_label</span><span class="p">,</span>
                    <span class="p">{</span><span class="n">clade1</span><span class="p">:</span> <span class="n">EdgeSet</span><span class="p">(),</span> <span class="n">clade2</span><span class="p">:</span> <span class="n">EdgeSet</span><span class="p">()},</span>
                    <span class="p">{},</span>
                <span class="p">)</span>
            <span class="p">)</span>
    <span class="k">for</span> <span class="n">leaf_label</span> <span class="ow">in</span> <span class="n">leaf_labels</span><span class="p">:</span>
        <span class="n">node_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
            <span class="n">HistoryDagNode</span><span class="p">(</span>
                <span class="n">leaf_label</span><span class="p">,</span>
                <span class="p">{},</span>
                <span class="p">{},</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">history_dag_from_nodes</span><span class="p">(</span><span class="n">node_set</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Will Dumm.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>